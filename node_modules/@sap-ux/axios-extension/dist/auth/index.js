"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReentranceTicketAuthInterceptor = exports.attachReentranceTicketAuthInterceptor = exports.attachUaaAuthInterceptor = exports.attachBasicAuthInterceptor = exports.Uaa = void 0;
const axios_1 = require("axios");
const reentrance_ticket_1 = require("./reentrance-ticket");
const uaa_1 = require("./uaa");
Object.defineProperty(exports, "Uaa", { enumerable: true, get: function () { return uaa_1.Uaa; } });
__exportStar(require("./connection"), exports);
__exportStar(require("./error"), exports);
/**
 * @param provider Basic Auth Provider
 */
function attachBasicAuthInterceptor(provider) {
    const oneTimeInterceptorId = provider.interceptors.response.use((response) => {
        delete provider.defaults.auth;
        provider.interceptors.response.eject(oneTimeInterceptorId);
        return response;
    });
}
exports.attachBasicAuthInterceptor = attachBasicAuthInterceptor;
/**
 * @param provider  Abap Service Provider
 * @param service Service Information
 * @param refreshToken refreshToken
 * @param refreshTokenUpdateCb refreshTokenUpdate callback function
 */
function attachUaaAuthInterceptor(provider, service, refreshToken, refreshTokenUpdateCb) {
    const uaa = new uaa_1.Uaa(service, provider.log);
    let token;
    const getToken = () => __awaiter(this, void 0, void 0, function* () {
        var _a;
        return ((_a = service.uaa) === null || _a === void 0 ? void 0 : _a.username)
            ? yield uaa.getAccessTokenWithClientCredentials()
            : yield uaa.getAccessToken(refreshToken, refreshTokenUpdateCb);
    });
    // provide function to fetch user info from UAA if needed
    provider.user = () => __awaiter(this, void 0, void 0, function* () {
        token = token !== null && token !== void 0 ? token : (yield getToken());
        return uaa.getUserInfo(token);
    });
    provider.interceptors.request.use((request) => __awaiter(this, void 0, void 0, function* () {
        var _b;
        token = token !== null && token !== void 0 ? token : (yield getToken());
        // add token as auth header
        request.headers = (_b = request.headers) !== null && _b !== void 0 ? _b : new axios_1.AxiosHeaders();
        request.headers.authorization = `bearer ${token}`;
        return request;
    }));
}
exports.attachUaaAuthInterceptor = attachUaaAuthInterceptor;
/**
 * Get the reentrace ticket from the backend and add it to the header.
 *
 * @param options options
 * @param options.provider an instance of an ABAP service provider
 */
function attachReentranceTicketAuthInterceptor({ provider }) {
    /* This cannot be a const like eslint claims */
    /* eslint-disable prefer-const */
    let oneTimeInterceptorId;
    const ejectCallback = () => provider.interceptors.request.eject(oneTimeInterceptorId);
    oneTimeInterceptorId = provider.interceptors.request.use(getReentranceTicketAuthInterceptor({ provider, ejectCallback }));
}
exports.attachReentranceTicketAuthInterceptor = attachReentranceTicketAuthInterceptor;
/**
 * Get the interceptor that fetches and uses reentrance tickets from the backend.
 *
 * @param options options
 * @param options.provider an instance of an ABAP service provider
 * @param options.ejectCallback  eject Callback Function
 * @returns the interceptor function to fetch and use reentrace tickets
 */
function getReentranceTicketAuthInterceptor({ provider, ejectCallback }) {
    return (request) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const { reentranceTicket, apiUrl } = yield (0, reentrance_ticket_1.getReentranceTicket)({
            backendUrl: provider.defaults.baseURL,
            logger: provider.log
        });
        if (apiUrl && apiUrl != provider.defaults.baseURL) {
            // Reentrance tickets work with API hostnames. If the original URL was not one, this will replace it
            // with the API hostname returned
            provider.log.warn(`Replacing provider's default base URL (${provider.defaults.baseURL}) with API URL: ${apiUrl}`);
            provider.defaults.baseURL = apiUrl;
        }
        request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : new axios_1.AxiosHeaders();
        request.headers.MYSAPSSO2 = reentranceTicket;
        // remove this interceptor since it is not needed anymore
        ejectCallback();
        return request;
    });
}
exports.getReentranceTicketAuthInterceptor = getReentranceTicketAuthInterceptor;
//# sourceMappingURL=index.js.map