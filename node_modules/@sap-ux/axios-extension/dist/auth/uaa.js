"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uaa = void 0;
const open = require("open");
const axios_1 = __importDefault(require("axios"));
const http_1 = __importDefault(require("http"));
const qs_1 = __importDefault(require("qs"));
const redirect_1 = require("./redirect");
const message_1 = require("../abap/message");
const error_1 = require("./error");
const static_1 = require("./static");
const connection_1 = require("./connection");
/**
 * A class representing interactions with an SAP BTP UAA service
 */
class Uaa {
    /**
     * @param serviceInfo service Information
     * @param log logger
     */
    constructor(serviceInfo, log) {
        this.log = log;
        this.validatePropertyExists(serviceInfo.uaa.clientid, 'Client ID missing');
        this.validatePropertyExists(serviceInfo.uaa.clientsecret, 'Client Secret missing');
        this.validatePropertyExists(serviceInfo.uaa.url, 'UAA URL missing');
        this.serviceInfo = serviceInfo;
    }
    /**
     * @param property property
     * @param errMsg error message
     */
    validatePropertyExists(property, errMsg) {
        if (!property) {
            throw Error(errMsg);
        }
    }
    /**
     * Getter for uaa url.
     *
     * @returns uaa url
     */
    get url() {
        return this.serviceInfo.uaa.url.replace(/\/?$/, '');
    }
    /**
     * Getter for client id.
     *
     * @returns client id
     */
    get clientid() {
        return this.serviceInfo.uaa.clientid;
    }
    /**
     * Getter for client secret.
     *
     * @returns client secret
     */
    get clientsecret() {
        return this.serviceInfo.uaa.clientsecret;
    }
    /**
     * Getter for logout url.
     *
     * @returns logout url
     */
    get logoutUrl() {
        return this.url + '/logout.do';
    }
    /**
     * Getter for system id.
     *
     * @returns system id
     */
    get systemId() {
        return this.serviceInfo.systemid;
    }
    /**
     * Getter for username.
     *
     * @returns system id
     */
    get username() {
        return this.serviceInfo.uaa.username;
    }
    /**
     * Getter for password.
     *
     * @returns system id
     */
    get password() {
        return this.serviceInfo.uaa.password;
    }
    /**
     * Generates a request url based on the provided redirect url.
     *
     * @param params config parameters
     * @param params.redirectUri redirect url
     * @returns authentication code request url
     */
    getAuthCodeUrl({ redirectUri }) {
        return (this.url +
            '/oauth/authorize?' +
            qs_1.default.stringify({
                'response_type': 'code',
                'redirect_uri': redirectUri,
                'client_id': this.clientid
            }));
    }
    /**
     * Generate an access token using grant_type password to the authorization service (XSUAA).
     *
     * @returns an axios request config
     */
    getTokenRequestForClientCredential() {
        const secret = `${this.clientid}:${this.clientsecret}`;
        return {
            url: `${this.url}/oauth/token`,
            method: 'POST',
            data: qs_1.default.stringify({
                'grant_type': 'password',
                'username': this.username,
                'password': this.password
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json',
                Authorization: `Basic ${Buffer.from(secret).toString('base64')}`
            }
        };
    }
    /**
     * Generate an Axios token request configuration for fetching a token.
     *
     * @param params config parameters
     * @param params.redirectUri redirect url
     * @param params.authCode authentication code
     * @returns an axios request config
     */
    getTokenRequestForAuthCode({ redirectUri, authCode }) {
        return {
            url: `${this.url}/oauth/token`,
            auth: { username: this.clientid, password: this.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                code: authCode,
                'grant_type': 'authorization_code',
                'redirect_uri': redirectUri,
                'response_type': 'token'
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    /**
     * Generate an Axios token request configuration for fetching a token.
     *
     * @param refreshToken existing refresh token
     * @returns an axios request config
     */
    getTokenRequestForRefreshToken(refreshToken) {
        return {
            url: `${this.url}/oauth/token`,
            auth: { username: this.clientid, password: this.clientsecret },
            method: 'POST',
            data: qs_1.default.stringify({
                'grant_type': 'refresh_token',
                'refresh_token': refreshToken
            }),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json'
            }
        };
    }
    /**
     * Get user information.
     *
     * @param accessToken valid access token
     * @returns user name or undefined
     */
    getUserInfo(accessToken) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const userInfoResp = yield axios_1.default.request({
                url: `${this.url}/userinfo`,
                method: 'GET',
                headers: {
                    authorization: `bearer ${accessToken}`
                }
            });
            return ((_a = userInfoResp === null || userInfoResp === void 0 ? void 0 : userInfoResp.data) === null || _a === void 0 ? void 0 : _a.email) || ((_b = userInfoResp === null || userInfoResp === void 0 ? void 0 : userInfoResp.data) === null || _b === void 0 ? void 0 : _b.name);
        });
    }
    /**
     * Get an authentication code.
     *
     * @param timeout timeout
     * @returns an object containing an authentication code and a redirect object
     */
    getAuthCode(timeout = connection_1.defaultTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                var _a;
                // eslint-disable-next-line prefer-const
                let redirect;
                // eslint-disable-next-line prefer-const
                let server;
                const handleTimeout = () => {
                    server === null || server === void 0 ? void 0 : server.close();
                    reject(new error_1.UAATimeoutError(`Timeout. Did not get a response within ${(0, message_1.prettyPrintTimeInMs)(timeout)}`));
                };
                const timer = setTimeout(handleTimeout, timeout);
                server = http_1.default.createServer((req, res) => {
                    const reqUrl = new URL(req.url, `http://${req.headers.host}`);
                    if (reqUrl.pathname === redirect_1.Redirect.path) {
                        res.writeHead(200, { 'Content-Type': 'text/html' });
                        res.end(Buffer.from((0, static_1.redirectSuccessHtml)(this.logoutUrl, this.systemId)));
                        this.log.info('Got authCode');
                        resolve({ authCode: reqUrl.searchParams.get('code') + '', redirect });
                        if (timer) {
                            clearTimeout(timer);
                        }
                        server.close();
                    }
                });
                // Start listening. Let the OS assign an available port
                server.listen();
                redirect = new redirect_1.Redirect(server.address().port);
                const oauthUrl = this.getAuthCodeUrl({ redirectUri: redirect.url() });
                (_a = open(oauthUrl)) === null || _a === void 0 ? void 0 : _a.catch((error) => this.log.error(error));
            });
        });
    }
    /**
     * @param refreshToken refreshToken
     * @param refreshTokenChangedCb refreshTokenChanged callback function
     * @returns an access token.
     */
    getAccessToken(refreshToken, refreshTokenChangedCb) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            let startFreshLogin = false;
            let newRefreshToken;
            if (refreshToken) {
                this.log.info('Refresh token passed in');
                const tokenRequest = this.getTokenRequestForRefreshToken(refreshToken);
                try {
                    response = yield axios_1.default.request(tokenRequest);
                    // Has refresh token expired?
                    if (response.status === 401 || response.data.error === 'invalid_token') {
                        startFreshLogin = true;
                        this.log.warn('Cannot use stored refresh token. Starting fresh request');
                    }
                    else if (refreshToken !== response.data.refresh_token) {
                        this.log.info('New refresh token issued');
                        newRefreshToken = response.data.refresh_token;
                    }
                }
                catch (e) {
                    startFreshLogin = true;
                }
            }
            if (!refreshToken || startFreshLogin) {
                const { authCode, redirect } = yield this.getAuthCode();
                const tokenRequest = this.getTokenRequestForAuthCode({
                    redirectUri: redirect.url(), // Redirection URL needs to match
                    authCode
                });
                response = yield axios_1.default.request(tokenRequest);
                this.log.info('Refresh token issued');
                newRefreshToken = response.data.refresh_token;
            }
            if (refreshTokenChangedCb) {
                this.log.info('Sending notification that refresh token changed');
                yield refreshTokenChangedCb(newRefreshToken, (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.access_token);
            }
            this.log.info('Got access token successfully');
            return (_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.access_token;
        });
    }
    /**
     * Retrieve an access token using the client credentials.
     *
     * @returns an access token using the BTP UAA credentials
     */
    getAccessTokenWithClientCredentials() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const tokenRequest = this.getTokenRequestForClientCredential();
            const response = yield axios_1.default.request(tokenRequest);
            this.log.info('Got access token successfully using client credentials');
            return (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.access_token;
        });
    }
}
exports.Uaa = Uaa;
//# sourceMappingURL=uaa.js.map