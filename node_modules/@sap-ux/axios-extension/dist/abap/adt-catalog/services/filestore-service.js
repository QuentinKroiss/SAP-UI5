"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStoreService = void 0;
const adt_service_1 = require("./adt-service");
const fast_xml_parser_1 = require("fast-xml-parser");
/**
 * FileStoreService implements ADT requests to obtain the content
 * of deployed archive.
 */
class FileStoreService extends adt_service_1.AdtService {
    /**
     * Get ADT scheme ID.
     *
     * @returns AdtCategory
     */
    static getAdtCatagory() {
        return FileStoreService.adtCategory;
    }
    /**
     * If target `path` is a file, the file content is returned as string type.
     * If target `path` is a folder, files and folders in this folder are returned as an array
     * of ArchiveFileNode objects.
     *
     * @see ArchiveFileNode
     * @param type
     *  Specifies if input `path` refers to a file or a folder. When starting exploring
     *  the file structure from the root, type should be set to `folder`. The type information
     *  of files and folders inside root folder can be found in the returned `ArchiveFileNode` entries.
     * @param appName Deployed Fiori app name
     * @param path
     *   Default value is empty string. In this case the output would be folder structure information of the root folder.
     *   Otherwise provide path to a folder or a file in the deployed archive. E.g. `/webapp/index.html`.
     * @returns Folder content (ArchiveFileNode[]) | file content (string)
     */
    getAppArchiveContent(type, appName, path = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = type === 'folder' ? 'application/atom+xml' : 'application/octet-stream';
            const config = {
                headers: {
                    Accept: 'application/xml',
                    'Content-Type': contentType
                }
            };
            if (path && !path.startsWith('/')) {
                throw new Error('Input argument "path" needs to start with /');
            }
            const encodedFullPath = encodeURIComponent(`${appName}${path}`);
            const response = yield this.get(`/${encodedFullPath}/content`, config);
            return this.parseArchiveContentResponse(appName, response.data, type);
        });
    }
    /**
     * Parse response data from ADT service. If the content is XML document of
     * folder structure, this method returns a list of `ArchiveFileNode` object. If the content
     * is text string, this method returns the text cotent.
     *
     * @see ArchiveFileNode
     * @param appName Deployed Fiori app name
     * @param responseData Response from ADT service
     * @param type Reponse data is the file content or folder content.
     * @returns Folder content (ArchiveFileNode[]) | file content (string)
     */
    parseArchiveContentResponse(appName, responseData, type) {
        // File content that is not xml data.
        if (type === 'file') {
            return responseData;
        }
        // A list of file/folder items in the response data as xml string.
        if (fast_xml_parser_1.XMLValidator.validate(responseData) !== true) {
            throw new Error('Invalid XML content');
        }
        const options = {
            attributeNamePrefix: '',
            ignoreAttributes: false,
            ignoreNameSpace: true,
            parseAttributeValue: true,
            removeNSPrefix: true
        };
        const parser = new fast_xml_parser_1.XMLParser(options);
        const parsed = parser.parse(responseData, true);
        let fileNodeArray = [];
        if (parsed === null || parsed === void 0 ? void 0 : parsed.feed) {
            if (Array.isArray(parsed.feed.entry)) {
                fileNodeArray = parsed.feed.entry;
            }
            else {
                fileNodeArray = [parsed.feed.entry];
            }
        }
        return fileNodeArray.map((fileNode) => {
            const exposedFileNode = {
                basename: fileNode.title.split('/').pop(),
                path: fileNode.title.substring(appName.length),
                type: fileNode.category.term
            };
            return exposedFileNode;
        });
    }
}
exports.FileStoreService = FileStoreService;
/**
 * @see AdtService.getAdtCatagory()
 */
FileStoreService.adtCategory = {
    scheme: 'http://www.sap.com/adt/categories/filestore',
    term: 'filestore-ui5-bsp'
};
//# sourceMappingURL=filestore-service.js.map