"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.V2CatalogService = void 0;
const base_1 = require("./base");
const odata_service_1 = require("../../base/odata-service");
const odata_request_error_1 = require("../../base/odata-request-error");
const V2_CLASSIC_ENTITYSET = 'ServiceCollection';
const V2_RECOMMENDED_ENTITYSET = 'RecommendedServiceCollection';
const V2_S4CLOUD_FILTER = '((IsSapService%20eq%20true)and(ReleaseStatus%20eq%20%27RELEASED%27))or((IsSapService%20eq%20false))';
/**
 * OData V2 specific implmentation of SAP's catalog service
 */
class V2CatalogService extends base_1.CatalogService {
    determineEntitySet() {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.document();
            this.entitySet = doc.EntitySets.includes(V2_RECOMMENDED_ENTITYSET)
                ? V2_RECOMMENDED_ENTITYSET
                : V2_CLASSIC_ENTITYSET;
        });
    }
    /**
     * Map the V2 service information to a version independent structure.
     *
     * @param services v2 services information
     * @returns version independent information
     */
    mapServices(services) {
        return services.map((service) => {
            return {
                id: service.ID,
                name: service.TechnicalServiceName,
                path: new URL(service.ServiceUrl).pathname,
                serviceVersion: service.TechnicalServiceVersion + '',
                odataVersion: odata_service_1.ODataVersion.v2
            };
        });
    }
    /**
     * Fetch all services from the backend.
     *
     * @returns version independent service information
     */
    fetchServices() {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                $format: 'json'
            };
            if (!this.entitySet) {
                yield this.determineEntitySet();
            }
            if (this.entitySet === V2_CLASSIC_ENTITYSET && (yield this.isS4Cloud)) {
                params['$filter'] = V2_S4CLOUD_FILTER;
            }
            const response = yield this.get(`/${this.entitySet}`, { params });
            const data = response.odata();
            // check if the service responded with an odata error
            if (odata_request_error_1.ODataRequestError.containsError(data)) {
                throw new odata_request_error_1.ODataRequestError(data);
            }
            return this.mapServices(data);
        });
    }
    /**
     * Find a specific service by title.
     *
     * @param filter filter options
     * @param filter.title filter by title
     * @param filter.path filter by path
     * @returns service information matching the given filter
     */
    findService({ title, path }) {
        return __awaiter(this, void 0, void 0, function* () {
            let version = 1;
            if (!title) {
                const titleWithParameters = path.replace(/\/$/, '').split('/').pop().split(';');
                title = titleWithParameters[0].toUpperCase();
                if (!title) {
                    throw new Error(`Cannot determine service title from path: ${path}`);
                }
                const segParams = titleWithParameters.slice(1);
                segParams.forEach((parameter) => {
                    const [key, value] = parameter.split('=');
                    if (key === 'v') {
                        version = parseInt(value, 10);
                    }
                });
            }
            const params = {
                $format: 'json',
                $filter: `Title eq '${title}' and TechnicalServiceVersion eq ${version}`
            };
            const response = yield this.get(`/${this.entitySet}`, { params });
            const services = response.odata();
            if (services.length > 1) {
                // #14793: Fix for user created multi namespaces for the same service
                const servicesWithSameNameSpace = services.filter((service) => { var _a; return (_a = service.ServiceUrl) === null || _a === void 0 ? void 0 : _a.toUpperCase().includes((path || title).toUpperCase()); });
                if (servicesWithSameNameSpace.length > 1) {
                    this.log.warn('Service filter was not sufficient to identify one service.');
                }
                else if (servicesWithSameNameSpace.length > 0) {
                    this.log.info(`Service filter chose service: ${servicesWithSameNameSpace[0].TechnicalServiceName}`);
                    return servicesWithSameNameSpace[0];
                }
            }
            return services.length > 0 ? services[0] : undefined;
        });
    }
    /**
     * Get service annotations for the service matching the given filter.
     *
     * @param filter filter options
     * @param filter.id filter by id
     * @param filter.title filter by title
     * @param filter.path filter by path
     * @returns service annotations
     */
    getServiceAnnotations({ id, title, path }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.entitySet) {
                yield this.determineEntitySet();
            }
            if (!id) {
                const ServiceConfig = yield this.findService({ title, path });
                if (ServiceConfig) {
                    id = ServiceConfig.ID;
                }
            }
            if (id) {
                const response = yield this.get(`/${this.entitySet}('${encodeURIComponent(id)}')/Annotations`, {
                    params: { $format: 'json' }
                });
                return response.odata();
            }
            else {
                return [];
            }
        });
    }
    /**
     * Get all annotations available for the service matching one of the below filter options.
     *
     * @param filter filter options
     * @param filter.id filter by id
     * @param filter.title filter by title
     * @param filter.path filter by path
     * @returns annotations
     */
    getAnnotations({ id, title, path }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!id && !title && !path) {
                throw new Error('No filter parameters passed in');
            }
            const serviceAnnotations = yield this.getServiceAnnotations({ id, title, path });
            const annotations = [];
            for (const service of serviceAnnotations) {
                const _path = `/Annotations(TechnicalName='${encodeURIComponent(service.TechnicalName)}',Version='${service.Version}')/$value/`;
                const response = yield this.get(_path, {
                    headers: {
                        Accept: 'application/xml'
                    }
                });
                if (response.data) {
                    annotations.push({
                        TechnicalName: service.TechnicalName,
                        Version: service.Version,
                        Definitions: response.data,
                        Uri: this.defaults.baseURL + _path
                    });
                }
                else {
                    this.log.warn(`No annotations found for TechnicalName=${service.TechnicalName}, Version=${service.Version}`);
                }
            }
            return annotations;
        });
    }
}
exports.V2CatalogService = V2CatalogService;
V2CatalogService.PATH = '/sap/opu/odata/IWFND/CATALOGSERVICE;v=2';
//# sourceMappingURL=v2-catalog-service.js.map