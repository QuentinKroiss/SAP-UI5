"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayeredRepositoryService = void 0;
const axios_1 = require("axios");
const logger_1 = require("@sap-ux/logger");
const fs_1 = require("fs");
const odata_request_error_1 = require("../base/odata-request-error");
/**
 * Returns the namespace as string.
 *
 * @param namespace either as string or as object
 * @returns serialized namespace
 */
function getNamespaceAsString(namespace) {
    return typeof namespace !== 'string' ? `apps/${namespace['reference']}/appVariants/${namespace['id']}/` : namespace;
}
/**
 * Check if a variable is a buffer.
 *
 * @param input variable to be checked
 * @returns true if the input is a buffer
 */
function isBuffer(input) {
    return input.BYTES_PER_ELEMENT !== undefined;
}
/**
 * Path suffix for all DTA actions.
 */
const DTA_PATH_SUFFIX = '/dta_folder/';
/**
 * A class representing the design time adaptation service allowing to deploy adaptation projects to an ABAP system.
 */
class LayeredRepositoryService extends axios_1.Axios {
    /**
     * Simple request to fetch a CSRF token required for all writing operations.
     *
     * @returns the response
     */
    getCsrfToken() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.get('/actions/getcsrftoken/');
            }
            catch (error) {
                if ((0, odata_request_error_1.isAxiosError)(error)) {
                    this.tryLogResponse(error.response);
                }
                throw error;
            }
        });
    }
    /**
     * Merge a given app descriptor variant with the stord app descriptor.
     *
     * @param appDescriptorVariant zip file containing an app descriptor variant
     * @returns a promise with an object containing merged app descriptors with their id as keys.
     */
    mergeAppDescriptorVariant(appDescriptorVariant) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.put('/appdescr_variant_preview/', appDescriptorVariant, {
                    headers: {
                        'Content-Type': 'application/zip'
                    }
                });
                return JSON.parse(response.data);
            }
            catch (error) {
                if ((0, odata_request_error_1.isAxiosError)(error)) {
                    this.tryLogResponse(error.response);
                }
                throw error;
            }
        });
    }
    /**
     * Check whether a variant with the given namespace already exists.
     *
     * @param namespace either as string or as object
     * @param [layer] optional layer
     * @returns the Axios response object for further processing
     */
    isExistingVariant(namespace, layer = 'CUSTOMER_BASE') {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.get(DTA_PATH_SUFFIX, {
                    params: {
                        name: getNamespaceAsString(namespace),
                        layer,
                        timestamp: Date.now()
                    }
                });
                this.tryLogResponse(response);
                return response;
            }
            catch (error) {
                if ((0, odata_request_error_1.isAxiosError)(error)) {
                    this.tryLogResponse(error.response);
                    if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                        return error.response;
                    }
                }
                throw error;
            }
        });
    }
    /**
     * Deploy the given archive either by creating a new folder in the layered repository or updating an existing one.
     *
     * @param archive path to a zip archive or archive as buffer containing the adaptation project
     * @param config adataption project deployment configuration
     * @returns the Axios response object for futher processing
     */
    deploy(archive, config) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const data = isBuffer(archive) ? archive : (0, fs_1.readFileSync)(archive);
            const checkResponse = yield this.isExistingVariant(config.namespace);
            const params = {
                name: getNamespaceAsString(config.namespace),
                layer: (_a = config.layer) !== null && _a !== void 0 ? _a : 'CUSTOMER_BASE'
            };
            params['package'] = (_b = config.package) !== null && _b !== void 0 ? _b : '$TMP';
            if (params['package'].toUpperCase() !== '$TMP') {
                params['changelist'] = config.transport;
            }
            const response = yield this.request({
                method: checkResponse.status === 200 ? 'PUT' : 'POST',
                url: DTA_PATH_SUFFIX,
                data,
                params,
                headers: {
                    'Content-Type': 'application/octet-stream'
                }
            });
            this.tryLogResponse(response, 'Deployment successful.');
            return response;
        });
    }
    /**
     * Undeploy the archive identified by the configuration.
     *
     * @param config adaptation project deployment configuration
     * @returns the Axios response object for further processing
     */
    undeploy(config) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const checkResponse = yield this.isExistingVariant(config.namespace);
            if (checkResponse.status !== 200) {
                throw new Error('Undeploy failed because the given project does not exist.');
            }
            const params = {
                name: getNamespaceAsString(config.namespace),
                layer: (_a = config.layer) !== null && _a !== void 0 ? _a : 'CUSTOMER_BASE'
            };
            if (config.transport) {
                params['changelist'] = config.transport;
            }
            try {
                const response = yield this.delete(DTA_PATH_SUFFIX, { params });
                this.tryLogResponse(response, 'Undeployment successful.');
                return response;
            }
            catch (error) {
                this.log.error('Undeployment failed');
                this.log.debug(error);
                if ((0, odata_request_error_1.isAxiosError)(error) && ((_b = error.response) === null || _b === void 0 ? void 0 : _b.status) === 405) {
                    this.log.error('Newer version of SAP_UI required, please check https://help.sap.com/docs/bas/developing-sap-fiori-app-in-sap-business-application-studio/delete-adaptation-project');
                }
                throw error;
            }
        });
    }
    /**
     * Try parsing the response and log the result. If the parsing fails and an alternative is provided, log it instead.
     *
     * @param response axios response from the LREP service
     * @param alternativeMessage optional alternative message if the response cannot be parsed
     */
    tryLogResponse(response, alternativeMessage) {
        var _a;
        try {
            const info = response.data ? JSON.parse(response.data) : {};
            if (info.result) {
                this.logMessage(info.result);
            }
            ((_a = info.messages) !== null && _a !== void 0 ? _a : []).forEach((message) => {
                this.logMessage(message);
            });
        }
        catch (error) {
            if (alternativeMessage) {
                this.log.info(alternativeMessage);
            }
            this.log.warn('Could not parse returned messages.');
        }
    }
    /**
     * Log a message from the backend.
     *
     * @param msg message to be logged
     */
    logMessage(msg) {
        var _a;
        const level = msg.severity === 'Error' ? logger_1.LogLevel.Error : logger_1.LogLevel.Info;
        this.log.log({ level, message: msg.text });
        ((_a = msg.details) !== null && _a !== void 0 ? _a : []).forEach((message) => {
            this.log.log({ level, message });
        });
    }
}
exports.LayeredRepositoryService = LayeredRepositoryService;
LayeredRepositoryService.PATH = '/sap/bc/lrep';
//# sourceMappingURL=lrep-service.js.map