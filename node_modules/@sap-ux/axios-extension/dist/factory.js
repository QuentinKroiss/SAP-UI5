"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServiceForUrl = exports.createForDestination = exports.createForAbapOnCloud = exports.AbapCloudEnvironment = exports.createForAbap = exports.create = void 0;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const btp_utils_1 = require("@sap-ux/btp-utils");
const https_1 = require("https");
const auth_1 = require("./auth");
const service_provider_1 = require("./base/service-provider");
const abap_1 = require("./abap");
const util_1 = require("util");
/**
 * Create a new instance of given type and set default configuration merged with the given config.
 *
 * @param ProviderType class that will be instantiated
 * @param config axios config with additional extension specific properties
 * @returns instance of the provided class
 */
function createInstance(ProviderType, config) {
    var _a, _b;
    const providerConfig = (0, cloneDeep_1.default)(config);
    providerConfig.httpsAgent = new https_1.Agent({
        rejectUnauthorized: !providerConfig.ignoreCertErrors
    });
    delete providerConfig.ignoreCertErrors;
    providerConfig.withCredentials = (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.auth) && Object.keys(providerConfig.auth).length > 0;
    /**
     * Make axios throw an error for 4xx errors.
     *
     * @param status - http response status
     * @returns success (true) or error (false)
     */
    providerConfig.validateStatus = (status) => status < 400;
    const instance = new ProviderType(providerConfig);
    instance.defaults.headers = (_a = instance.defaults.headers) !== null && _a !== void 0 ? _a : {
        common: {},
        'delete': {},
        put: {},
        get: {},
        post: {},
        head: {},
        patch: {}
    };
    (0, auth_1.attachConnectionHandler)(instance);
    if ((_b = providerConfig.auth) === null || _b === void 0 ? void 0 : _b.password) {
        (0, auth_1.attachBasicAuthInterceptor)(instance);
    }
    if (config.cookies) {
        config.cookies.split(';').forEach((singleCookieStr) => {
            instance.cookies.addCookie(singleCookieStr.trim());
        });
    }
    return instance;
}
/**
 * Create an instance of a basic service provider.
 *
 * @param config axios config with additional extension specific properties
 * @returns instance of the basic service provider
 */
function create(config) {
    if (typeof config === 'string') {
        return createInstance(service_provider_1.ServiceProvider, {
            baseURL: config
        });
    }
    else {
        return createInstance(service_provider_1.ServiceProvider, config);
    }
}
exports.create = create;
/**
 * Create an instance of an ABAP service provider.
 *
 * @param config axios config with additional extension specific properties
 * @returns instance of an ABAP service provider
 */
function createForAbap(config) {
    return createInstance(abap_1.AbapServiceProvider, config);
}
exports.createForAbap = createForAbap;
/** Supported ABAP environments on the cloud */
var AbapCloudEnvironment;
(function (AbapCloudEnvironment) {
    AbapCloudEnvironment["Standalone"] = "Standalone";
    AbapCloudEnvironment["EmbeddedSteampunk"] = "EmbeddedSteampunk";
})(AbapCloudEnvironment || (exports.AbapCloudEnvironment = AbapCloudEnvironment = {}));
/**
 * Create an instance of an ABAP service provider for a Cloud ABAP system.
 *
 * @param options {@link AbapCloudOptions}
 * @returns instance of an {@link AbapServiceProvider}
 */
function createForAbapOnCloud(options) {
    let provider;
    switch (options.environment) {
        case AbapCloudEnvironment.Standalone: {
            const { service, refreshToken, refreshTokenChangedCb, cookies } = options, config = __rest(options, ["service", "refreshToken", "refreshTokenChangedCb", "cookies"]);
            provider = createInstance(abap_1.AbapServiceProvider, Object.assign({ baseURL: service.url, cookies }, config));
            if (!cookies) {
                (0, auth_1.attachUaaAuthInterceptor)(provider, service, refreshToken, refreshTokenChangedCb);
            }
            break;
        }
        case AbapCloudEnvironment.EmbeddedSteampunk: {
            const { url, cookies } = options, config = __rest(options, ["url", "cookies"]);
            provider = createInstance(abap_1.AbapServiceProvider, Object.assign({ baseURL: url }, config));
            if (!cookies) {
                (0, auth_1.attachReentranceTicketAuthInterceptor)({ provider });
            }
            break;
        }
        default:
            const opts = options;
            throw new Error(`Unknown environment type supplied: ${(0, util_1.inspect)(opts)}`);
    }
    return provider;
}
exports.createForAbapOnCloud = createForAbapOnCloud;
/**
 * Create an instance of a service provider for the given destination.
 *
 * @param options axios config with additional extension specific properties
 * @param destination destination config
 * @param destinationServiceInstance optional id of a destination service instance providing the destination
 * @returns instance of a service provider
 */
function createForDestination(options, destination, destinationServiceInstance) {
    var _a;
    const { cookies } = options, config = __rest(options, ["cookies"]);
    const providerConfig = Object.assign(Object.assign({}, config), { baseURL: (0, btp_utils_1.getDestinationUrlForAppStudio)(destination.Name, destination.Host ? new URL(destination.Host).pathname : undefined), cookies: cookies });
    // SAML in AppStudio is not yet supported
    providerConfig.params = (_a = providerConfig.params) !== null && _a !== void 0 ? _a : {};
    providerConfig.params.saml2 = 'disabled';
    let provider;
    if ((0, btp_utils_1.isAbapSystem)(destination)) {
        provider = createInstance(abap_1.AbapServiceProvider, providerConfig);
        // For an ABAP destination flow, need to show the destination host URL property instead of the BAS host URL i.e. https://mydest.dest
        provider.publicUrl = destination.Host;
    }
    else {
        provider = createInstance(service_provider_1.ServiceProvider, providerConfig);
    }
    // resolve destination service user on first request if required
    if (destinationServiceInstance) {
        const oneTimeReqInterceptorId = provider.interceptors.request.use((request) => __awaiter(this, void 0, void 0, function* () {
            const credentials = yield (0, btp_utils_1.getCredentialsForDestinationService)(destinationServiceInstance);
            provider.defaults.headers.common[btp_utils_1.BAS_DEST_INSTANCE_CRED_HEADER] = credentials;
            provider.interceptors.request.eject(oneTimeReqInterceptorId);
            return request;
        }));
    }
    return provider;
}
exports.createForDestination = createForDestination;
/**
 * Create an instance of a basic service provider and then generate an extension for a service based on the given url.
 *
 * @param url full url pointing to a service
 * @param config axios config with additional extension specific properties
 * @returns instance of a service
 */
function createServiceForUrl(url, config = {}) {
    const urlObject = new URL(url);
    config.baseURL = urlObject.origin;
    config.params = urlObject.searchParams;
    const provider = createInstance(service_provider_1.ServiceProvider, config);
    return provider.service(urlObject.pathname);
}
exports.createServiceForUrl = createServiceForUrl;
//# sourceMappingURL=factory.js.map