import type { YAMLMap } from 'yaml';
import { YAMLSeq } from 'yaml';
export interface NodeComment<T> {
    path: string;
    comment: string;
}
/**
 * Represents a yaml document with utility functions to manipulate the document.
 *
 * @class YamlDocument
 */
export declare class YamlDocument {
    private documents;
    /**
     * Returns a new instance of YamlDocument.
     *
     * @static
     * @param {string} serializedYaml - the serialized yaml string
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    static newInstance(serializedYaml: string): Promise<YamlDocument>;
    /**
     * Creates an instance of YamlDocument.
     *
     * @param {string} serializedYaml - the serialized yaml string
     * @memberof YamlDocument
     */
    private constructor();
    /**
     * Returns a string representation of the yaml document.
     *
     * @returns {string} the string representation
     * @memberof YamlDocument
     */
    toString(): string;
    /**
     * Adds a comment to the yaml document.
     *
     * @param root0 - the comment object
     * @param root0.comment - the comment object's comment
     * @param root0.location - the comment object's location
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    addDocumentComment({ comment, location }: {
        comment: string;
        location?: 'beginning' | 'end';
    }): YamlDocument;
    /**
     * Set the value at a given path.
     *
     * @param path - hierarchical path where the node will be inserted/updated
     * @param path.path - the path object's path
     * @param path.value - the path object's value
     * @param path.createIntermediateKeys - create the intermediate keys if they're missing. Error if not
     * @param path.comment - an optional comment
     * @example
     * If the document is:
     * key1:
     *   key2: value2
     *   key3:
     *     key4:
     *       - item: item1
     *       - item: item2
     *
     * To set the second item, the path will be `key1.key3.key4.1.item`
     * To set key2's value: `key1.key2`
     * To set a property at the root: 'keyX'
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    setIn({ path, value, createIntermediateKeys, comment }: {
        path: string;
        value: unknown;
        createIntermediateKeys?: boolean;
        comment?: string;
    }): YamlDocument;
    /**
     * Appends a node to a sequence in the document.
     *
     * @param path - hierarchical path where the node will be inserted/updated
     * @param {string} path.path - the path object's path
     * @param {object} path.value - the path object's value
     * @param {boolean} path.createIntermediateKeys - create the intermediate keys if they're missing. Error if not
     * @param path.nodeComment - optional comment to add to the node
     * @param path.comments - optional comments for subnodes in value being added
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    appendTo<T = unknown>({ path, value, createIntermediateKeys, nodeComment, comments }: {
        path: string;
        value: T;
        createIntermediateKeys?: boolean;
        nodeComment?: string;
        comments?: Array<NodeComment<T>>;
    }): YamlDocument;
    /**
     * Updates a node in a sequence in the document.
     *
     * @param path - hierarchical path where the node will be inserted/updated
     * @param {string} path.path - the path object's path
     * @param {object} path.matcher - key/value pair identifying the object
     * @param {object} path.value - the path object's value
     * @param path.matcher.key - name of the key
     * @param path.matcher.value - value of the key
     * @param {'merge' | 'overwrite'} [path.mode] - optional update mode: merge or overwrite, default is merge
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    updateAt<T = unknown>({ path, matcher, value, mode }: {
        path: string;
        matcher: {
            key: string;
            value: string;
        };
        value: T;
        mode?: 'merge' | 'overwrite';
    }): YamlDocument;
    /**
     * Deletes a node in a sequence in the document.
     *
     * @param path - hierarchical path where the node will be deleted
     * @param {string} path.path - the path object's path
     * @param {object} path.matcher - key/value pair identifying the object
     * @param {string} path.matcher.key - the key
     * @param {string} path.matcher.value - the value
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    deleteAt({ path, matcher }: {
        path: string;
        matcher: {
            key: string;
            value: string;
        };
    }): YamlDocument;
    /**
     * @param options - Options
     * @param options.start - Optional collection type to start looking from
     * @param options.path - String path of the node
     * @returns {unknown} - Node, if found. Will throw an error if not
     */
    getNode({ start, path }: {
        start?: YAMLMap | YAMLSeq;
        path: string;
    }): unknown;
    /**
     * @param options - Options
     * @param options.start - Optional collection type to start looking from
     * @param options.path - String path of the sequence
     * @returns {YAMLSeq} - Sequence, if found. Will throw an error if not
     */
    getSequence({ start, path }: {
        start?: YAMLMap | YAMLSeq;
        path: string;
    }): YAMLSeq;
    /**
     * @param options - Options
     * @param options.start - Optional collection type to start looking from
     * @param options.path - String path of the map
     * @returns {YAMLMap} - Map, if found. Will throw an error if not
     */
    getMap({ start, path }: {
        start?: YAMLMap | YAMLSeq;
        path: string;
    }): YAMLMap;
    /**
     * @param sequence - Sequence to find the item in
     * @param predicate - predicate function to determine the match
     * @returns {unknown} - Item node if found. Or undefined if not
     */
    findItem(sequence: YAMLSeq, predicate: (o: any) => boolean): unknown;
    /**
     * Converts to a path object to an array.
     *
     * @private
     * @template T
     * @param {string} path - string path
     * @returns {string[]} - the path array
     * @memberof YamlDocument
     */
    private toPathArray;
}
//# sourceMappingURL=yaml-document.d.ts.map