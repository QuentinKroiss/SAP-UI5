"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendPageJSON = exports.validatePageConfig = exports.initializeTargetSettings = exports.getFclConfig = exports.getManifestJsonExtensionHelper = exports.generateRouteTarget = exports.generateRoutePattern = exports.PATTERN_SUFFIX = void 0;
const mem_fs_1 = require("mem-fs");
const mem_fs_editor_1 = require("mem-fs-editor");
const path_1 = require("path");
const ejs_1 = require("ejs");
const validate_1 = require("../common/validate");
const defaults_1 = require("../common/defaults");
const file_1 = require("../common/file");
const templates_1 = require("../templates");
const semver_1 = require("semver");
/**
 * Suffix for patterns to support arbitrary paramters
 */
exports.PATTERN_SUFFIX = ':?query:';
/**
 * Generates the pattern for a new route based on the input.
 *
 * @param routes existing routes
 * @param targetEntity entity of the target
 * @param nav navigation object
 * @returns the generated pattern as string
 */
function generateRoutePattern(routes, targetEntity, nav) {
    var _a;
    const parts = [];
    if ((nav === null || nav === void 0 ? void 0 : nav.sourcePage) && nav.navEntity) {
        const sourceRoute = routes.find((route) => route.name === nav.sourcePage);
        if (sourceRoute === null || sourceRoute === void 0 ? void 0 : sourceRoute.pattern) {
            const basePattern = sourceRoute.pattern.replace(exports.PATTERN_SUFFIX, '');
            if (basePattern) {
                parts.push(basePattern);
                parts.push('/');
                parts.push(nav.navEntity);
            }
            else {
                parts.push(targetEntity);
            }
        }
        else {
            throw new Error('Navigation source invalid');
        }
    }
    else if (routes.length > 0) {
        parts.push(targetEntity);
    }
    if (nav === null || nav === void 0 ? void 0 : nav.navKey) {
        parts.push(`({${(_a = nav === null || nav === void 0 ? void 0 : nav.navEntity) !== null && _a !== void 0 ? _a : targetEntity}Key})`);
    }
    parts.push(exports.PATTERN_SUFFIX);
    return parts.join('');
}
exports.generateRoutePattern = generateRoutePattern;
/**
 * Generates the target property for a route based on exiting routes, configurations and the target's name.
 *
 * @param routes existing routes
 * @param name name of the target page
 * @param fcl optional flag if FCL is enabled
 * @param nav navigation object
 * @returns the target property of a route
 */
function generateRouteTarget(routes, name, fcl, nav) {
    var _a;
    if (nav === null || nav === void 0 ? void 0 : nav.sourcePage) {
        const sourceRoute = routes.find((route) => route.name === nav.sourcePage);
        // FCL only supports 3 columns, therefore, show the page in fullscreen if it is the 4th level of navigation
        if (fcl && ((_a = sourceRoute === null || sourceRoute === void 0 ? void 0 : sourceRoute.target) === null || _a === void 0 ? void 0 : _a.constructor) === Array && sourceRoute.target.length < 3) {
            return [...sourceRoute.target, name];
        }
    }
    return fcl ? [name] : name;
}
exports.generateRouteTarget = generateRouteTarget;
/**
 * Create a function that can be used as JsonReplace when calling extendJson.
 *
 * @param config page configuration
 * @returns a JsonReplacer function for the usage in ejs
 */
function getManifestJsonExtensionHelper(config) {
    return (key, value) => {
        var _a, _b, _c;
        switch (key) {
            case 'routing':
                value.routes = (_a = value.routes) !== null && _a !== void 0 ? _a : [];
                break;
            case 'routes':
                const routes = value;
                routes.push({
                    name: (_b = config.id) !== null && _b !== void 0 ? _b : `${config.entity}${config.name}`,
                    pattern: generateRoutePattern(routes, config.entity, config.navigation),
                    target: generateRouteTarget(routes, (_c = config.id) !== null && _c !== void 0 ? _c : `${config.entity}${config.name}`, config.fcl, config.navigation)
                });
                break;
            default:
                break;
        }
        return value;
    };
}
exports.getManifestJsonExtensionHelper = getManifestJsonExtensionHelper;
/**
 * Get the configuration parameters for the flexible column layout based on the given manifest and navigation config.
 *
 * @param manifest existing manifest
 * @param navigation navigation configuration that is to be added
 * @returns fcl configuration
 */
function getFclConfig(manifest, navigation) {
    var _a, _b, _c, _d, _e, _f;
    const config = {};
    if (((_c = (_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.routerClass) === defaults_1.FCL_ROUTER) {
        config.fcl = true;
        if (navigation) {
            const sourceRoute = (((_e = (_d = manifest['sap.ui5']) === null || _d === void 0 ? void 0 : _d.routing) === null || _e === void 0 ? void 0 : _e.routes) || []).find((route) => route.name === (navigation === null || navigation === void 0 ? void 0 : navigation.sourcePage));
            config.controlAggregation =
                ((_f = sourceRoute === null || sourceRoute === void 0 ? void 0 : sourceRoute.target) !== null && _f !== void 0 ? _f : []).length > 1 ? 'endColumnPages' : 'midColumnPages';
        }
        else {
            config.controlAggregation = 'beginColumnPages';
        }
    }
    return config;
}
exports.getFclConfig = getFclConfig;
/**
 * Create target settings for a Fiori elements page.
 *
 * @param data - incoming configuration
 * @param addSettings - optional arbitrary settings
 * @returns version aware settings object
 */
function initializeTargetSettings(data, addSettings) {
    var _a, _b;
    const settings = addSettings ? Object.assign({}, addSettings) : {};
    (_a = settings.navigation) !== null && _a !== void 0 ? _a : (settings.navigation = {});
    // starting with UI5 v1.94.0, contextPath is the preferred setting
    const minVersion = (0, semver_1.coerce)(data.minUI5Version);
    if (!minVersion || (0, semver_1.gte)(minVersion, '1.94.0')) {
        settings.contextPath = (_b = data.contextPath) !== null && _b !== void 0 ? _b : `/${data.entity}`;
    }
    else {
        settings.entitySet = data.entity;
    }
    return settings;
}
exports.initializeTargetSettings = initializeTargetSettings;
/**
 * Validate the input parameters for the generation of a custom or an object page.
 *
 * @param basePath - the base path
 * @param config - the custom page configuration
 * @param fs - the memfs editor instance
 * @returns the updated memfs editor instance
 */
function validatePageConfig(basePath, config, fs) {
    // common validators
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    (0, validate_1.validateBasePath)(basePath, fs);
    // validate config against the manifest
    if ((_a = config.navigation) === null || _a === void 0 ? void 0 : _a.sourcePage) {
        const manifest = fs.readJSON((0, path_1.join)(basePath, 'webapp/manifest.json'));
        if (!((_d = (_c = (_b = manifest['sap.ui5']) === null || _b === void 0 ? void 0 : _b.routing) === null || _c === void 0 ? void 0 : _c.targets) === null || _d === void 0 ? void 0 : _d[config.navigation.sourcePage])) {
            throw new Error(`Could not find navigation source ${config.navigation.sourcePage}!`);
        }
        const routes = {};
        if (((_g = (_f = (_e = manifest['sap.ui5']) === null || _e === void 0 ? void 0 : _e.routing) === null || _f === void 0 ? void 0 : _f.routes) === null || _g === void 0 ? void 0 : _g.constructor) === Array) {
            manifest['sap.ui5'].routing.routes.forEach((routeWithName) => {
                routes[routeWithName.name] = routeWithName;
            });
        }
        else {
            Object.assign(routes, (_k = (_j = (_h = manifest['sap.ui5']) === null || _h === void 0 ? void 0 : _h.routing) === null || _j === void 0 ? void 0 : _j.routes) !== null && _k !== void 0 ? _k : {});
        }
        const route = routes[config.navigation.sourcePage];
        if (!(route === null || route === void 0 ? void 0 : route.pattern) || !route.target) {
            throw new Error(`Invalid routing configuration for navigation source ${config.navigation.sourcePage}!`);
        }
    }
    return fs;
}
exports.validatePageConfig = validatePageConfig;
/**
 * Add an generic page to an existing UI5 application.
 * Supported pages - ListReport or ObjectPage.
 *
 * @param basePath - the base path
 * @param data - the page configuration
 * @param enhanceDataFn - Callback function for data enhancement
 * @param templatePath - path to 'manifest.json' template
 * @param fs - the memfs editor instance
 * @returns the updated memfs editor instance
 */
function extendPageJSON(basePath, data, enhanceDataFn, templatePath, fs) {
    if (!fs) {
        fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    }
    validatePageConfig(basePath, data, fs);
    const manifestPath = (0, path_1.join)(basePath, 'webapp/manifest.json');
    const manifest = fs.readJSON(manifestPath);
    const config = enhanceDataFn(data, manifest);
    // enhance manifest.json
    (0, file_1.extendJSON)(fs, {
        filepath: manifestPath,
        content: (0, ejs_1.render)(fs.read((0, templates_1.getTemplatePath)(templatePath)), config, {}),
        replacer: getManifestJsonExtensionHelper(config),
        tabInfo: data.tabInfo
    });
    return fs;
}
exports.extendPageJSON = extendPageJSON;
//# sourceMappingURL=common.js.map