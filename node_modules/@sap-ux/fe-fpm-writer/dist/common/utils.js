"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addExtensionTypes = exports.insertTextAtPosition = exports.insertTextAtAbsolutePosition = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const semver_1 = require("semver");
const templates_1 = require("../templates");
/**
 * Method inserts passed text into content by char index position.
 * In case if position is out of range, then whitespaces would be created.
 * Negative positions are not supported.
 *
 * @param {string} text - text to insert
 * @param {string} content - target content for update
 * @param {number} position - Char index position to insert in
 * @returns new content with inserted text
 */
function insertTextAtAbsolutePosition(text, content, position) {
    if (position < 0) {
        return content;
    }
    // Check if char position exist and create missing chars
    const prepareCharIndex = Math.max(position - 1, 0);
    while (prepareCharIndex > 0 && content[prepareCharIndex] === undefined) {
        content += ' ';
    }
    return `${content.slice(0, position)}${text}${content.slice(position)}`;
}
exports.insertTextAtAbsolutePosition = insertTextAtAbsolutePosition;
/**
 * Method inserts passed text into content by line and char position.
 * In case if position is out of range, then whitespaces would be created.
 * Negative positions are not supported.
 *
 * @param {string} text - text to insert
 * @param {string} content - target content for update
 * @param {FileContentPosition} position - Line and char position to insert in
 * @returns new content with inserted text
 */
function insertTextAtPosition(text, content, position) {
    if (position.line < 0 || position.character < 0) {
        return content;
    }
    const lines = content.split(/\r\n|\n/);
    let targetLine = lines[position.line];
    // Check if line position exist and create missing lines
    while (targetLine === undefined) {
        lines.push('');
        targetLine = lines[position.line];
    }
    // Update line with inserting passed text
    lines[position.line] = insertTextAtAbsolutePosition(text, lines[position.line], position.character);
    return lines.join(os_1.default.EOL);
}
exports.insertTextAtPosition = insertTextAtPosition;
/**
 * Adds type extensions for sap.fe types if an older version is used.
 * The types were fixed in 1.108 and downported to 1.102.
 *
 * @param basePath - the base path
 * @param minUI5Version - minimal required UI5 version
 * @param fs - the memfs editor instance
 */
function addExtensionTypes(basePath, minUI5Version, fs) {
    var _a;
    const version = (0, semver_1.minor)((_a = (0, semver_1.coerce)(minUI5Version)) !== null && _a !== void 0 ? _a : '1.108.0');
    const path = (0, path_1.join)(basePath, '/webapp/ext/sap.fe.d.ts');
    if (version < 108 && version !== 102 && !fs.exists(path)) {
        fs.copyTpl((0, templates_1.getTemplatePath)('common/sap.fe.d.ts'), path, { version });
    }
}
exports.addExtensionTypes = addExtensionTypes;
//# sourceMappingURL=utils.js.map