"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBuildingBlock = void 0;
const mem_fs_1 = require("mem-fs");
const mem_fs_editor_1 = require("mem-fs-editor");
const ejs_1 = require("ejs");
const path_1 = require("path");
const xmldom_1 = require("@xmldom/xmldom");
const xpath = __importStar(require("xpath"));
const xml_formatter_1 = __importDefault(require("xml-formatter"));
const validate_1 = require("../common/validate");
const templates_1 = require("../templates");
/**
 * Generates a building block into the provided xml view file.
 *
 * @param {string} basePath - the base path
 * @param {BuildingBlockConfig} config - the building block configuration parameters
 * @param {Editor} [fs] - the memfs editor instance
 * @returns {Editor} the updated memfs editor instance
 */
function generateBuildingBlock(basePath, config, fs) {
    // Validate the base and view paths
    if (!fs) {
        fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    }
    (0, validate_1.validateBasePath)(basePath, fs);
    if (!fs.exists((0, path_1.join)(basePath, config.viewOrFragmentPath))) {
        throw new Error(`Invalid view path ${config.viewOrFragmentPath}.`);
    }
    // Read the view xml and template files and update contents of the view xml file
    const xmlDocument = getUI5XmlDocument(basePath, config.viewOrFragmentPath, fs);
    const templateDocument = getTemplateDocument(config.buildingBlockData, xmlDocument, fs);
    fs = updateViewFile(basePath, config.viewOrFragmentPath, config.aggregationPath, xmlDocument, templateDocument, fs);
    return fs;
}
exports.generateBuildingBlock = generateBuildingBlock;
/**
 * Returns the UI5 xml file document (view/fragment).
 *
 * @param {string} basePath - the base path
 * @param {string} viewPath - the path of the xml view relative to the base path
 * @param {Editor} fs - the memfs editor instance
 * @returns {Document} the view xml file document
 */
function getUI5XmlDocument(basePath, viewPath, fs) {
    let viewContent;
    try {
        viewContent = fs.read((0, path_1.join)(basePath, viewPath));
    }
    catch (error) {
        throw new Error(`Unable to read xml view file. Details: ${(0, validate_1.getErrorMessage)(error)}`);
    }
    const errorHandler = (level, message) => {
        throw new Error(`Unable to parse xml view file. Details: [${level}] - ${message}`);
    };
    // Parse the xml view content
    let viewDocument;
    try {
        viewDocument = new xmldom_1.DOMParser({ errorHandler }).parseFromString(viewContent);
    }
    catch (error) {
        throw new Error(`Unable to parse xml view file. Details: ${(0, validate_1.getErrorMessage)(error)}`);
    }
    return viewDocument;
}
/**
 * Returns the macros namespace from the xml document if it exists or creates a new one and returns it.
 *
 * @param {Document} ui5XmlDocument - the view/fragment xml file document
 * @returns {string} the macros namespace
 */
function getOrAddMacrosNamespace(ui5XmlDocument) {
    const namespaceMap = ui5XmlDocument.firstChild._nsMap;
    const macrosNamespaceEntry = Object.entries(namespaceMap).find(([_, value]) => value === 'sap.fe.macros');
    if (!macrosNamespaceEntry) {
        ui5XmlDocument.firstChild._nsMap['macros'] = 'sap.fe.macros';
        ui5XmlDocument.documentElement.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:macros', 'sap.fe.macros');
    }
    return macrosNamespaceEntry ? macrosNamespaceEntry[0] : 'macros';
}
/**
 * Returns the template xml file document.
 *
 * @param {BuildingBlock} buildingBlockData - the building block data
 * @param {Document} viewDocument - the view xml file document
 * @param {Editor} fs - the memfs editor instance
 * @returns {Document} the template xml file document
 */
function getTemplateDocument(buildingBlockData, viewDocument, fs) {
    const templateFolderName = buildingBlockData.buildingBlockType;
    const templateFilePath = (0, templates_1.getTemplatePath)(`/building-block/${templateFolderName}/View.xml`);
    const templateContent = (0, ejs_1.render)(fs.read(templateFilePath), {
        macrosNamespace: getOrAddMacrosNamespace(viewDocument),
        data: buildingBlockData
    }, {});
    const errorHandler = (level, message) => {
        throw new Error(`Unable to parse template file with building block data. Details: [${level}] - ${message}`);
    };
    // Parse the rendered template content
    let templateDocument;
    try {
        templateDocument = new xmldom_1.DOMParser({ errorHandler }).parseFromString(templateContent);
    }
    catch (error) {
        throw new Error(`Unable to parse template file with building block data. Details: ${(0, validate_1.getErrorMessage)(error)}`);
    }
    return templateDocument;
}
/**
 * Updates the view file by inserting the template as a child of the element specified in the aggregated xpath.
 *
 * @param {string} basePath - the base path
 * @param {string} viewPath - the path of the xml view relative to the base path
 * @param {string} aggregationPath - the aggregation xpath
 * @param {Document} viewDocument - the view xml document
 * @param {Document} templateDocument - the template xml document
 * @param {Editor} [fs] - the memfs editor instance
 * @returns {Editor} the updated memfs editor instance
 */
function updateViewFile(basePath, viewPath, aggregationPath, viewDocument, templateDocument, fs) {
    const xpathSelect = xpath.useNamespaces(viewDocument.firstChild._nsMap);
    // Find target aggregated element and append template as child
    const targetNodes = xpathSelect(aggregationPath, viewDocument);
    if (targetNodes && Array.isArray(targetNodes) && targetNodes.length > 0) {
        const targetNode = targetNodes[0];
        const sourceNode = viewDocument.importNode(templateDocument.documentElement, true);
        targetNode.appendChild(sourceNode);
        // Serialize and format new view xml document
        const newXmlContent = new xmldom_1.XMLSerializer().serializeToString(viewDocument);
        fs.write((0, path_1.join)(basePath, viewPath), (0, xml_formatter_1.default)(newXmlContent));
    }
    else {
        throw new Error(`Aggregation control not found ${aggregationPath}.`);
    }
    return fs;
}
//# sourceMappingURL=index.js.map