"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonToI18nBundle = void 0;
const jsonc_parser_1 = require("jsonc-parser");
const utils_1 = require("../../parser/utils");
/**
 * Create text node value with its range.
 *
 * @param value node value
 * @param range node range
 * @returns text node with range info
 */
function createTextNode(value, range) {
    return {
        value,
        range
    };
}
/**
 * Convert a json node to text node with range information.
 *
 * @param node json node
 * @param lineOffsets line offsets
 * @param contentLength length of json content
 * @returns text node along its range or undefined
 */
function toTextNode(node, lineOffsets, contentLength) {
    if (!node) {
        return undefined;
    }
    let result;
    switch (typeof node.value) {
        case 'string': {
            // for string literals node offset starts with '"' character, but we don't include it in the text node range
            const start = (0, utils_1.positionAt)(lineOffsets, node.offset + 1, contentLength);
            const { value } = node;
            result = createTextNode(value, utils_1.Range.create(start, utils_1.Position.create(start.line, start.character + value.length)));
            break;
        }
        case 'number': {
            const start = (0, utils_1.positionAt)(lineOffsets, node.offset, contentLength);
            const value = node.value.toString();
            result = createTextNode(value, utils_1.Range.create(start, utils_1.Position.create(start.line, start.character + value.length)));
            break;
        }
        case 'boolean': {
            const start = (0, utils_1.positionAt)(lineOffsets, node.offset, contentLength);
            // CDS currently uses the boolean value if its true, otherwise falls back to using the key
            const value = node.value ? 'true' : '';
            result = createTextNode(value, utils_1.Range.create(start, utils_1.Position.create(start.line, start.character + value.length)));
            break;
        }
        default: {
            const start = (0, utils_1.positionAt)(lineOffsets, node.offset, contentLength);
            result = createTextNode('', utils_1.Range.create(start, start));
        }
    }
    return result;
}
/**
 * Process text nodes.
 *
 * @param textNodes text nodes
 * @param lineOffsets line offsets
 * @param contentLength content length
 * @param filePath file path
 * @returns i18n entires
 */
function processTextNodes(textNodes, lineOffsets, contentLength, filePath) {
    var _a, _b;
    const entries = [];
    for (const textNode of textNodes) {
        if (textNode.type === 'property') {
            const key = toTextNode(((_a = textNode.children) !== null && _a !== void 0 ? _a : [])[0], lineOffsets, contentLength);
            const value = toTextNode(((_b = textNode.children) !== null && _b !== void 0 ? _b : [])[1], lineOffsets, contentLength);
            if (key && value) {
                entries.push({
                    filePath,
                    key,
                    value
                });
            }
        }
    }
    return entries;
}
/**
 * Convert json text to i18n bundles.
 *
 * @param text json text
 * @param filePath file path of json text
 * @returns i18n bundles
 */
function jsonToI18nBundle(text, filePath = '') {
    var _a, _b, _c, _d, _e, _f, _g;
    const bundle = {};
    const rootNode = (0, jsonc_parser_1.parseTree)(text);
    const lineOffsets = (0, utils_1.getLineOffsets)(text);
    const contentLength = text.length;
    if ((rootNode === null || rootNode === void 0 ? void 0 : rootNode.type) !== 'object') {
        return bundle;
    }
    const localeNodes = (_a = rootNode.children) !== null && _a !== void 0 ? _a : [];
    for (const localeNode of localeNodes) {
        if (localeNode.type === 'property') {
            const locale = (_d = (_c = ((_b = localeNode.children) !== null && _b !== void 0 ? _b : [])[0]) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : '';
            const textNodes = (_g = (_f = ((_e = localeNode.children) !== null && _e !== void 0 ? _e : [])[1]) === null || _f === void 0 ? void 0 : _f.children) !== null && _g !== void 0 ? _g : [];
            bundle[locale] = processTextNodes(textNodes, lineOffsets, contentLength, filePath);
        }
    }
    return bundle;
}
exports.jsonToI18nBundle = jsonToI18nBundle;
//# sourceMappingURL=json.js.map