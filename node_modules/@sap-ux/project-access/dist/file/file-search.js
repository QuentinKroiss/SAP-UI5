"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilePaths = exports.findFileUp = exports.findFilesByExtension = exports.findFiles = exports.findBy = void 0;
const path_1 = require("path");
const findit2_1 = __importDefault(require("findit2"));
const file_access_1 = require("./file-access");
const fs_1 = require("fs");
/**
 * Get deleted and modified files from mem-fs editor filtered by query and 'by' (name|extension).
 *
 * @param changes - memfs editor changes, usually retrieved by fs.dump()
 * @param fileNames - array of file names to search for
 * @param extensionNames - array of extensions names to search for
 * @returns - array of deleted and modified files filtered by query
 */
function getMemFsChanges(changes, fileNames, extensionNames) {
    const deleted = [];
    const modified = [];
    const filteredChanges = Object.keys(changes).filter((f) => fileNames.includes((0, path_1.basename)(f)) || extensionNames.includes((0, path_1.extname)(f)));
    for (const file of filteredChanges) {
        if (changes[file].state === 'deleted') {
            deleted.push((0, path_1.join)(file));
        }
        if (changes[file].state === 'modified') {
            modified.push((0, path_1.join)(file));
        }
    }
    return { deleted, modified };
}
/**
 * Find function to search for files by names or file extensions.
 *
 * @param options - find options
 * @param [options.fileNames] - optional array of file names to search for
 * @param [options.extensionNames] - optional array of file extensions to search for
 * @param options.root - folder to start recursive search
 * @param [options.excludeFolders] - optional array of folder names to exclude
 * @param [options.memFs] - optional memfs editor instance
 * @returns - array of paths that contain the file
 */
function findBy(options) {
    return new Promise((resolve, reject) => {
        const results = [];
        const fileNames = Array.isArray(options.fileNames) ? options.fileNames : [];
        const extensionNames = Array.isArray(options.extensionNames) ? options.extensionNames : [];
        const excludeFolders = Array.isArray(options.excludeFolders) ? options.excludeFolders : [];
        const finder = (0, findit2_1.default)(options.root);
        finder.on('directory', (dir, _stat, stop) => {
            const base = (0, path_1.basename)(dir);
            if (excludeFolders.includes(base)) {
                stop();
            }
        });
        finder.on('file', (file) => {
            if (extensionNames.includes((0, path_1.extname)(file)) || fileNames.includes((0, path_1.basename)(file))) {
                results.push(file);
            }
        });
        finder.on('end', () => {
            let searchResult = results;
            if (options.memFs) {
                const { modified, deleted } = getMemFsChanges(options.memFs.dump(''), fileNames, extensionNames);
                const merged = Array.from(new Set([...results, ...modified]));
                searchResult = merged.filter((f) => !deleted.includes(f));
            }
            resolve(searchResult);
        });
        finder.on('error', (error) => {
            reject(error);
        });
    });
}
exports.findBy = findBy;
/**
 * Search for 'filename' starting from 'root'. Returns array of paths that contain the file.
 *
 * @param filename - filename to search
 * @param root - root folder to start search
 * @param excludeFolders - list of folder names to exclude (search doesn't traverse into these folders)
 * @param [memFs] - optional mem-fs-editor instance
 * @returns - array of paths that contain the filename
 */
function findFiles(filename, root, excludeFolders, memFs) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = yield findBy({ fileNames: [filename], root, excludeFolders, memFs });
        return results.map((f) => (0, path_1.dirname)(f));
    });
}
exports.findFiles = findFiles;
/**
 * Search for 'filename' starting from 'root'. Returns array of paths that contain the file.
 *
 * @param extension - file extension to search for including '.', e.g. '.ts'
 * @param root - root folder to start search
 * @param excludeFolders - list of folder names to exclude (search doesn't traverse into these folders)
 * @param [memFs] - optional mem-fs-editor instance
 * @returns - array of file paths that have the extension
 */
function findFilesByExtension(extension, root, excludeFolders, memFs) {
    return findBy({ extensionNames: [extension], root, excludeFolders, memFs });
}
exports.findFilesByExtension = findFilesByExtension;
/**
 * Find a file by name in parent folders starting from 'startPath'.
 *
 * @param fileName - file name to look for
 * @param startPath - path for start searching up
 * @param fs - optional mem-fs-editor instance
 * @returns - path to file name if found, otherwise undefined
 */
function findFileUp(fileName, startPath, fs) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = (0, path_1.join)(startPath, fileName);
        if (yield (0, file_access_1.fileExists)(filePath, fs)) {
            return filePath;
        }
        else {
            return (0, path_1.dirname)(startPath) !== startPath ? findFileUp(fileName, (0, path_1.dirname)(startPath), fs) : undefined;
        }
    });
}
exports.findFileUp = findFileUp;
/**
 * @description Returns a flat list of all file paths under a directory tree,
 * recursing through all subdirectories.
 * @param {string} dir - the directory to walk
 * @returns {string[]} - array of file path strings
 * @throws if an error occurs reading a file path
 */
function getFilePaths(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        const entries = yield fs_1.promises.readdir(dir);
        const filePathsPromises = entries.map((entry) => __awaiter(this, void 0, void 0, function* () {
            const entryPath = (0, path_1.join)(dir, entry);
            const isDirectory = (yield fs_1.promises.stat(entryPath)).isDirectory();
            return isDirectory ? getFilePaths(entryPath) : entryPath;
        }));
        const filePaths = yield Promise.all(filePathsPromises);
        return [].concat(...filePaths);
    });
}
exports.getFilePaths = getFilePaths;
//# sourceMappingURL=file-search.js.map