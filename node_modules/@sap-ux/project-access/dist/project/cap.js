"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toReferenceUri = exports.toAbsoluteUri = exports.getCapEnvironment = exports.readCapServiceMetadataEdmx = exports.getCdsServices = exports.getCdsRoots = exports.getCdsFiles = exports.getCapModelAndServices = exports.getCapCustomPaths = exports.isCapProject = exports.getCapProjectType = exports.isCapJavaProject = exports.isCapNodeJsProject = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const constants_1 = require("../constants");
const file_1 = require("../file");
const module_loader_1 = require("./module-loader");
/**
 * Returns true if the project is a CAP Node.js project.
 *
 * @param packageJson - the parsed package.json object
 * @returns - true if the project is a CAP Node.js project
 */
function isCapNodeJsProject(packageJson) {
    var _a, _b;
    return !!((_a = packageJson.cds) !== null && _a !== void 0 ? _a : (_b = packageJson.dependencies) === null || _b === void 0 ? void 0 : _b['@sap/cds']);
}
exports.isCapNodeJsProject = isCapNodeJsProject;
/**
 * Returns true if the project is a CAP Java project.
 *
 * @param projectRoot - the root path of the project
 * @param [capCustomPaths] - optional, relative CAP paths like app, db, srv
 * @returns - true if the project is a CAP project
 */
function isCapJavaProject(projectRoot, capCustomPaths) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const srv = (_a = capCustomPaths === null || capCustomPaths === void 0 ? void 0 : capCustomPaths.srv) !== null && _a !== void 0 ? _a : (yield getCapCustomPaths(projectRoot)).srv;
        return (0, file_1.fileExists)((0, path_1.join)(projectRoot, srv, 'src', 'main', 'resources', constants_1.FileName.CapJavaApplicationYaml));
    });
}
exports.isCapJavaProject = isCapJavaProject;
/**
 * Returns the CAP project type, undefined if it is not a CAP project.
 *
 * @param projectRoot - root of the project, where the package.json resides.
 * @returns - CAPJava for Java based CAP projects; CAPNodejs for node.js based CAP projects; undefined if it is no CAP project
 */
function getCapProjectType(projectRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const capCustomPaths = yield getCapCustomPaths(projectRoot);
        if (!(yield (0, file_1.fileExists)((0, path_1.join)(projectRoot, capCustomPaths.srv)))) {
            return undefined;
        }
        if (yield isCapJavaProject(projectRoot, capCustomPaths)) {
            return 'CAPJava';
        }
        let packageJson;
        try {
            packageJson = yield (0, file_1.readJSON)((0, path_1.join)(projectRoot, constants_1.FileName.Package));
        }
        catch (_a) {
            // Ignore errors while reading the package.json file
        }
        if (packageJson && isCapNodeJsProject(packageJson)) {
            return 'CAPNodejs';
        }
        return undefined;
    });
}
exports.getCapProjectType = getCapProjectType;
/**
 * Returns true if the project is either a CAP Node.js or a CAP Java project.
 *
 * @param projectRoot - the root path of the project
 * @returns - true if the project is a CAP project
 */
function isCapProject(projectRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        return !!(yield getCapProjectType(projectRoot));
    });
}
exports.isCapProject = isCapProject;
/**
 * Get CAP CDS project custom paths for project root.
 *
 * @param capProjectPath - project root of cap project
 * @returns - paths to app, db, and srv for CAP project
 */
function getCapCustomPaths(capProjectPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = {
            app: 'app/',
            db: 'db/',
            srv: 'srv/'
        };
        try {
            const cdsCustomPaths = yield getCapEnvironment(capProjectPath);
            if (cdsCustomPaths.folders) {
                result.app = cdsCustomPaths.folders.app;
                result.db = cdsCustomPaths.folders.db;
                result.srv = cdsCustomPaths.folders.srv;
            }
        }
        catch (error) {
            // In case of issues, fall back to the defaults
        }
        return result;
    });
}
exports.getCapCustomPaths = getCapCustomPaths;
/**
 * Return the CAP model and all services. The cds.root will be set to the provided project root path.
 *
 * @param projectRoot - CAP project root where package.json resides or object specifying project root and optional logger to log additonal info
 * @returns {*}  {Promise<{ model: csn; services: ServiceInfo[] }>} - CAP Model and Services
 */
function getCapModelAndServices(projectRoot) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let _projectRoot;
        let _logger;
        if (typeof projectRoot === 'object') {
            _projectRoot = projectRoot.projectRoot;
            _logger = projectRoot.logger;
        }
        else {
            _projectRoot = projectRoot;
        }
        const cds = yield loadCdsModuleFromProject(_projectRoot);
        const capProjectPaths = yield getCapCustomPaths(_projectRoot);
        const modelPaths = [
            (0, path_1.join)(_projectRoot, capProjectPaths.app),
            (0, path_1.join)(_projectRoot, capProjectPaths.srv),
            (0, path_1.join)(_projectRoot, capProjectPaths.db)
        ];
        const model = yield cds.load(modelPaths, { root: _projectRoot });
        _logger === null || _logger === void 0 ? void 0 : _logger.info(`@sap-ux/project-access:getCapModelAndServices - Using 'cds.home': ${cds.home}`);
        _logger === null || _logger === void 0 ? void 0 : _logger.info(`@sap-ux/project-access:getCapModelAndServices - Using 'cds.version': ${cds.version}`);
        _logger === null || _logger === void 0 ? void 0 : _logger.info(`@sap-ux/project-access:getCapModelAndServices - Using 'cds.root': ${cds.root}`);
        let services = (_a = cds.compile.to.serviceinfo(model, { root: _projectRoot })) !== null && _a !== void 0 ? _a : [];
        if (services.map) {
            services = services.map((value) => {
                return {
                    name: value.name,
                    urlPath: uniformUrl(value.urlPath),
                    runtime: value.runtime
                };
            });
        }
        return {
            model,
            services
        };
    });
}
exports.getCapModelAndServices = getCapModelAndServices;
/**
 * Returns a list of cds file paths (layers). By default return list of all, but you can also restrict it to one envRoot.
 *
 * @param projectRoot - root of the project, where the package.json is
 * @param [ignoreErrors] - optionally, default is false; if set to true the thrown error will be checked for CDS file paths in model and returned
 * @param [envRoot] - optionally, the root folder or CDS file to get the layer files
 * @returns - array of strings containing cds file paths
 */
function getCdsFiles(projectRoot, ignoreErrors = false, envRoot) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        let cdsFiles = [];
        try {
            let csn;
            envRoot !== null && envRoot !== void 0 ? envRoot : (envRoot = yield getCdsRoots(projectRoot));
            try {
                const cds = yield loadCdsModuleFromProject(projectRoot);
                csn = yield cds.load(envRoot, { root: projectRoot });
                cdsFiles = [...((_a = csn['$sources']) !== null && _a !== void 0 ? _a : [])];
            }
            catch (e) {
                if (ignoreErrors && ((_b = e.model) === null || _b === void 0 ? void 0 : _b.sources) && typeof e.model.sources === 'object') {
                    cdsFiles.push(...extractCdsFilesFromMessage(e.model.sources));
                }
                else {
                    throw e;
                }
            }
        }
        catch (error) {
            throw Error(`Error while retrieving the list of cds files for project ${projectRoot}, envRoot ${envRoot}. Error was: ${error}`);
        }
        return cdsFiles;
    });
}
exports.getCdsFiles = getCdsFiles;
/**
 * Returns a list of filepaths to CDS files in root folders. Same what is done if you execute cds.resolve('*') on command line in a project.
 *
 * @param projectRoot - root of the project, where the package.json is
 * @param [clearCache] - optionally, clear the cache, default false
 * @returns - array of root paths
 */
function getCdsRoots(projectRoot, clearCache = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const roots = [];
        const capCustomPaths = yield getCapCustomPaths(projectRoot);
        const cdsEnvRoots = [capCustomPaths.db, capCustomPaths.srv, capCustomPaths.app, 'schema', 'services'];
        // clear cache is enforced to also resolve newly created cds file at design time
        const cds = yield loadCdsModuleFromProject(projectRoot);
        if (clearCache) {
            cds.resolve.cache = {};
        }
        for (const cdsEnvRoot of cdsEnvRoots) {
            const resolvedRoots = cds.resolve((0, path_1.join)(projectRoot, cdsEnvRoot), {
                skipModelCache: true
            }) || [];
            for (const resolvedRoot of resolvedRoots) {
                roots.push(resolvedRoot);
            }
        }
        return roots;
    });
}
exports.getCdsRoots = getCdsRoots;
/**
 * Return a list of services in a CAP project.
 *
 * @param projectRoot - root of the CAP project, where the package.json is
 * @param ignoreErrors - in case loading the cds model throws an error, try to use the model from the exception object
 * @returns - array of service definitions
 */
function getCdsServices(projectRoot, ignoreErrors = true) {
    return __awaiter(this, void 0, void 0, function* () {
        let cdsServices = [];
        try {
            const cds = yield loadCdsModuleFromProject(projectRoot);
            const roots = yield getCdsRoots(projectRoot);
            let model;
            try {
                model = yield cds.load(roots, { root: projectRoot });
            }
            catch (e) {
                if (ignoreErrors && e.model) {
                    model = e.model;
                }
                else {
                    throw e;
                }
            }
            const linked = cds.linked(model);
            if (Array.isArray(linked.services)) {
                cdsServices = linked.services;
            }
            else {
                Object.keys(linked.services).forEach((service) => {
                    cdsServices.push(linked.services[service]);
                });
            }
        }
        catch (error) {
            throw Error(`Error while resolving cds roots for '${projectRoot}'. ${error}`);
        }
        return cdsServices;
    });
}
exports.getCdsServices = getCdsServices;
/**
 * When an error occurs while trying to read cds files, the error object contains the source file
 * information. This function extracts this file paths.
 *
 * @param sources - map containing the file name
 * @returns - array of strings containing cds file paths
 */
function extractCdsFilesFromMessage(sources) {
    const cdsFiles = [];
    for (const source in sources) {
        let filename = sources[source].filename;
        if (typeof filename === 'string' && !filename.startsWith(path_1.sep)) {
            filename = (0, path_1.join)(path_1.sep, filename);
        }
        if (filename) {
            cdsFiles.push(filename);
        }
    }
    return cdsFiles;
}
/**
 * Remove rogue '\\' - cds windows if needed.
 * Replaces all backslashes with forward slashes, removes double slashes, and trailing slashes.
 *
 * @param url - url to uniform
 * @returns - uniform url
 */
function uniformUrl(url) {
    return url
        .replace(/\\/g, '/')
        .replace(/\/\//g, '/')
        .replace(/(?:^\/)/g, '');
}
/**
 * Return the EDMX string of a CAP service.
 *
 * @param root - CAP project root where package.json resides
 * @param uri - service path, e.g 'incident/'
 * @param version - optional OData version v2 or v4
 * @returns - string containing the edmx
 */
function readCapServiceMetadataEdmx(root, uri, version = 'v4') {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { model, services } = yield getCapModelAndServices(root);
            const service = findServiceByUri(services, uri);
            if (!service) {
                throw Error(`Service for uri: '${uri}' not found. Available services: ${JSON.stringify(services)}`);
            }
            const cds = yield loadCdsModuleFromProject(root);
            const edmx = cds.compile.to.edmx(model, { service: service.name, version });
            return edmx;
        }
        catch (error) {
            throw Error(`Error while reading CAP service metadata. Path: '${root}', service uri: '${uri}', error: '${error.toString()}'}`);
        }
    });
}
exports.readCapServiceMetadataEdmx = readCapServiceMetadataEdmx;
/**
 * Find a service in a list of services ignoring leading and trailing slashes.
 *
 * @param services - list of services from cds.compile.to['serviceinfo'](model)
 * @param uri - search uri (usually from data source in manifest.json)
 * @returns - name and uri of the service, undefined if service not found
 */
function findServiceByUri(services, uri) {
    const searchUri = uniformUrl(uri).replace(/(?:^\/)|(?:\/$)/g, '');
    return services.find((srv) => srv.urlPath.replace(/(?:^\/)|(?:\/$)/g, '') === searchUri);
}
/**
 * Get CAP CDS project environment config for project root.
 *
 * @param capProjectPath - project root of a CAP project
 * @returns - environment config for a CAP project
 */
function getCapEnvironment(capProjectPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const cds = yield loadCdsModuleFromProject(capProjectPath);
        return cds.env.for('cds', capProjectPath);
    });
}
exports.getCapEnvironment = getCapEnvironment;
/**
 * Load CAP CDS module. First attempt loads @sap/cds for a project based on its root.
 * Second attempt loads @sap/cds from global installed @sap/cds-dk.
 * Throws error if module could not be loaded.
 *
 * @param capProjectPath - project root of a CAP project
 * @returns - CAP CDS module for a CAP project
 */
function loadCdsModuleFromProject(capProjectPath) {
    return __awaiter(this, void 0, void 0, function* () {
        let module;
        let loadProjectError;
        let loadError;
        try {
            // First approach, load @sap/cds from project
            module = yield (0, module_loader_1.loadModuleFromProject)(capProjectPath, '@sap/cds');
        }
        catch (error) {
            loadProjectError = error;
        }
        if (!module) {
            try {
                // Second approach, load @sap/cds from @sap/cds-dk
                module = yield loadGlobalCdsModule();
            }
            catch (error) {
                loadError = error;
            }
        }
        if (!module) {
            throw Error(`Could not load cds module. Attempt to load module @sap/cds from project threw error '${loadProjectError}', attempt to load module @sap/cds from @sap/cds-dk threw error '${loadError}'`);
        }
        const cds = 'default' in module ? module.default : module;
        // Fix when switching cds versions dynamically
        if (global) {
            global.cds = cds;
        }
        return cds;
    });
}
/**
 * Get absolute path to a resource.
 *
 * @param projectRoot - project root of a CAP project
 * @param relativeUri - relative resource path.
 * @returns {string} - absolute path.
 */
const toAbsoluteUri = (projectRoot, relativeUri) => (0, path_1.join)(projectRoot, relativeUri);
exports.toAbsoluteUri = toAbsoluteUri;
/**
 * Converts to referenced uri to be used in using statements.
 *
 * @param projectRoot - project root of a CAP project
 * @param relativeUriFrom - relative uri of from directory
 * @param relativeUriTo - relative uri of to directory
 * @returns {Promise<string>} - reference uri
 */
const toReferenceUri = (projectRoot, relativeUriFrom, relativeUriTo) => __awaiter(void 0, void 0, void 0, function* () {
    let relativeUri = '';
    const indexNodeModules = relativeUriTo.lastIndexOf('node_modules');
    if (indexNodeModules >= 0) {
        // extract module name from fileUri - e.g. '@sap/cds/common' from '../../node_modules/@sap/cds/common.cds'
        const indexLastDot = relativeUriTo.lastIndexOf('.');
        if (indexLastDot > indexNodeModules + 13) {
            relativeUri = relativeUriTo.slice(indexNodeModules + 13, indexLastDot);
        }
        else {
            relativeUri = relativeUriTo.slice(indexNodeModules + 13);
        }
    }
    else if (relativeUriTo.startsWith('../') || relativeUriTo.startsWith('..\\')) {
        // file outside current project (e.g. mono repo)
        const result = yield getPackageNameInFolder(projectRoot, relativeUriTo);
        if (result.packageName) {
            relativeUri = result.packageName + relativeUriTo.slice(result.packageFolder.length);
        }
    }
    if (!relativeUri) {
        // build relative path
        const fromDir = (0, path_1.dirname)((0, exports.toAbsoluteUri)(projectRoot, relativeUriFrom));
        relativeUri = (0, path_1.relative)(fromDir, (0, exports.toAbsoluteUri)(projectRoot, relativeUriTo));
        if (!relativeUri.startsWith('.')) {
            relativeUri = './' + relativeUri;
        }
    }
    // remove file extension
    const fileExtension = relativeUri.lastIndexOf('.') > 0 ? relativeUri.slice(relativeUri.lastIndexOf('.') + 1) : '';
    if (['CDS', 'JSON'].includes(fileExtension.toUpperCase())) {
        relativeUri = relativeUri.slice(0, relativeUri.length - fileExtension.length - 1);
    }
    // always use '/' instead of platform specific separator
    return relativeUri.split(path_1.sep).join('/');
});
exports.toReferenceUri = toReferenceUri;
/**
 * Gets package name from the folder.
 *
 * @param baseUri - base uri of the cap project
 * @param relativeUri - relative uri to the resource folder
 * @returns {Promise<{ packageName: string; packageFolder: string }>} - package name and folder
 */
function getPackageNameInFolder(baseUri, relativeUri) {
    return __awaiter(this, void 0, void 0, function* () {
        const refUriParts = relativeUri.split(path_1.sep);
        const result = { packageName: '', packageFolder: relativeUri };
        for (let i = refUriParts.length - 1; i >= 0 && !result.packageName; i--) {
            const currentFolder = refUriParts.slice(0, i).join(path_1.sep);
            result.packageName = yield readPackageNameForFolder(baseUri, currentFolder);
            if (result.packageName) {
                result.packageFolder = currentFolder;
            }
        }
        return result;
    });
}
/**
 * Reads package name from package json of the folder.
 *
 * @param baseUri - base uri of the cap project
 * @param relativeUri - relative uri to the resource folder
 * @returns {Promise<string>} - package name
 */
function readPackageNameForFolder(baseUri, relativeUri) {
    return __awaiter(this, void 0, void 0, function* () {
        let packageName = '';
        try {
            const path = (0, path_1.normalize)(baseUri + '/' + relativeUri + '/' + 'package.json');
            const content = yield (0, file_1.readFile)(path);
            if (content) {
                const parsed = JSON.parse(content);
                packageName = parsed.name;
            }
        }
        catch (e) {
            packageName = '';
        }
        return packageName;
    });
}
let globalCdsPathCache;
/**
 * Try to load global installation of @sap/cds, usually child of @sap/cds-dk.
 *
 * @returns - module @sap/cds from global installed @sap/cds-dk
 */
function loadGlobalCdsModule() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!globalCdsPathCache) {
            const versions = yield getCdsVersionInfo();
            if (!versions.home) {
                throw Error('Can not find global installation of module @sap/cds, which should be part of @sap/cds-dk');
            }
            globalCdsPathCache = versions.home;
        }
        return (0, module_loader_1.loadModuleFromProject)(globalCdsPathCache, '@sap/cds');
    });
}
/**
 * Get cds information, which includes versions and also the home path of cds module.
 *
 * @param [cwd] - optional folder in which cds --version should be executed
 * @returns - result of call 'cds --version'
 */
function getCdsVersionInfo(cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let out = '';
            const cdsVersionInfo = (0, child_process_1.spawn)('cds', ['--version'], { cwd, shell: true });
            cdsVersionInfo.stdout.on('data', (data) => {
                out += data.toString();
            });
            cdsVersionInfo.on('close', () => {
                if (out) {
                    const versions = {};
                    for (const line of out.split('\n').filter((v) => v)) {
                        const [key, value] = line.split(': ');
                        versions[key] = value;
                    }
                    resolve(versions);
                }
                else {
                    reject(new Error('Module path not found'));
                }
            });
            cdsVersionInfo.on('error', (error) => {
                reject(error);
            });
        });
    });
}
//# sourceMappingURL=cap.js.map