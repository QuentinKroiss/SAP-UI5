"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCapProjects = exports.findFioriArtifacts = exports.findAllApps = exports.getAppRootFromWebappPath = exports.findProjectRoot = void 0;
const path_1 = require("path");
const constants_1 = require("../constants");
const file_1 = require("../file");
const dependencies_1 = require("./dependencies");
const cap_1 = require("./cap");
const ui5_config_1 = require("./ui5-config");
/**
 * Map artifact to file that is specific to the artifact type. Some artifacts can
 * be identified by the same file, like app and library have file 'manifest.json'.
 * Further filtering for specific artifact types happens in the filter{Artifact}
 * functions.
 */
const filterFileMap = {
    applications: [constants_1.FileName.Manifest],
    adaptations: [constants_1.FileName.ManifestAppDescrVar],
    extensions: [constants_1.FileName.ExtConfigJson],
    libraries: [constants_1.FileName.Library, constants_1.FileName.Manifest]
};
/**
 * Default folders to exclude from search.
 */
const excludeFolders = ['.git', 'node_modules', 'dist'];
/**
 * WorkspaceFolder type guard.
 *
 * @param value - value to type check
 * @returns - true: is a vscode workspace array; no: not a vscode workspace array
 */
function isWorkspaceFolder(value) {
    return value && value.length > 0 && value[0].uri !== undefined;
}
/**
 * Convert workspace root folders to root paths.
 *
 * @param wsFolders - list of roots, either as vscode WorkspaceFolder[] or array of paths
 * @returns - root paths
 */
function wsFoldersToRootPaths(wsFolders) {
    // extract root path if provided as VSCode folder
    let wsRoots;
    if (wsFolders && isWorkspaceFolder(wsFolders)) {
        wsRoots = [];
        wsFolders
            .filter((each) => each.uri.scheme === 'file')
            .forEach((folder) => {
            wsRoots.push(folder.uri.fsPath);
        });
    }
    else {
        wsRoots = (wsFolders !== null && wsFolders !== void 0 ? wsFolders : []);
    }
    return wsRoots;
}
/**
 * Find root folder of the project containing the given file.
 *
 * @param path path of a project file
 * @param sapuxRequired if true, only find sapux projects
 * @param silent if true, then does not throw an error but returns an empty path
 * @returns {*}  {Promise<string>} - Project Root
 */
function findProjectRoot(path, sapuxRequired = true, silent = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield (0, file_1.findFileUp)(constants_1.FileName.Package, path);
        if (!packageJson) {
            if (silent) {
                return '';
            }
            throw new Error(`Could not find any project root for '${path}'. Search was done for ${sapuxRequired ? 'Fiori elements' : 'All'} projects.`);
        }
        let root = (0, path_1.dirname)(packageJson);
        if (sapuxRequired) {
            const sapux = (yield (0, file_1.readJSON)(packageJson)).sapux;
            if (!sapux) {
                root = yield findProjectRoot((0, path_1.dirname)(root), sapuxRequired, silent);
            }
        }
        return root;
    });
}
exports.findProjectRoot = findProjectRoot;
/**
 * Find app root and project root from given paths and sapux entry.
 *
 * @param sapux - value of sapux in package.json, either boolean or string array
 * @param path - path where the search started from
 * @param root - root of the app or project, where package.json is located
 * @returns - appRoot and projectRoot or null
 */
function findRootsWithSapux(sapux, path, root) {
    if (typeof sapux === 'boolean' && sapux === true) {
        return {
            appRoot: root,
            projectRoot: root
        };
    }
    else if (Array.isArray(sapux)) {
        // Backward compatibility for FE apps in CAP projects that have no app package.json,
        // but are listed in CAP root sapux array
        const pathWithSep = path.endsWith(path_1.sep) ? path : path + path_1.sep;
        const relAppPaths = sapux.map((a) => (0, path_1.join)(...a.split(/[\\/]/)));
        const relApp = relAppPaths.find((app) => pathWithSep.startsWith((0, path_1.join)(root, app) + path_1.sep));
        if (relApp) {
            return {
                appRoot: (0, path_1.join)(root, relApp),
                projectRoot: root
            };
        }
    }
    // The first package.json we found when searching up contains sapux, but not true -> not supported
    return null;
}
/**
 * Get the application root for a given webapp path.
 *
 * @param webappPath - path to webapp folder, where manifest.json is
 * @returns - root path of the application, where usually ui5.yaml and package.json are
 */
function getAppRootFromWebappPath(webappPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const ui5YamlPath = yield (0, file_1.findFileUp)(constants_1.FileName.Ui5Yaml, webappPath);
        let appRoot = (0, path_1.dirname)(webappPath);
        if (ui5YamlPath) {
            const candidate = (0, path_1.dirname)(ui5YamlPath);
            const webapp = yield (0, ui5_config_1.getWebappPath)(candidate);
            if (webapp === webappPath) {
                appRoot = candidate;
            }
        }
        return appRoot;
    });
}
exports.getAppRootFromWebappPath = getAppRootFromWebappPath;
/**
 * Find the app root and project root folder for a given path. In case of apps in non CAP projects they are the same.
 * This function also validates if an app is supported by tools considering Fiori elements apps and SAPUI5
 * freestyle apps. Only if project root and app root can be determined, they are returned, otherwise null is returned.
 * This function is used e.g. to get a filtered list of all manifest.json files in a workspace for tools
 * supported apps and retrieve the respective root paths.
 *
 * This function makes following assumptions:
 * - All applications have a package.json in root folder.
 * - If sapux=true in package.json the app is NOT inside a CAP project.
 * - Freestyle application (non CAP) has in package.json dependency to @sap/ux-ui5-tooling and <appRoot>/ui5-local.yaml.
 *
 * @param path - path to check, e.g. to the manifest.json
 * @returns - in case a supported app is found this function returns the appRoot and projectRoot path
 */
function findRootsForPath(path) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // Get the root of the app, that is where the package.json is, otherwise not supported
            const appRoot = yield findProjectRoot(path, false);
            if (!appRoot) {
                return null;
            }
            const appPckJson = yield (0, file_1.readJSON)((0, path_1.join)(appRoot, constants_1.FileName.Package));
            // Check for most common app, Fiori elements with sapux=true in package.json
            if (appPckJson.sapux) {
                return findRootsWithSapux(appPckJson.sapux, path, appRoot);
            }
            if ((yield (0, cap_1.getCapProjectType)(appRoot)) !== undefined) {
                // App is part of a CAP project, but doesn't have own package.json and is not mentioned in sapux array
                // in root -> not supported
                return null;
            }
            // Check if app is included in CAP project
            const projectRoot = yield findCapProjectRoot(appRoot);
            if (projectRoot) {
                // App included in CAP
                return {
                    appRoot,
                    projectRoot
                };
            }
            else if (
            // Check for freestyle non CAP
            (yield (0, file_1.fileExists)((0, path_1.join)(appRoot, constants_1.FileName.Ui5LocalYaml))) &&
                (0, dependencies_1.hasDependency)(appPckJson, '@sap/ux-ui5-tooling')) {
                return {
                    appRoot,
                    projectRoot: appRoot
                };
            }
        }
        catch (_a) {
            // Finding root should not throw error. Return null instead.
        }
        return null;
    });
}
/**
 * Find CAP project root path.
 *
 * @param path - path inside CAP project
 * @returns - CAP project root path
 */
function findCapProjectRoot(path) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { root } = (0, path_1.parse)(path);
            let projectRoot = (0, path_1.dirname)(path);
            while (projectRoot !== root) {
                if (yield (0, cap_1.getCapProjectType)(projectRoot)) {
                    // We have found a CAP project as root. Check if the found app is not directly in CAP's 'app/' folder.
                    // Sometime there is a <CAP_ROOT>/app/package.json file that is used for app router (not an app)
                    if ((0, path_1.join)(projectRoot, 'app') !== path) {
                        return projectRoot;
                    }
                }
                projectRoot = (0, path_1.dirname)(projectRoot);
            }
        }
        catch (_a) {
            // No project root can be found at parent folder.
        }
        return null;
    });
}
/**
 * Find all app that are supported by Fiori tools for a given list of roots (workspace folders).
 * This is a convenient function to retrieve all apps. Same result can be achieved with call
 * findFioriArtifacts({ wsFolders, artifacts: ['applications'] }); from same module.
 *
 * @param wsFolders - list of roots, either as vscode WorkspaceFolder[] or array of paths
 * @returns - results as path to apps plus files already parsed, e.g. manifest.json
 */
function findAllApps(wsFolders) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const findResults = yield findFioriArtifacts({ wsFolders, artifacts: ['applications'] });
        return (_a = findResults.applications) !== null && _a !== void 0 ? _a : [];
    });
}
exports.findAllApps = findAllApps;
/**
 * Filter Fiori apps from a list of files.
 *
 * @param pathMap - map of files. Key is the path, on first read parsed content will be set as value to prevent multiple reads of a file.
 * @returns - results as path to apps plus files already parsed, e.g. manifest.json
 */
function filterApplications(pathMap) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const result = [];
        const manifestPaths = Object.keys(pathMap).filter((path) => (0, path_1.basename)(path) === constants_1.FileName.Manifest);
        for (const manifestPath of manifestPaths) {
            try {
                // All UI5 apps have at least sap.app: { id: <ID>, type: "application" } in manifest.json
                (_a = pathMap[manifestPath]) !== null && _a !== void 0 ? _a : (pathMap[manifestPath] = yield (0, file_1.readJSON)(manifestPath));
                const manifest = pathMap[manifestPath];
                if (!((_b = manifest['sap.app']) === null || _b === void 0 ? void 0 : _b.id) || manifest['sap.app'].type !== 'application') {
                    continue;
                }
                const roots = yield findRootsForPath(manifestPath);
                if (roots && !(yield (0, file_1.fileExists)((0, path_1.join)(roots.appRoot, '.adp', constants_1.FileName.AdaptationConfig)))) {
                    result.push({ appRoot: roots.appRoot, projectRoot: roots.projectRoot, manifest, manifestPath });
                }
            }
            catch (_c) {
                // ignore exceptions for invalid manifests
            }
        }
        return result;
    });
}
/**
 * Filter adaptation projects from a list of files.
 *
 * @param pathMap - map of files. Key is the path, on first read parsed content will be set as value to prevent multiple reads of a file.
 * @returns - results as array of found adaptation projects.
 */
function filterAdaptations(pathMap) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        const manifestAppDescrVars = Object.keys(pathMap).filter((path) => path.endsWith(constants_1.FileName.ManifestAppDescrVar));
        for (const manifestAppDescrVar of manifestAppDescrVars) {
            const packageJsonPath = yield (0, file_1.findFileUp)(constants_1.FileName.Package, (0, path_1.dirname)(manifestAppDescrVar));
            const projectRoot = packageJsonPath ? (0, path_1.dirname)(packageJsonPath) : null;
            if (projectRoot && (yield (0, file_1.fileExists)((0, path_1.join)(projectRoot, 'webapp', constants_1.FileName.ManifestAppDescrVar)))) {
                results.push({ appRoot: projectRoot, manifestAppdescrVariantPath: manifestAppDescrVar });
            }
        }
        return results;
    });
}
/**
 * Filter extensions projects from a list of files.
 *
 * @param pathMap - map of files. Key is the path, on first read parsed content will be set as value to prevent multiple reads of a file.
 * @returns - results as array of found extension projects.
 */
function filterExtensions(pathMap) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        const extensionConfigs = Object.keys(pathMap).filter((path) => (0, path_1.basename)(path) === constants_1.FileName.ExtConfigJson);
        for (const extensionConfig of extensionConfigs) {
            try {
                let manifest = null;
                let manifestPath = Object.keys(pathMap).find((path) => path.startsWith((0, path_1.dirname)(extensionConfig) + path_1.sep) && (0, path_1.basename)(path) === constants_1.FileName.Manifest);
                if (manifestPath) {
                    (_a = pathMap[manifestPath]) !== null && _a !== void 0 ? _a : (pathMap[manifestPath] = yield (0, file_1.readJSON)(manifestPath));
                    manifest = pathMap[manifestPath];
                }
                else {
                    const manifests = yield (0, file_1.findBy)({
                        fileNames: [constants_1.FileName.Manifest],
                        root: (0, path_1.dirname)(extensionConfig),
                        excludeFolders
                    });
                    if (manifests.length === 1) {
                        [manifestPath] = manifests;
                        manifest = yield (0, file_1.readJSON)(manifestPath);
                    }
                }
                if (manifestPath && manifest) {
                    results.push({ appRoot: (0, path_1.dirname)(extensionConfig), manifest, manifestPath });
                }
            }
            catch (_b) {
                // ignore exceptions for invalid manifests
            }
        }
        return results;
    });
}
/**
 * Find and filter libraries with only a `.library` and no `manifest.json`.
 *
 * @param pathMap - path to files
 * @param manifestPaths - paths to manifest.json files
 * @returns - results as array of found .library projects.
 */
function filterDotLibraries(pathMap, manifestPaths) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const dotLibraries = [];
        const dotLibraryPaths = Object.keys(pathMap)
            .filter((path) => (0, path_1.basename)(path) === constants_1.FileName.Library)
            .map((path) => (0, path_1.dirname)(path))
            .filter((path) => !manifestPaths.map((manifestPath) => (0, path_1.dirname)(manifestPath)).includes(path));
        if (dotLibraryPaths) {
            for (const libraryPath of dotLibraryPaths) {
                const projectRoot = (0, path_1.dirname)((_a = (yield (0, file_1.findFileUp)(constants_1.FileName.Package, (0, path_1.dirname)(libraryPath)))) !== null && _a !== void 0 ? _a : libraryPath);
                dotLibraries.push({ projectRoot, libraryPath });
            }
        }
        return dotLibraries;
    });
}
/**
 * Filter extensions projects from a list of files.
 *
 * @param pathMap - path to files
 * @returns - results as array of found library projects.
 */
function filterLibraries(pathMap) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        const manifestPaths = Object.keys(pathMap).filter((path) => (0, path_1.basename)(path) === constants_1.FileName.Manifest);
        results.push(...(yield filterDotLibraries(pathMap, manifestPaths)));
        for (const manifestPath of manifestPaths) {
            try {
                (_a = pathMap[manifestPath]) !== null && _a !== void 0 ? _a : (pathMap[manifestPath] = yield (0, file_1.readJSON)(manifestPath));
                const manifest = pathMap[manifestPath];
                if (manifest['sap.app'] && manifest['sap.app'].type === 'library') {
                    const packageJsonPath = yield (0, file_1.findFileUp)(constants_1.FileName.Package, (0, path_1.dirname)(manifestPath));
                    const projectRoot = packageJsonPath ? (0, path_1.dirname)(packageJsonPath) : null;
                    if (projectRoot && (yield (0, file_1.fileExists)((0, path_1.join)(projectRoot, constants_1.FileName.Ui5Yaml)))) {
                        results.push({ projectRoot, manifestPath, manifest });
                    }
                }
            }
            catch (_b) {
                // ignore exceptions for invalid manifests
            }
        }
        return results;
    });
}
/**
 * Get the files to search for according to requested artifact type.
 *
 * @param artifacts - requests artifacts like apps, adaptations, extensions
 * @returns - array of filenames to search for
 */
function getFilterFileNames(artifacts) {
    const uniqueFilterFiles = new Set();
    for (const artifact of artifacts) {
        if (filterFileMap[artifact]) {
            filterFileMap[artifact].forEach((artifactFile) => uniqueFilterFiles.add(artifactFile));
        }
    }
    return Array.from(uniqueFilterFiles);
}
/**
 * Find all requested Fiori artifacts like apps, adaptations, extensions, that are supported by Fiori tools, for a given list of roots (workspace folders).
 *
 * @param options - find options
 * @param options.wsFolders - list of roots, either as vscode WorkspaceFolder[] or array of paths
 * @param options.artifacts - list of artifacts to search for: 'application', 'adaptation', 'extension' see FioriArtifactTypes
 * @returns - data structure containing the search results, for app e.g. as path to app plus files already parsed, e.g. manifest.json
 */
function findFioriArtifacts(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = {};
        const fileNames = getFilterFileNames(options.artifacts);
        const wsRoots = wsFoldersToRootPaths(options.wsFolders);
        const pathMap = {};
        for (const root of wsRoots) {
            try {
                const foundFiles = yield (0, file_1.findBy)({
                    fileNames,
                    root,
                    excludeFolders
                });
                foundFiles.forEach((path) => (pathMap[path] = null));
            }
            catch (_a) {
                // ignore exceptions during find
            }
        }
        if (options.artifacts.includes('applications')) {
            results.applications = yield filterApplications(pathMap);
        }
        if (options.artifacts.includes('adaptations')) {
            results.adaptations = yield filterAdaptations(pathMap);
        }
        if (options.artifacts.includes('extensions')) {
            results.extensions = yield filterExtensions(pathMap);
        }
        if (options.artifacts.includes('libraries')) {
            results.libraries = yield filterLibraries(pathMap);
        }
        return results;
    });
}
exports.findFioriArtifacts = findFioriArtifacts;
/**
 * Find all CAP project roots by locating pom.xml or package.json in a given workspace.
 *
 * @param options - find options
 * @param options.wsFolders - list of roots, either as vscode WorkspaceFolder[] or array of paths
 * @returns - root file paths that may contain a CAP project
 */
function findCapProjects(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = new Set();
        const excludeFolders = ['node_modules', 'dist', 'webapp', 'MDKModule', 'gen'];
        const fileNames = [constants_1.FileName.Pom, constants_1.FileName.Package, constants_1.FileName.CapJavaApplicationYaml];
        const wsRoots = wsFoldersToRootPaths(options.wsFolders);
        for (const root of wsRoots) {
            const filesToCheck = yield (0, file_1.findBy)({
                fileNames,
                root,
                excludeFolders
            });
            const appYamlsToCheck = Array.from(new Set(filesToCheck
                .filter((file) => (0, path_1.basename)(file) === constants_1.FileName.CapJavaApplicationYaml)
                .map((file) => (0, path_1.dirname)(file))));
            const foldersToCheck = Array.from(new Set(filesToCheck
                .filter((file) => (0, path_1.basename)(file) !== constants_1.FileName.CapJavaApplicationYaml)
                .map((file) => (0, path_1.dirname)(file))));
            for (const appYamlToCheck of appYamlsToCheck) {
                const capRoot = yield findCapProjectRoot(appYamlToCheck);
                if (capRoot) {
                    result.add(capRoot);
                }
            }
            for (const folderToCheck of foldersToCheck) {
                if ((yield (0, cap_1.getCapProjectType)(folderToCheck)) !== undefined) {
                    result.add(folderToCheck);
                }
            }
        }
        return Array.from(result);
    });
}
exports.findCapProjects = findCapProjects;
//# sourceMappingURL=search.js.map