"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InboundWriter = void 0;
const change_utils_1 = require("../../../base/change-utils");
/**
 * Handles the creation and writing of inbound data changes for a project.
 */
class InboundWriter {
    /**
     * @param {Editor} fs - The filesystem editor instance.
     * @param {string} projectPath - The root path of the project.
     */
    constructor(fs, projectPath) {
        this.fs = fs;
        this.projectPath = projectPath;
    }
    /**
     * Constructs the content for an inbound data change based on provided data.
     *
     * @param {InboundData} data - The answers object containing information needed to construct the content property.
     * @returns {object} The constructed content object for the inbound data change.
     */
    constructContent(data) {
        const content = {
            inboundId: data.inboundId,
            entityPropertyChange: []
        };
        this.getEnhancedContent(data, content);
        return content;
    }
    /**
     * Enhances the provided content object based on the values provided in answers.
     *
     * @param {InboundData} data - An object containing potential values for title, subTitle, and icon.
     * @param {InboundContent} content - The initial content object to be enhanced.
     * @returns {void}
     */
    getEnhancedContent(data, content) {
        const { icon, title, subTitle } = data.flp;
        if (title) {
            content.entityPropertyChange.push({
                propertyPath: 'title',
                operation: 'UPSERT',
                propertyValue: title
            });
        }
        if (subTitle) {
            content.entityPropertyChange.push({
                propertyPath: 'subTitle',
                operation: 'UPSERT',
                propertyValue: subTitle
            });
        }
        if (icon) {
            content.entityPropertyChange.push({
                propertyPath: 'icon',
                operation: 'UPSERT',
                propertyValue: icon
            });
        }
    }
    /**
     * Processes the provided answers object to parse its properties into the correct format.
     *
     * @param {InboundData} data - An object containing raw answers for inboundId, title, subTitle, and icon.
     * @returns {InboundData} A new answers object with properties modified
     *                           to ensure they are in the correct format for use in content construction.
     */
    getModifiedData(data) {
        const { title, subTitle, icon } = data.flp;
        return Object.assign(Object.assign({}, data), { flp: {
                title: (0, change_utils_1.getParsedPropertyValue)(title),
                subTitle: (0, change_utils_1.getParsedPropertyValue)(subTitle),
                icon: (0, change_utils_1.getParsedPropertyValue)(icon)
            } });
    }
    /**
     * Writes the inbound data change to the project based on the provided data.
     *
     * @param {InboundData} data - The inbound data containing all the necessary information to construct and write the change.
     * @returns {Promise<void>} A promise that resolves when the change writing process is completed.
     */
    write(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const answers = this.getModifiedData(data);
            const { changeWithInboundId, filePath } = (0, change_utils_1.findChangeWithInboundId)(this.projectPath, answers.inboundId);
            if (!changeWithInboundId) {
                const content = this.constructContent(answers);
                const change = (0, change_utils_1.getGenericChange)(data, content, "appdescr_app_changeInbound" /* ChangeType.CHANGE_INBOUND */);
                (0, change_utils_1.writeChangeToFolder)(this.projectPath, change, `id_${data.timestamp}_changeInbound.change`, this.fs, "manifest" /* FolderTypes.MANIFEST */);
            }
            else {
                if (changeWithInboundId.content) {
                    this.getEnhancedContent(answers, changeWithInboundId.content);
                }
                (0, change_utils_1.writeChangeToFile)(filePath, changeWithInboundId, this.fs);
            }
        });
    }
}
exports.InboundWriter = InboundWriter;
//# sourceMappingURL=inbound-writer.js.map