"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGenericChange = exports.findChangeWithInboundId = exports.getParsedPropertyValue = exports.parseStringToObject = exports.writeChangeToFile = exports.writeChangeToFolder = exports.writeAnnotationChange = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
/**
 * Writes annotation changes to the specified project path using the provided `mem-fs-editor` instance.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {AnnotationsData} data - The data object containing information about the annotation change.
 * @param {ManifestChangeProperties} change - The annotation data change that will be written.
 * @param {Editor} fs - The `mem-fs-editor` instance used for file operations.
 * @returns {void}
 */
function writeAnnotationChange(projectPath, data, change, fs) {
    var _a;
    try {
        const { timestamp, annotation } = data;
        const changeFileName = `id_${timestamp}_addAnnotationsToOData.change`;
        const changesFolderPath = path_1.default.join(projectPath, "webapp" /* FolderTypes.WEBAPP */, "changes" /* FolderTypes.CHANGES */);
        const changeFilePath = path_1.default.join(changesFolderPath, "manifest" /* FolderTypes.MANIFEST */, changeFileName);
        const annotationsFolderPath = path_1.default.join(changesFolderPath, "annotations" /* FolderTypes.ANNOTATIONS */);
        writeChangeToFile(changeFilePath, change, fs);
        if (!annotation.filePath) {
            fs.write(path_1.default.join(annotationsFolderPath, (_a = annotation.fileName) !== null && _a !== void 0 ? _a : ''), '');
        }
        else {
            const { filePath, fileName } = annotation;
            const selectedDir = path_1.default.dirname(filePath);
            if (selectedDir !== annotationsFolderPath) {
                fs.copy(filePath, path_1.default.join(annotationsFolderPath, fileName !== null && fileName !== void 0 ? fileName : ''));
            }
        }
    }
    catch (e) {
        throw new Error(`Could not write annotation changes. Reason: ${e.message}`);
    }
}
exports.writeAnnotationChange = writeAnnotationChange;
/**
 * Writes a given change object to a file within a specified folder in the project's 'changes' directory.
 * If an additional subdirectory is specified, the change file is written there.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {ManifestChangeProperties} change - The change data to be written to the file.
 * @param {string} fileName - The name of the file to write the change data to.
 * @param {Editor} fs - The `mem-fs-editor` instance used for file operations.
 * @param {string} [dir] - An optional subdirectory within the 'changes' directory where the file will be written.
 * @returns {void}
 */
function writeChangeToFolder(projectPath, change, fileName, fs, dir = '') {
    try {
        let targetFolderPath = path_1.default.join(projectPath, "webapp" /* FolderTypes.WEBAPP */, "changes" /* FolderTypes.CHANGES */);
        if (dir) {
            targetFolderPath = path_1.default.join(targetFolderPath, dir);
        }
        const filePath = path_1.default.join(targetFolderPath, fileName);
        writeChangeToFile(filePath, change, fs);
    }
    catch (e) {
        throw new Error(`Could not write change to folder. Reason: ${e.message}`);
    }
}
exports.writeChangeToFolder = writeChangeToFolder;
/**
 * Writes a given change object to a specific file path. The change data is stringified to JSON format before
 * writing. This function is used to directly write changes to a file, without specifying a directory.
 *
 * @param {string} path - The root path of the project.
 * @param {ManifestChangeProperties} change - The change data to be written to the file.
 * @param {Editor} fs - The `mem-fs-editor` instance used for file operations.
 */
function writeChangeToFile(path, change, fs) {
    try {
        fs.writeJSON(path, change);
    }
    catch (e) {
        throw new Error(`Could not write change to file: ${path}. Reason: ${e.message}`);
    }
}
exports.writeChangeToFile = writeChangeToFile;
/**
 * Parses a string into an object.
 *
 * @param {string} str - The string to be parsed into an object. The string should be in the format of object properties without the surrounding braces.
 * @returns {{ [key: string]: string }} An object constructed from the input string.
 * @example
 * // returns { name: "value" }
 * parseStringToObject('"name":"value"');
 */
function parseStringToObject(str) {
    return JSON.parse(`{${str}}`);
}
exports.parseStringToObject = parseStringToObject;
/**
 * Attempts to parse a property value as JSON.
 *
 * @param {string} propertyValue - The property value to be parsed.
 * @returns {PropertyValueType} The parsed value if `propertyValue` is valid JSON; otherwise, returns the original `propertyValue`.
 * @example
 * // Returns the object { key: "value" }
 * getParsedPropertyValue('{"key": "value"}');
 *
 * // Returns the string "nonJSONValue" because it cannot be parsed as JSON
 * getParsedPropertyValue('nonJSONValue');
 */
function getParsedPropertyValue(propertyValue) {
    try {
        const value = JSON.parse(propertyValue);
        return value;
    }
    catch (e) {
        return propertyValue;
    }
}
exports.getParsedPropertyValue = getParsedPropertyValue;
/**
 * Searches for a change file with a specific inbound ID within a project's change directory.
 *
 * @param {string} projectPath - The root path of the project.
 * @param {string} inboundId - The inbound ID to search for within change files.
 * @returns {InboundChangeData} An object containing the file path and the change object with the matching inbound ID.
 * @throws {Error} Throws an error if the change file cannot be read or if there's an issue accessing the directory.
 */
function findChangeWithInboundId(projectPath, inboundId) {
    var _a;
    let changeObj;
    let filePath = '';
    const pathToInboundChangeFiles = path_1.default.join(projectPath, "webapp" /* FolderTypes.WEBAPP */, "changes" /* FolderTypes.CHANGES */, "manifest" /* FolderTypes.MANIFEST */);
    if (!(0, fs_1.existsSync)(pathToInboundChangeFiles)) {
        return {
            filePath,
            changeWithInboundId: changeObj
        };
    }
    try {
        const files = (0, fs_1.readdirSync)(pathToInboundChangeFiles, { withFileTypes: true }).filter((dirent) => dirent.isFile() && dirent.name.includes('changeInbound'));
        for (const file of files) {
            const pathToFile = path_1.default.join(pathToInboundChangeFiles, file.name);
            const change = JSON.parse((0, fs_1.readFileSync)(pathToFile, 'utf-8'));
            if (((_a = change.content) === null || _a === void 0 ? void 0 : _a.inboundId) === inboundId) {
                changeObj = change;
                filePath = pathToFile;
                break;
            }
        }
        return {
            filePath,
            changeWithInboundId: changeObj
        };
    }
    catch (e) {
        throw new Error(`Could not find change with inbound id '${inboundId}'. Reason: ${e.message}`);
    }
}
exports.findChangeWithInboundId = findChangeWithInboundId;
/**
 * Constructs a generic change object based on provided parameters.
 *
 * @param data - The base data associated with the change, including project data and timestamp.
 * @param data.projectData - The project specific data.
 * @param data.timestamp - The timestamp.
 * @param {object} content - The content of the change to be applied.
 * @param {ChangeType} changeType - The type of the change.
 * @returns An object representing the change.
 */
function getGenericChange(data, content, changeType) {
    const { projectData, timestamp } = data;
    const fileName = `id_${timestamp}`;
    return {
        fileName,
        namespace: path_1.default.posix.join(projectData.namespace, "changes" /* FolderTypes.CHANGES */),
        layer: projectData.layer,
        fileType: 'change',
        creation: new Date(timestamp).toISOString(),
        packageName: '$TMP',
        reference: projectData.id,
        support: { generator: '@sap-ux/adp-tooling' },
        changeType,
        content
    };
}
exports.getGenericChange = getGenericChange;
//# sourceMappingURL=change-utils.js.map