import * as Core from "./Core";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import ComplexType = Edm.RecordComplexType;
/**
  The pattern that a string property, parameter, or term must match. This SHOULD be a valid regular expression, according to the ECMA 262 regular expression dialect.
*/
export type Pattern = {
    term: ValidationAnnotationTerms.Pattern;
} & AnnotationTerm<Edm.String>;
/**
  Minimum value that a property, parameter, or term can have.
*/
export type Minimum = {
    term: ValidationAnnotationTerms.Minimum;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  Maximum value that a property, parameter, or term can have.
*/
export type Maximum = {
    term: ValidationAnnotationTerms.Maximum;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  Tags a Minimum or Maximum as exclusive, i.e. an open interval boundary.
*/
export type Exclusive = {
    term: ValidationAnnotationTerms.Exclusive;
} & AnnotationTerm<Core.Tag>;
/**
  A collection of valid values for the annotated property, parameter, or type definition
*/
export type AllowedValues = {
    term: ValidationAnnotationTerms.AllowedValues;
} & AnnotationTerm<AllowedValueTypes[]>;
export type AllowedValue = ComplexType & {
    $Type: ValidationAnnotationTypes.AllowedValue;
    /**
        An allowed value for the property, parameter, or type definition
    */
    Value?: Edm.PrimitiveType;
};
/**
  The value of the annotated property, parameter, or term must be an integer multiple of this positive value. For temporal types, the value is measured in seconds.
*/
export type MultipleOf = {
    term: ValidationAnnotationTerms.MultipleOf;
} & AnnotationTerm<Edm.Decimal>;
/**
  Condition that the annotation target has to fulfill
*/
export type Constraint = {
    term: ValidationAnnotationTerms.Constraint;
} & AnnotationTerm<ConstraintTypeTypes>;
export type ConstraintType = ComplexType & {
    $Type: ValidationAnnotationTypes.ConstraintType;
    /**
        Human-readable message that can be shown to end users if the constraint is not fulfilled
    */
    FailureMessage?: Edm.String;
    /**
        Value MUST be a dynamic expression that evaluates to true if and only if the constraint is fulfilled
    */
    Condition: Edm.Boolean;
};
/**
  A list of constraints describing that entities related via one navigation property MUST also be related via another, collection-valued navigation property. The same `path` value MUST NOT occur more than once.
*/
export type ItemsOf = {
    term: ValidationAnnotationTerms.ItemsOf;
} & AnnotationTerm<ItemsOfTypeTypes[]>;
/**
  Entities related via the single- or collection-valued navigation property identified by `path` are also related via the collection-valued navigation property identified by `target`.
*/
export type ItemsOfType = ComplexType & {
    $Type: ValidationAnnotationTypes.ItemsOfType;
    /**
        A path to a single- or collection-valued navigation property
    */
    path: Edm.NavigationPropertyPath;
    /**
        A path to a collection-valued navigation property
    */
    target: Edm.NavigationPropertyPath;
};
/**
  Dynamic properties added to the annotated open structured type are restricted to the listed types.
*/
export type OpenPropertyTypeConstraint = {
    term: ValidationAnnotationTerms.OpenPropertyTypeConstraint;
} & AnnotationTerm<SingleOrCollectionType[]>;
/**
  Values are restricted to types that are both identical to or derived from the declared type and a type listed in this collection.
*/
export type DerivedTypeConstraint = {
    term: ValidationAnnotationTerms.DerivedTypeConstraint;
} & AnnotationTerm<SingleOrCollectionType[]>;
/**
  The qualified name of a type in scope, optionally wrapped in `Collection()` to denote a collection of instances of the type
*/
export type SingleOrCollectionType = Edm.String;
/**
  Annotate a term of type Edm.AnnotationPath, or a property of type Edm.AnnotationPath that is used within a structured term, to restrict the terms that can be targeted by the path.
*/
export type AllowedTerms = {
    term: ValidationAnnotationTerms.AllowedTerms;
} & AnnotationTerm<Core.QualifiedTermName[]>;
/**
  Names of specific terms that are applicable and may be applied in the current context. This annotation does not restrict the use of other terms.
*/
export type ApplicableTerms = {
    term: ValidationAnnotationTerms.ApplicableTerms;
} & AnnotationTerm<Core.QualifiedTermName[]>;
/**
  The annotated collection must have at most the specified number of items.
*/
export type MaxItems = {
    term: ValidationAnnotationTerms.MaxItems;
} & AnnotationTerm<Edm.Int64>;
/**
  The annotated collection must have at least the specified number of items.
*/
export type MinItems = {
    term: ValidationAnnotationTerms.MinItems;
} & AnnotationTerm<Edm.Int64>;
export declare const enum ValidationAnnotationTerms {
    Pattern = "Org.OData.Validation.V1.Pattern",
    Minimum = "Org.OData.Validation.V1.Minimum",
    Maximum = "Org.OData.Validation.V1.Maximum",
    Exclusive = "Org.OData.Validation.V1.Exclusive",
    AllowedValues = "Org.OData.Validation.V1.AllowedValues",
    MultipleOf = "Org.OData.Validation.V1.MultipleOf",
    Constraint = "Org.OData.Validation.V1.Constraint",
    ItemsOf = "Org.OData.Validation.V1.ItemsOf",
    OpenPropertyTypeConstraint = "Org.OData.Validation.V1.OpenPropertyTypeConstraint",
    DerivedTypeConstraint = "Org.OData.Validation.V1.DerivedTypeConstraint",
    AllowedTerms = "Org.OData.Validation.V1.AllowedTerms",
    ApplicableTerms = "Org.OData.Validation.V1.ApplicableTerms",
    MaxItems = "Org.OData.Validation.V1.MaxItems",
    MinItems = "Org.OData.Validation.V1.MinItems"
}
export declare const enum ValidationAnnotationTypes {
    AllowedValue = "Org.OData.Validation.V1.AllowedValue",
    ConstraintType = "Org.OData.Validation.V1.ConstraintType",
    ItemsOfType = "Org.OData.Validation.V1.ItemsOfType"
}
export type AllowedValueTypes = AllowedValue;
export type ConstraintTypeTypes = ConstraintType;
export type ItemsOfTypeTypes = ItemsOfType;
