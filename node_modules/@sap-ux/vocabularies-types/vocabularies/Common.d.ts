import * as Core from "./Core";
import * as Aggregation from "./Aggregation";
import * as Analytics from "./Analytics";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import ComplexType = Edm.RecordComplexType;
/**
  Terms, types, and properties annotated with this term are experimental and can be changed incompatibly or removed completely any time without prior warning.
*/
export type Experimental = {
    term: CommonAnnotationTerms.Experimental;
} & AnnotationTerm<Edm.String>;
/**
  1 for first version of a service, incremented when schema changes incompatibly and service is published with a different URI
*/
export type ServiceVersion = {
    term: CommonAnnotationTerms.ServiceVersion;
} & AnnotationTerm<Edm.Int32>;
/**
  0 for first schema version within a service version, incremented when schema changes compatibly
*/
export type ServiceSchemaVersion = {
    term: CommonAnnotationTerms.ServiceSchemaVersion;
} & AnnotationTerm<Edm.Int32>;
/**
  A short, human-readable text suitable for labels and captions in UIs
*/
export type Label = {
    term: CommonAnnotationTerms.Label;
} & AnnotationTerm<Edm.String>;
/**
  A short, human-readable text suitable for column headings in UIs
*/
export type Heading = {
    term: CommonAnnotationTerms.Heading;
} & AnnotationTerm<Edm.String>;
/**
  A short, human-readable text suitable for tool tips in UIs
*/
export type QuickInfo = {
    term: CommonAnnotationTerms.QuickInfo;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  A descriptive text for values of the annotated property. Value MUST be a dynamic expression when used as metadata annotation.
*/
export type Text = {
    term: CommonAnnotationTerms.Text;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  The annotated property contains a descriptive text for values of the referenced property.
*/
export type TextFor = {
    term: CommonAnnotationTerms.TextFor;
} & AnnotationTerm<Edm.PropertyPath>;
/**
  A human readable identifier for values of the annotated property or parameter. Value MUST be a dynamic expression when used as metadata annotation.
*/
export type ExternalID = {
    term: CommonAnnotationTerms.ExternalID;
} & AnnotationTerm<Edm.String>;
/**
  An identifier to distinguish multiple texts in different languages for the same entity
*/
export type IsLanguageIdentifier = {
    term: CommonAnnotationTerms.IsLanguageIdentifier;
} & AnnotationTerm<Core.Tag>;
/**
  The annotated property, parameter, or return type contains human-readable text that may contain formatting information
*/
export type TextFormat = TextFormatType | TextFormatTypeValues;
export declare const enum TextFormatType {
    /**
    Plain text, line breaks represented as the character 0x0A
    */
    /**
    undefined
    */
    plain = "Common.TextFormatType/plain",
    /**
    Plain text with markup that can validly appear directly within an HTML DIV element
    */
    /**
    undefined
    */
    html = "Common.TextFormatType/html"
}
export declare const enum TextFormatTypeValues {
    /**
    Plain text, line breaks represented as the character 0x0A
    */
    /**
    undefined
    */
    plain = 0,
    /**
    Plain text with markup that can validly appear directly within an HTML DIV element
    */
    /**
    undefined
    */
    html = 1
}
/**
  The point in time represented by the annotated property or parameter shall be interpreted in the given time zone
*/
export type Timezone = {
    term: CommonAnnotationTerms.Timezone;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Annotated property or parameter is a time zone
*/
export type IsTimezone = {
    term: CommonAnnotationTerms.IsTimezone;
} & AnnotationTerm<Core.Tag>;
/**
  Contains only digits
*/
export type IsDigitSequence = {
    term: CommonAnnotationTerms.IsDigitSequence;
} & AnnotationTerm<Core.Tag>;
/**
  Contains just uppercase characters
*/
export type IsUpperCase = {
    term: CommonAnnotationTerms.IsUpperCase;
} & AnnotationTerm<Core.Tag>;
/**
  Annotated property or parameter is a currency code
*/
export type IsCurrency = {
    term: CommonAnnotationTerms.IsCurrency;
} & AnnotationTerm<Core.Tag>;
/**
  Annotated property or parameter is a unit of measure
*/
export type IsUnit = {
    term: CommonAnnotationTerms.IsUnit;
} & AnnotationTerm<Core.Tag>;
/**
  The number of fractional decimal digits of a currency amount or measured quantity
*/
export type UnitSpecificScale = {
    term: CommonAnnotationTerms.UnitSpecificScale;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  The number of significant decimal digits of a currency amount or measured quantity
*/
export type UnitSpecificPrecision = {
    term: CommonAnnotationTerms.UnitSpecificPrecision;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  The listed properties form a secondary key. Multiple secondary keys are possible using different qualifiers.
*/
export type SecondaryKey = {
    term: CommonAnnotationTerms.SecondaryKey;
} & AnnotationTerm<Edm.PropertyPath[]>;
/**
  The annotated set or collection contains at least this number of items
*/
export type MinOccurs = {
    term: CommonAnnotationTerms.MinOccurs;
} & AnnotationTerm<Edm.Int64>;
/**
  The annotated set or collection contains at most this number of items
*/
export type MaxOccurs = {
    term: CommonAnnotationTerms.MaxOccurs;
} & AnnotationTerm<Edm.Int64>;
/**
  Entity representing an n:m association with attributes
*/
export type AssociationEntity = {
    term: CommonAnnotationTerms.AssociationEntity;
} & AnnotationTerm<Edm.NavigationPropertyPath[]>;
/**
  Shortcut for a multi-segment navigation, contains the long path with all its segments
*/
export type DerivedNavigation = {
    term: CommonAnnotationTerms.DerivedNavigation;
} & AnnotationTerm<Edm.NavigationPropertyPath>;
/**
  Property contains sensitive data that should by default be masked on a UI and clear-text visible only upon user interaction
*/
export type Masked = {
    term: CommonAnnotationTerms.Masked;
} & AnnotationTerm<Core.Tag>;
/**
  Property contains sensitive data that is by default not transferred
*/
export type MaskedValue = {
    term: CommonAnnotationTerms.MaskedValue;
} & AnnotationTerm<Edm.String>;
/**
  Unmasked data for this property can be requested with custom query option `masked-values=false`
*/
export type RevealOnDemand = {
    term: CommonAnnotationTerms.RevealOnDemand;
} & AnnotationTerm<Edm.Boolean>;
/**
  Name of the Semantic Object represented as this entity type or identified by this property
*/
export type SemanticObject = {
    term: CommonAnnotationTerms.SemanticObject;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Maps properties of the annotated entity type or sibling properties of the annotated property to properties of the Semantic Object
*/
export type SemanticObjectMapping = {
    term: CommonAnnotationTerms.SemanticObjectMapping;
} & AnnotationTerm<SemanticObjectMappingTypeTypes[]>;
/**
  Maps a property of the annotated entity type or a sibling property of the annotated property to a property of the Semantic Object
*/
export type SemanticObjectMappingType = ComplexType & {
    $Type: CommonAnnotationTypes.SemanticObjectMappingType;
    /**
        Path to a local property that provides the value for the Semantic Object property
    */
    LocalProperty: Edm.PropertyPath;
    /**
        Name of the Semantic Object property
    */
    SemanticObjectProperty: Edm.String;
};
/**
  List of actions that are not available in the current state of the instance of the Semantic Object
*/
export type SemanticObjectUnavailableActions = {
    term: CommonAnnotationTerms.SemanticObjectUnavailableActions;
} & AnnotationTerm<Edm.String[]>;
/**
  Term can also be used as instance annotation; AppliesTo of this term specifies where it can be applied
*/
export type IsInstanceAnnotation = {
    term: CommonAnnotationTerms.IsInstanceAnnotation;
} & AnnotationTerm<Core.Tag>;
/**
  These properties only allow a subset of expressions
*/
export type FilterExpressionRestrictions = {
    term: CommonAnnotationTerms.FilterExpressionRestrictions;
} & AnnotationTerm<FilterExpressionRestrictionTypeTypes[]>;
export type FilterExpressionRestrictionType = ComplexType & {
    $Type: CommonAnnotationTypes.FilterExpressionRestrictionType;
    Property?: Edm.PropertyPath;
    AllowedExpressions?: FilterExpressionType;
};
export declare const enum FilterExpressionType {
    /**
    a single 'eq' clause
    */
    /**
    undefined
    */
    SingleValue = "Common.FilterExpressionType/SingleValue",
    /**
    one or more 'eq' clauses, separated by 'or'
    */
    /**
    undefined
    */
    MultiValue = "Common.FilterExpressionType/MultiValue",
    /**
    at most one 'ge' and one 'le' clause, separated by 'and', alternatively a single 'eq' clause
    */
    /**
    undefined
    */
    SingleInterval = "Common.FilterExpressionType/SingleInterval"
}
export declare const enum FilterExpressionTypeValues {
    /**
    a single 'eq' clause
    */
    /**
    undefined
    */
    SingleValue = 0,
    /**
    one or more 'eq' clauses, separated by 'or'
    */
    /**
    undefined
    */
    MultiValue = 1,
    /**
    at most one 'ge' and one 'le' clause, separated by 'and', alternatively a single 'eq' clause
    */
    /**
    undefined
    */
    SingleInterval = 2
}
/**
  Control state of a property, parameter, or the media stream of a media entity
*/
export type FieldControl = PropertyAnnotationValue<FieldControlType | FieldControlTypeValues>;
/**
  Control state of a property
*/
export declare const enum FieldControlType {
    /**
    Property is mandatory from a business perspective
    */
    /**
    A request that
            <br>- sets the property to null or an empty value or
            <br>- creates a non-[draft](#DraftRoot) entity and omits the property or
            <br>- activates a draft entity while the property is null or empty
            <br>fails entirely if this annotation is `Mandatory` in the after-image of the request.
            The empty string is an empty value. Service-specific rules may consider other values, also
            of non-string type, empty.
            Values in draft entities are never considered empty.
            Mandatory properties SHOULD be decorated in the UI with an asterisk.
            Null or empty values can also be disallowed by restricting the property value range with the standard type facet `Nullable` or terms from the [Validation vocabulary](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Validation.V1.md).
    */
    Mandatory = "Common.FieldControlType/Mandatory",
    /**
    Property may have a value
    */
    /**
    This value does not make sense as a static annotation value.
    */
    Optional = "Common.FieldControlType/Optional",
    /**
    Property value cannot be changed
    */
    /**
    A request to change the property to a value that differs from the before-image fails entirely
            according to [OData-Protocol, section 11.4.3](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity)
            if this annotation is given dynamically as `ReadOnly` in the before-image of the request.

            To statically mark a property as read-only use term [Core.Computed](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#Computed) instead.
    */
    ReadOnly = "Common.FieldControlType/ReadOnly",
    /**
    Property has no meaning in the current entity state
    */
    /**
    A request that sets the property to a non-initial non-null value fails entirely if this annotation is `Inapplicable` in the after-image of the request.

            This value does not make sense as a static annotation value.

Example for dynamic use: in a travel expense report the property `DestinationCountry` is inapplicable if trip type is domestic, and mandatory if trip type is international.
    */
    Inapplicable = "Common.FieldControlType/Inapplicable",
    /**
    Deprecated synonym for Inapplicable, do not use
    */
    /**
    To statically hide a property on a UI use [UI.Hidden](UI.md#Hidden) instead
    */
    Hidden = "Common.FieldControlType/Hidden"
}
export declare const enum FieldControlTypeValues {
    /**
    Property is mandatory from a business perspective
    */
    /**
    A request that
            <br>- sets the property to null or an empty value or
            <br>- creates a non-[draft](#DraftRoot) entity and omits the property or
            <br>- activates a draft entity while the property is null or empty
            <br>fails entirely if this annotation is `Mandatory` in the after-image of the request.
            The empty string is an empty value. Service-specific rules may consider other values, also
            of non-string type, empty.
            Values in draft entities are never considered empty.
            Mandatory properties SHOULD be decorated in the UI with an asterisk.
            Null or empty values can also be disallowed by restricting the property value range with the standard type facet `Nullable` or terms from the [Validation vocabulary](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Validation.V1.md).
    */
    Mandatory = 7,
    /**
    Property may have a value
    */
    /**
    This value does not make sense as a static annotation value.
    */
    Optional = 3,
    /**
    Property value cannot be changed
    */
    /**
    A request to change the property to a value that differs from the before-image fails entirely
            according to [OData-Protocol, section 11.4.3](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity)
            if this annotation is given dynamically as `ReadOnly` in the before-image of the request.

            To statically mark a property as read-only use term [Core.Computed](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#Computed) instead.
    */
    ReadOnly = 1,
    /**
    Property has no meaning in the current entity state
    */
    /**
    A request that sets the property to a non-initial non-null value fails entirely if this annotation is `Inapplicable` in the after-image of the request.

            This value does not make sense as a static annotation value.

Example for dynamic use: in a travel expense report the property `DestinationCountry` is inapplicable if trip type is domestic, and mandatory if trip type is international.
    */
    Inapplicable = 0,
    /**
    Deprecated synonym for Inapplicable, do not use
    */
    /**
    To statically hide a property on a UI use [UI.Hidden](UI.md#Hidden) instead
    */
    Hidden = 0
}
/**
  A machine-readable exception category
*/
export type ExceptionCategory = {
    term: CommonAnnotationTerms.ExceptionCategory;
} & AnnotationTerm<Edm.String>;
/**
  ...
*/
export type Application = {
    term: CommonAnnotationTerms.Application;
} & AnnotationTerm<ApplicationTypeTypes>;
export type ApplicationType = ComplexType & {
    $Type: CommonAnnotationTypes.ApplicationType;
    /**
        Software component of service implementation
    */
    Component?: Edm.String;
    /**
        ...
    */
    ServiceRepository?: Edm.String;
    /**
        ...
    */
    ServiceId?: Edm.String;
    /**
        ...
    */
    ServiceVersion?: Edm.String;
};
/**
  ...
*/
export type Timestamp = {
    term: CommonAnnotationTerms.Timestamp;
} & AnnotationTerm<Edm.DateTimeOffset>;
/**
  ...
*/
export type TransactionId = {
    term: CommonAnnotationTerms.TransactionId;
} & AnnotationTerm<Edm.String>;
/**
  Hints for resolving this error
*/
export type ErrorResolution = {
    term: CommonAnnotationTerms.ErrorResolution;
} & AnnotationTerm<ErrorResolutionTypeTypes>;
export type ErrorResolutionType = ComplexType & {
    $Type: CommonAnnotationTypes.ErrorResolutionType;
    /**
        Short hint on how to analyze this error
    */
    Analysis?: Edm.String;
    /**
        Note for error resolution
    */
    Note?: Edm.String;
    /**
        Additional note for error resolution
    */
    AdditionalNote?: Edm.String;
};
/**
  Collection of end-user messages
*/
export type Messages = {
    term: CommonAnnotationTerms.Messages;
} & AnnotationTerm<Edm.ComplexType[]>;
/**
  Additional targets for the message
*/
export type additionalTargets = {
    term: CommonAnnotationTerms.additionalTargets;
} & AnnotationTerm<Edm.String[]>;
/**
  Location of the message long text
*/
export type longtextUrl = {
    term: CommonAnnotationTerms.longtextUrl;
} & AnnotationTerm<Edm.String>;
/**
  Classifies an end-user message as info, success, warning, or error
*/
export type numericSeverity = {
    term: CommonAnnotationTerms.numericSeverity;
} & AnnotationTerm<NumericMessageSeverityType>;
/**
  The maximum severity of all end-user messages attached to an entity, null if no messages are attached
*/
export type MaximumNumericMessageSeverity = {
    term: CommonAnnotationTerms.MaximumNumericMessageSeverity;
} & AnnotationTerm<NumericMessageSeverityType>;
/**
  Classifies an end-user message as info, success, warning, or error
*/
export type NumericMessageSeverityType = Edm.Byte;
/**
  Criticality of the function or action to enforce a warning or similar before it's executed
*/
export type IsActionCritical = {
    term: CommonAnnotationTerms.IsActionCritical;
} & AnnotationTerm<Edm.Boolean>;
/**
  Attributes related to this property, which may occur in denormalized entity types
*/
export type Attributes = {
    term: CommonAnnotationTerms.Attributes;
} & AnnotationTerm<Edm.PropertyPath[]>;
/**
  A recursive hierarchy related to this property. The annotation path must end in Aggregation.RecursiveHierarchy.
*/
export type RelatedRecursiveHierarchy = {
    term: CommonAnnotationTerms.RelatedRecursiveHierarchy;
} & AnnotationTerm<Edm.AnnotationPath<any>>;
/**
  An interval with lower and upper boundaries described by two properties
*/
export type Interval = {
    term: CommonAnnotationTerms.Interval;
} & AnnotationTerm<IntervalTypeTypes>;
export type IntervalType = ComplexType & {
    $Type: CommonAnnotationTypes.IntervalType;
    /**
        A short, human-readable text suitable for labels and captions in UIs
    */
    Label?: Edm.String;
    /**
        Property holding the lower interval boundary
    */
    LowerBoundary: Edm.PropertyPath;
    /**
        The lower boundary value is included in the interval
    */
    LowerBoundaryIncluded: Edm.Boolean;
    /**
        Property holding the upper interval boundary
    */
    UpperBoundary: Edm.PropertyPath;
    /**
        The upper boundary value is included in the interval
    */
    UpperBoundaryIncluded: Edm.Boolean;
};
/**
  The annotated entity type has one or more containment navigation properties.
            An instance of the annotated entity type provides the context required for determining
            the target entity sets reached by these containment navigation properties.
*/
export type ResultContext = {
    term: CommonAnnotationTerms.ResultContext;
} & AnnotationTerm<Core.Tag>;
/**
  The SAP Object Node Type represented by the annotated entity type
*/
export type SAPObjectNodeType = {
    term: CommonAnnotationTerms.SAPObjectNodeType;
} & AnnotationTerm<SAPObjectNodeTypeTypeTypes>;
/**
  Information about an SAP Object Node Type
*/
export type SAPObjectNodeTypeType = ComplexType & {
    $Type: CommonAnnotationTypes.SAPObjectNodeTypeType;
    /**
        The name of the SAP Object Node Type
    */
    Name: Edm.String;
};
/**
  The annotated navigation property represents a logical composition, even though it is non-containment
*/
export type Composition = {
    term: CommonAnnotationTerms.Composition;
} & AnnotationTerm<Core.Tag>;
/**
  The entity referenced by the annotated property has the [`SAPObjectNodeType`](#SAPObjectNodeType) with this name
*/
export type SAPObjectNodeTypeReference = {
    term: CommonAnnotationTerms.SAPObjectNodeTypeReference;
} & AnnotationTerm<Edm.String>;
/**
  The annotated entity type (e.g. `Employee`) or annotation (e.g. `IsImageUrl`) represents a natural person
*/
export type IsNaturalPerson = {
    term: CommonAnnotationTerms.IsNaturalPerson;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Specifies how to get a list of acceptable values for a property or parameter
*/
export type ValueList = {
    term: CommonAnnotationTerms.ValueList;
} & AnnotationTerm<ValueListTypeTypes>;
export type ValueListType = ComplexType & {
    $Type: CommonAnnotationTypes.ValueListType;
    /**
        Headline for value list, fallback is the label of the property or parameter
    */
    Label?: Edm.String;
    /**
        Resource path of an OData collection with possible values, relative to CollectionRoot
    */
    CollectionPath: Edm.String;
    /**
        Service root of the value list collection; not specified means local to the document containing the annotation
    */
    CollectionRoot?: Edm.String;
    /**
        Indicates that the value list supports a 'distinct' aggregation on the value list properties defined via ValueListParameterInOut and ValueListParameterOut
    */
    DistinctValuesSupported: Edm.Boolean;
    /**
        Value list supports the $search query option
    */
    SearchSupported: Edm.Boolean;
    /**
        Hint on when to fetch values
    */
    FetchValues?: FetchValuesType;
    /**
        Alternative representation of a value help, e.g. as a bar chart
    */
    PresentationVariantQualifier?: Core.SimpleIdentifier;
    /**
        Optional combination of parameters and filters to query the value help entity set
    */
    SelectionVariantQualifier?: Core.SimpleIdentifier;
    /**
        Instructions on how to construct the value list request and consume response properties
    */
    Parameters: ValueListParameterTypes[];
};
/**
  Hint on when to fetch values
*/
export type FetchValuesType = Edm.Byte;
/**
  List of qualifiers of relevant ValueList annotations
*/
export type ValueListRelevantQualifiers = {
    term: CommonAnnotationTerms.ValueListRelevantQualifiers;
} & AnnotationTerm<PropertyAnnotationValue<Core.SimpleIdentifier[]>>;
/**
  If specified as true, there's only one value list mapping and its value list consists of a small number of fixed values
*/
export type ValueListWithFixedValues = {
    term: CommonAnnotationTerms.ValueListWithFixedValues;
} & AnnotationTerm<Core.Tag>;
/**
  A value list with a very small number of fixed values, can decide to show all values immediately
*/
export type ValueListShowValuesImmediately = {
    term: CommonAnnotationTerms.ValueListShowValuesImmediately;
} & AnnotationTerm<Core.Tag>;
/**
  Contains the qualifier of the ValueList or ValueListMapping that should be used for validation
*/
export type ValueListForValidation = {
    term: CommonAnnotationTerms.ValueListForValidation;
} & AnnotationTerm<Edm.String>;
/**
  A list of URLs of CSDL documents containing value list mappings for this parameter or property
*/
export type ValueListReferences = {
    term: CommonAnnotationTerms.ValueListReferences;
} & AnnotationTerm<Edm.String[]>;
/**
  Specifies the mapping between data service properties and value list properties
*/
export type ValueListMapping = {
    term: CommonAnnotationTerms.ValueListMapping;
} & AnnotationTerm<ValueListMappingTypeTypes>;
export type ValueListMappingType = ComplexType & {
    $Type: CommonAnnotationTypes.ValueListMappingType;
    /**
        Headline for value list, fallback is the label of the property or parameter
    */
    Label?: Edm.String;
    /**
        Resource path of an OData collection with possible values, relative to the document containing the value list mapping
    */
    CollectionPath: Edm.String;
    /**
        Indicates that the value list supports a 'distinct' aggregation on the value list properties defined via ValueListParameterInOut and ValueListParameterOut
    */
    DistinctValuesSupported: Edm.Boolean;
    /**
        Hint on when to fetch values
    */
    FetchValues?: FetchValuesType;
    /**
        Alternative representation of a value help, e.g. as a bar chart
    */
    PresentationVariantQualifier?: Core.SimpleIdentifier;
    /**
        Optional combination of parameters and filters to query the value help entity set
    */
    SelectionVariantQualifier?: Core.SimpleIdentifier;
    /**
        Instructions on how to construct the value list request and consume response properties
    */
    Parameters: ValueListParameterTypes[];
};
export type ValueListParameter = ComplexType & {
    $Type: CommonAnnotationTypes.ValueListParameter;
    /**
        Path to property in the value list . Format is identical to PropertyPath annotations.
    */
    ValueListProperty: Edm.String;
};
export type ValueListParameterIn = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterIn;
    /**
        Path to property that is used to filter the value list with `eq` comparison
    */
    LocalDataProperty: Edm.PropertyPath;
    /**
        Initial value, e.g. empty string, is a valid and significant value
    */
    InitialValueIsSignificant: Edm.Boolean;
};
export type ValueListParameterConstant = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterConstant;
    /**
        Constant value that is used to filter the value list with `eq` comparison, using the same representation as property default values, see [CSDL XML, 7.2.7 Default Value](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_DefaultValue)
    */
    Constant: Edm.PrimitiveType;
    /**
        Initial value, e.g. empty string, is a valid and significant value
    */
    InitialValueIsSignificant: Edm.Boolean;
};
export type ValueListParameterConstants = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterConstants;
    /**
        List of constant values that are used to filter the value list with `eq` comparisons connected by `or` operators, using the same representation as property default values, see [CSDL XML, 7.2.7 Default Value](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_DefaultValue). Initial values are significant.
    */
    Constants: Edm.PrimitiveType[];
};
export type ValueListParameterInOut = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterInOut;
    /**
        Path to property that is used to filter the value list with `startswith` comparison and filled from the picked value list item
    */
    LocalDataProperty: Edm.PropertyPath;
    /**
        Initial value, e.g. empty string, is a valid and significant value
    */
    InitialValueIsSignificant: Edm.Boolean;
};
export type ValueListParameterOut = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterOut;
    /**
        Path to property that is filled from response
    */
    LocalDataProperty: Edm.PropertyPath;
};
/**
  Value list property that is not used to fill the edited entity
*/
export type ValueListParameterDisplayOnly = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterDisplayOnly;
};
/**
  Value list property that is used to filter the value list, not connected to the edited entity
*/
export type ValueListParameterFilterOnly = ComplexType & Omit<ValueListParameter, '$Type'> & {
    $Type: CommonAnnotationTypes.ValueListParameterFilterOnly;
};
/**
  Property encodes a year number as string following the logical pattern (-?)YYYY(Y*) consisting of an optional
            minus sign for years B.C. followed by at least four digits. The string matches the regex pattern -?([1-9][0-9]{3,}|0[0-9]{3})
          
*/
export type IsCalendarYear = {
    term: CommonAnnotationTerms.IsCalendarYear;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a halfyear number as string following the logical pattern H consisting of a single digit.
            The string matches the regex pattern [1-2]
          
*/
export type IsCalendarHalfyear = {
    term: CommonAnnotationTerms.IsCalendarHalfyear;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar quarter number as string following the logical pattern Q consisting of a single digit.
            The string matches the regex pattern [1-4]
          
*/
export type IsCalendarQuarter = {
    term: CommonAnnotationTerms.IsCalendarQuarter;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar month number as string following the logical pattern MM consisting of two digits.
            The string matches the regex pattern 0[1-9]|1[0-2]
          
*/
export type IsCalendarMonth = {
    term: CommonAnnotationTerms.IsCalendarMonth;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar week number as string following the logical pattern WW consisting of two digits.
            The string matches the regex pattern 0[1-9]|[1-4][0-9]|5[0-3]
          
*/
export type IsCalendarWeek = {
    term: CommonAnnotationTerms.IsCalendarWeek;
} & AnnotationTerm<Core.Tag>;
/**
  Day number relative to a calendar month. Valid values are between 1 and 31.
          
*/
export type IsDayOfCalendarMonth = {
    term: CommonAnnotationTerms.IsDayOfCalendarMonth;
} & AnnotationTerm<Core.Tag>;
/**
  Day number relative to a calendar year. Valid values are between 1 and 366.
          
*/
export type IsDayOfCalendarYear = {
    term: CommonAnnotationTerms.IsDayOfCalendarYear;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar year and halfyear as string following the logical pattern (-?)YYYY(Y*)H consisting
            of an optional minus sign for years B.C. followed by at least five digits, where the last digit represents the halfyear.
            The string matches the regex pattern -?([1-9][0-9]{3,}|0[0-9]{3})[1-2]
          
*/
export type IsCalendarYearHalfyear = {
    term: CommonAnnotationTerms.IsCalendarYearHalfyear;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar year and quarter as string following the logical pattern (-?)YYYY(Y*)Q consisting
            of an optional minus sign for years B.C. followed by at least five digits, where the last digit represents the quarter.
            The string matches the regex pattern -?([1-9][0-9]{3,}|0[0-9]{3})[1-4]
          
*/
export type IsCalendarYearQuarter = {
    term: CommonAnnotationTerms.IsCalendarYearQuarter;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar year and month as string following the logical pattern (-?)YYYY(Y*)MM consisting
            of an optional minus sign for years B.C. followed by at least six digits, where the last two digits represent the months January to
            December.
            The string matches the regex pattern -?([1-9][0-9]{3,}|0[0-9]{3})(0[1-9]|1[0-2])
          
*/
export type IsCalendarYearMonth = {
    term: CommonAnnotationTerms.IsCalendarYearMonth;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar year and week as string following the logical pattern (-?)YYYY(Y*)WW consisting
          of an optional minus sign for years B.C. followed by at least six digits, where the last two digits represent week number in the year.
          The string matches the regex pattern -?([1-9][0-9]{3,}|0[0-9]{3})(0[1-9]|[1-4][0-9]|5[0-3])
          
*/
export type IsCalendarYearWeek = {
    term: CommonAnnotationTerms.IsCalendarYearWeek;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a calendar date: year, month and day as string following the logical pattern (-?)YYYY(Y*)MMDD consisting
          of an optional minus sign for years B.C. followed by at least eight digits, where the last four digits represent
          the months January to December (MM) and the day of the month (DD).
          The string matches the regex pattern -?([1-9][0-9]{3,}|0[0-9]{3})(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])
          The regex pattern does not reflect the additional constraint for "Day-of-month Values":
          The day value must be no more than 30 if month is one of 04, 06, 09, or 11, no more than 28 if month is 02 and year is not divisible by 4,
          or is divisible by 100 but not by 400, and no more than 29 if month is 02 and year is divisible by 400, or by 4 but not by 100.
          
*/
export type IsCalendarDate = {
    term: CommonAnnotationTerms.IsCalendarDate;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal year number as string following the logical pattern YYYY consisting of four digits.
          The string matches the regex pattern [1-9][0-9]{3}
          
*/
export type IsFiscalYear = {
    term: CommonAnnotationTerms.IsFiscalYear;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal period as string following the logical pattern PPP consisting of three digits.
          The string matches the regex pattern [0-9]{3}
          
*/
export type IsFiscalPeriod = {
    term: CommonAnnotationTerms.IsFiscalPeriod;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal year and period as string following the logical pattern YYYYPPP consisting
          of seven digits, where the last three digits represent the fiscal period in the year.
          The string matches the regex pattern ([1-9][0-9]{3})([0-9]{3})
          
*/
export type IsFiscalYearPeriod = {
    term: CommonAnnotationTerms.IsFiscalYearPeriod;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal quarter number as string following the logical pattern Q consisting of a single digit.
          The string matches the regex pattern [1-4]
*/
export type IsFiscalQuarter = {
    term: CommonAnnotationTerms.IsFiscalQuarter;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal year and quarter as string following the logical pattern YYYYQ consisting of
          five digits, where the last digit represents the quarter.
          The string matches the regex pattern [1-9][0-9]{3}[1-4]
*/
export type IsFiscalYearQuarter = {
    term: CommonAnnotationTerms.IsFiscalYearQuarter;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal week number as string following the logical pattern WW consisting of two digits.
          The string matches the regex pattern 0[1-9]|[1-4][0-9]|5[0-3]
*/
export type IsFiscalWeek = {
    term: CommonAnnotationTerms.IsFiscalWeek;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal year and week as string following the logical pattern YYYYWW consisting of
          six digits, where the last two digits represent the week number in the year.
          The string matches the regex pattern [1-9][0-9]{3}(0[1-9]|[1-4][0-9]|5[0-3])
*/
export type IsFiscalYearWeek = {
    term: CommonAnnotationTerms.IsFiscalYearWeek;
} & AnnotationTerm<Core.Tag>;
/**
  Day number relative to a fiscal year. Valid values are between 1 and 371.
*/
export type IsDayOfFiscalYear = {
    term: CommonAnnotationTerms.IsDayOfFiscalYear;
} & AnnotationTerm<Core.Tag>;
/**
  Property encodes a fiscal year variant
*/
export type IsFiscalYearVariant = {
    term: CommonAnnotationTerms.IsFiscalYearVariant;
} & AnnotationTerm<Core.Tag>;
/**
  Only one term of the group identified with the Qualifier attribute can be applied
*/
export type MutuallyExclusiveTerm = {
    term: CommonAnnotationTerms.MutuallyExclusiveTerm;
} & AnnotationTerm<Core.Tag>;
/**
  Root entities of business documents that support the draft pattern
*/
export type DraftRoot = {
    term: CommonAnnotationTerms.DraftRoot;
} & AnnotationTerm<DraftRootTypeTypes>;
export type DraftRootType = ComplexType & Omit<DraftNodeType, '$Type'> & {
    $Type: CommonAnnotationTypes.DraftRootType;
    /**
        Action that activates a draft document
    */
    ActivationAction: QualifiedName;
    /**
        Action that discards a draft document
    */
    DiscardAction?: QualifiedName;
    /**
        Action that creates an edit draft
    */
    EditAction?: QualifiedName;
    /**
        Action that creates a new draft
    */
    NewAction?: QualifiedName;
    /**
        Additional actions that create a new draft
    */
    AdditionalNewActions: QualifiedName[];
    /**
        Action that shares a draft document with other users
    */
    ShareAction?: QualifiedName;
};
/**
  Entities in this set are parts of business documents that support the draft pattern
*/
export type DraftNode = {
    term: CommonAnnotationTerms.DraftNode;
} & AnnotationTerm<DraftNodeTypeTypes>;
export type DraftNodeType = ComplexType & {
    $Type: CommonAnnotationTypes.DraftNodeType;
    /**
        Action that prepares a draft document for later activation
    */
    PreparationAction?: QualifiedName;
    /**
        Function that validates whether a draft document is ready for activation
    */
    ValidationFunction?: QualifiedName;
};
/**
  Draft entities in this set are indirectly activated via draft entities in the referenced entity sets
*/
export type DraftActivationVia = {
    term: CommonAnnotationTerms.DraftActivationVia;
} & AnnotationTerm<Core.SimpleIdentifier[]>;
/**
  The annotated property is an editable field for the referenced key property
*/
export type EditableFieldFor = {
    term: CommonAnnotationTerms.EditableFieldFor;
} & AnnotationTerm<Edm.PropertyPath>;
/**
  The SimpleIdentifier of an OData construct in scope
*/
export type SimpleIdentifier = Edm.String;
/**
  The namespace-qualified name of an OData construct in scope
*/
export type QualifiedName = Edm.String;
/**
  The namespace-qualified name of an action with an optional overload
*/
export type ActionOverload = Edm.String;
/**
  The listed properties form the semantic key, i.e. they are unique modulo IsActiveEntity
*/
export type SemanticKey = {
    term: CommonAnnotationTerms.SemanticKey;
} & AnnotationTerm<Edm.PropertyPath[]>;
/**
  Describes side-effects of modification operations
*/
export type SideEffects = {
    term: CommonAnnotationTerms.SideEffects;
} & AnnotationTerm<SideEffectsTypeTypes>;
/**
  Changes to the source properties or source entities may have side-effects on the target properties or entities.
*/
export type SideEffectsType = ComplexType & {
    $Type: CommonAnnotationTypes.SideEffectsType;
    /**
        Changes to the values of one or more of these structural properties may affect the targets
    */
    SourceProperties: Edm.PropertyPath[];
    /**
        Changes to one or more of these entities may affect the targets. An empty path means the annotation target.
    */
    SourceEntities: Edm.NavigationPropertyPath[];
    /**
        These structural properties may be affected if the value of one of the sources changes
    */
    TargetProperties: Edm.String[];
    /**
        These entities will be affected if the value of one of the sources changes. All affected entities need to be explicitly listed. An empty path means the annotation target.
    */
    TargetEntities: Edm.NavigationPropertyPath[];
    /**
        One or more of the targets may show these effects. If not specified, any effect is possible.
    */
    EffectTypes?: EffectType[];
    /**
        Bound action to trigger side-effects after modifying an entity
    */
    TriggerAction?: QualifiedName;
    /**
        Indicates whether the side-effect has already happened
    */
    TriggeredIndicator?: Edm.Boolean;
    /**
        Indicates whether the client can decide if a side-effect should be triggered or not
    */
    Discretionary: Edm.Boolean;
};
export declare const enum EffectType {
    /**
    Validation messages are assigned to a target
    */
    /**
    This side effect type indicates that validation messages may result from changes of source properties or entities.
Thus, a validation request can be sent either in conjunction with or separately after a modifying request.
Validation messages shall be persisted with the draft and immediately available in a subsequent request without repeating the validation logic.
    */
    ValidationMessage = "Common.EffectType/ValidationMessage",
    /**
    The value of a target changes
    */
    /**
    This side effect type declares that changes to source properties or entities may impact the values of any, one or multiple target properties or entities.
Upon modification preparation logic is performed that determines additional values to be stored in the draft document.
    */
    ValueChange = "Common.EffectType/ValueChange",
    /**
    The value of the Common.FieldControl annotation of a target changes
    */
    /**
    This side effect type specifies that source properties or entities may impact the dynamic field control state of any, one or multiple target properties or entities.
Upon modification field control logic is invoked so that meta-information like hidden or read-only is determined.
    */
    FieldControlChange = "Common.EffectType/FieldControlChange"
}
export declare const enum EffectTypeValues {
    /**
    Validation messages are assigned to a target
    */
    /**
    This side effect type indicates that validation messages may result from changes of source properties or entities.
Thus, a validation request can be sent either in conjunction with or separately after a modifying request.
Validation messages shall be persisted with the draft and immediately available in a subsequent request without repeating the validation logic.
    */
    ValidationMessage = 1,
    /**
    The value of a target changes
    */
    /**
    This side effect type declares that changes to source properties or entities may impact the values of any, one or multiple target properties or entities.
Upon modification preparation logic is performed that determines additional values to be stored in the draft document.
    */
    ValueChange = 2,
    /**
    The value of the Common.FieldControl annotation of a target changes
    */
    /**
    This side effect type specifies that source properties or entities may impact the dynamic field control state of any, one or multiple target properties or entities.
Upon modification field control logic is invoked so that meta-information like hidden or read-only is determined.
    */
    FieldControlChange = 4
}
/**
  Function to calculate default values based on user input that is only known to the client and "context information" that is already available to the service
*/
export type DefaultValuesFunction = {
    term: CommonAnnotationTerms.DefaultValuesFunction;
} & AnnotationTerm<QualifiedName>;
/**
  Function import to derive a default value for the property from a given context.
*/
export type DerivedDefaultValue = {
    term: CommonAnnotationTerms.DerivedDefaultValue;
} & AnnotationTerm<Edm.String>;
/**
  A default value for the property to be used in filter expressions.
*/
export type FilterDefaultValue = {
    term: CommonAnnotationTerms.FilterDefaultValue;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  A default upper limit for the property to be used in 'less than or equal' filter expressions.
*/
export type FilterDefaultValueHigh = {
    term: CommonAnnotationTerms.FilterDefaultValueHigh;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  Function import to derive a default value for the property from a given context in order to use it in filter expressions.
*/
export type DerivedFilterDefaultValue = {
    term: CommonAnnotationTerms.DerivedFilterDefaultValue;
} & AnnotationTerm<Edm.String>;
/**
  List of sort criteria
*/
export type SortOrder = {
    term: CommonAnnotationTerms.SortOrder;
} & AnnotationTerm<SortOrderTypeTypes[]>;
/**
  Exactly one of `Property` and `DynamicProperty` must be present
*/
export type SortOrderType = ComplexType & {
    $Type: CommonAnnotationTypes.SortOrderType;
    /**
        Sort property
    */
    Property?: Edm.PropertyPath;
    /**
        Dynamic property introduced by an annotation and used as sort property
    */
    DynamicProperty?: Edm.AnnotationPath<Analytics.AggregatedProperty | Aggregation.CustomAggregate>;
    /**
        Sort direction, ascending if not specified otherwise
    */
    Descending?: Edm.Boolean;
};
/**
  Defines a recursive hierarchy.
*/
export type RecursiveHierarchy = {
    term: CommonAnnotationTerms.RecursiveHierarchy;
} & AnnotationTerm<RecursiveHierarchyTypeTypes>;
export type RecursiveHierarchyType = ComplexType & {
    $Type: CommonAnnotationTypes.RecursiveHierarchyType;
    /**
        Property holding the external human-readable key identifying the node
    */
    ExternalNodeKeyProperty?: Edm.PropertyPath;
    /**
        Property holding the descendant count for a hierarchy node.
            The descendant count of a node is the number of its descendants in the hierarchy structure of the result considering
            only those nodes matching any specified $filter and $search. A property holding descendant counts has an integer
            data type.
    */
    NodeDescendantCountProperty?: Edm.PropertyPath;
    /**
        Property holding the drill state of a hierarchy node. The drill state is indicated
            by one of the following string values: collapsed, expanded, or leaf. For an expanded node, its
            children are included in the result collection. For a collapsed node, the children are included in the entity set, but
            they are not part of the result collection. Retrieving them requires a relaxed filter expression or a separate request
            filtering on the parent node ID with the ID of the collapsed node. A leaf does not have any child in the entity set.
            
    */
    NodeDrillStateProperty?: Edm.PropertyPath;
};
/**
  Creation timestamp
*/
export type CreatedAt = {
    term: CommonAnnotationTerms.CreatedAt;
} & AnnotationTerm<Edm.DateTimeOffset>;
/**
  First editor
*/
export type CreatedBy = {
    term: CommonAnnotationTerms.CreatedBy;
} & AnnotationTerm<UserID>;
/**
  Last modification timestamp
*/
export type ChangedAt = {
    term: CommonAnnotationTerms.ChangedAt;
} & AnnotationTerm<Edm.DateTimeOffset>;
/**
  Last editor
*/
export type ChangedBy = {
    term: CommonAnnotationTerms.ChangedBy;
} & AnnotationTerm<UserID>;
/**
  User ID
*/
export type UserID = Edm.String;
/**
  Original protocol version of a converted (V4) CSDL document, allowed values `2.0` and `3.0`
*/
export type OriginalProtocolVersion = {
    term: CommonAnnotationTerms.OriginalProtocolVersion;
} & AnnotationTerm<Edm.String>;
/**
  Sorting and filtering of amounts in multiple currencies needs special consideration
*/
export type ApplyMultiUnitBehaviorForSortingAndFiltering = {
    term: CommonAnnotationTerms.ApplyMultiUnitBehaviorForSortingAndFiltering;
} & AnnotationTerm<Core.Tag>;
/**
  URL for uploading new media content to a Document Management Service
*/
export type mediaUploadLink = {
    term: CommonAnnotationTerms.mediaUploadLink;
} & AnnotationTerm<Edm.String>;
/**
  A term or term property with this tag whose type is (a collection of) `Edm.PropertyPath` MUST resolve to a primitive structural property
*/
export type PrimitivePropertyPath = {
    term: CommonAnnotationTerms.PrimitivePropertyPath;
} & AnnotationTerm<Core.Tag>;
/**
  Base URL for WebSocket connections
*/
export type WebSocketBaseURL = {
    term: CommonAnnotationTerms.WebSocketBaseURL;
} & AnnotationTerm<Edm.String>;
export declare const enum CommonAnnotationTerms {
    Experimental = "com.sap.vocabularies.Common.v1.Experimental",
    ServiceVersion = "com.sap.vocabularies.Common.v1.ServiceVersion",
    ServiceSchemaVersion = "com.sap.vocabularies.Common.v1.ServiceSchemaVersion",
    Label = "com.sap.vocabularies.Common.v1.Label",
    Heading = "com.sap.vocabularies.Common.v1.Heading",
    QuickInfo = "com.sap.vocabularies.Common.v1.QuickInfo",
    Text = "com.sap.vocabularies.Common.v1.Text",
    TextFor = "com.sap.vocabularies.Common.v1.TextFor",
    ExternalID = "com.sap.vocabularies.Common.v1.ExternalID",
    IsLanguageIdentifier = "com.sap.vocabularies.Common.v1.IsLanguageIdentifier",
    TextFormat = "com.sap.vocabularies.Common.v1.TextFormat",
    Timezone = "com.sap.vocabularies.Common.v1.Timezone",
    IsTimezone = "com.sap.vocabularies.Common.v1.IsTimezone",
    IsDigitSequence = "com.sap.vocabularies.Common.v1.IsDigitSequence",
    IsUpperCase = "com.sap.vocabularies.Common.v1.IsUpperCase",
    IsCurrency = "com.sap.vocabularies.Common.v1.IsCurrency",
    IsUnit = "com.sap.vocabularies.Common.v1.IsUnit",
    UnitSpecificScale = "com.sap.vocabularies.Common.v1.UnitSpecificScale",
    UnitSpecificPrecision = "com.sap.vocabularies.Common.v1.UnitSpecificPrecision",
    SecondaryKey = "com.sap.vocabularies.Common.v1.SecondaryKey",
    MinOccurs = "com.sap.vocabularies.Common.v1.MinOccurs",
    MaxOccurs = "com.sap.vocabularies.Common.v1.MaxOccurs",
    AssociationEntity = "com.sap.vocabularies.Common.v1.AssociationEntity",
    DerivedNavigation = "com.sap.vocabularies.Common.v1.DerivedNavigation",
    Masked = "com.sap.vocabularies.Common.v1.Masked",
    MaskedValue = "com.sap.vocabularies.Common.v1.MaskedValue",
    RevealOnDemand = "com.sap.vocabularies.Common.v1.RevealOnDemand",
    SemanticObject = "com.sap.vocabularies.Common.v1.SemanticObject",
    SemanticObjectMapping = "com.sap.vocabularies.Common.v1.SemanticObjectMapping",
    SemanticObjectUnavailableActions = "com.sap.vocabularies.Common.v1.SemanticObjectUnavailableActions",
    IsInstanceAnnotation = "com.sap.vocabularies.Common.v1.IsInstanceAnnotation",
    FilterExpressionRestrictions = "com.sap.vocabularies.Common.v1.FilterExpressionRestrictions",
    FieldControl = "com.sap.vocabularies.Common.v1.FieldControl",
    ExceptionCategory = "com.sap.vocabularies.Common.v1.ExceptionCategory",
    Application = "com.sap.vocabularies.Common.v1.Application",
    Timestamp = "com.sap.vocabularies.Common.v1.Timestamp",
    TransactionId = "com.sap.vocabularies.Common.v1.TransactionId",
    ErrorResolution = "com.sap.vocabularies.Common.v1.ErrorResolution",
    Messages = "com.sap.vocabularies.Common.v1.Messages",
    additionalTargets = "com.sap.vocabularies.Common.v1.additionalTargets",
    longtextUrl = "com.sap.vocabularies.Common.v1.longtextUrl",
    numericSeverity = "com.sap.vocabularies.Common.v1.numericSeverity",
    MaximumNumericMessageSeverity = "com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity",
    IsActionCritical = "com.sap.vocabularies.Common.v1.IsActionCritical",
    Attributes = "com.sap.vocabularies.Common.v1.Attributes",
    RelatedRecursiveHierarchy = "com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy",
    Interval = "com.sap.vocabularies.Common.v1.Interval",
    ResultContext = "com.sap.vocabularies.Common.v1.ResultContext",
    SAPObjectNodeType = "com.sap.vocabularies.Common.v1.SAPObjectNodeType",
    Composition = "com.sap.vocabularies.Common.v1.Composition",
    SAPObjectNodeTypeReference = "com.sap.vocabularies.Common.v1.SAPObjectNodeTypeReference",
    IsNaturalPerson = "com.sap.vocabularies.Common.v1.IsNaturalPerson",
    ValueList = "com.sap.vocabularies.Common.v1.ValueList",
    ValueListRelevantQualifiers = "com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers",
    ValueListWithFixedValues = "com.sap.vocabularies.Common.v1.ValueListWithFixedValues",
    ValueListShowValuesImmediately = "com.sap.vocabularies.Common.v1.ValueListShowValuesImmediately",
    ValueListForValidation = "com.sap.vocabularies.Common.v1.ValueListForValidation",
    ValueListReferences = "com.sap.vocabularies.Common.v1.ValueListReferences",
    ValueListMapping = "com.sap.vocabularies.Common.v1.ValueListMapping",
    IsCalendarYear = "com.sap.vocabularies.Common.v1.IsCalendarYear",
    IsCalendarHalfyear = "com.sap.vocabularies.Common.v1.IsCalendarHalfyear",
    IsCalendarQuarter = "com.sap.vocabularies.Common.v1.IsCalendarQuarter",
    IsCalendarMonth = "com.sap.vocabularies.Common.v1.IsCalendarMonth",
    IsCalendarWeek = "com.sap.vocabularies.Common.v1.IsCalendarWeek",
    IsDayOfCalendarMonth = "com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth",
    IsDayOfCalendarYear = "com.sap.vocabularies.Common.v1.IsDayOfCalendarYear",
    IsCalendarYearHalfyear = "com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear",
    IsCalendarYearQuarter = "com.sap.vocabularies.Common.v1.IsCalendarYearQuarter",
    IsCalendarYearMonth = "com.sap.vocabularies.Common.v1.IsCalendarYearMonth",
    IsCalendarYearWeek = "com.sap.vocabularies.Common.v1.IsCalendarYearWeek",
    IsCalendarDate = "com.sap.vocabularies.Common.v1.IsCalendarDate",
    IsFiscalYear = "com.sap.vocabularies.Common.v1.IsFiscalYear",
    IsFiscalPeriod = "com.sap.vocabularies.Common.v1.IsFiscalPeriod",
    IsFiscalYearPeriod = "com.sap.vocabularies.Common.v1.IsFiscalYearPeriod",
    IsFiscalQuarter = "com.sap.vocabularies.Common.v1.IsFiscalQuarter",
    IsFiscalYearQuarter = "com.sap.vocabularies.Common.v1.IsFiscalYearQuarter",
    IsFiscalWeek = "com.sap.vocabularies.Common.v1.IsFiscalWeek",
    IsFiscalYearWeek = "com.sap.vocabularies.Common.v1.IsFiscalYearWeek",
    IsDayOfFiscalYear = "com.sap.vocabularies.Common.v1.IsDayOfFiscalYear",
    IsFiscalYearVariant = "com.sap.vocabularies.Common.v1.IsFiscalYearVariant",
    MutuallyExclusiveTerm = "com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm",
    DraftRoot = "com.sap.vocabularies.Common.v1.DraftRoot",
    DraftNode = "com.sap.vocabularies.Common.v1.DraftNode",
    DraftActivationVia = "com.sap.vocabularies.Common.v1.DraftActivationVia",
    EditableFieldFor = "com.sap.vocabularies.Common.v1.EditableFieldFor",
    SemanticKey = "com.sap.vocabularies.Common.v1.SemanticKey",
    SideEffects = "com.sap.vocabularies.Common.v1.SideEffects",
    DefaultValuesFunction = "com.sap.vocabularies.Common.v1.DefaultValuesFunction",
    DerivedDefaultValue = "com.sap.vocabularies.Common.v1.DerivedDefaultValue",
    FilterDefaultValue = "com.sap.vocabularies.Common.v1.FilterDefaultValue",
    FilterDefaultValueHigh = "com.sap.vocabularies.Common.v1.FilterDefaultValueHigh",
    DerivedFilterDefaultValue = "com.sap.vocabularies.Common.v1.DerivedFilterDefaultValue",
    SortOrder = "com.sap.vocabularies.Common.v1.SortOrder",
    RecursiveHierarchy = "com.sap.vocabularies.Common.v1.RecursiveHierarchy",
    CreatedAt = "com.sap.vocabularies.Common.v1.CreatedAt",
    CreatedBy = "com.sap.vocabularies.Common.v1.CreatedBy",
    ChangedAt = "com.sap.vocabularies.Common.v1.ChangedAt",
    ChangedBy = "com.sap.vocabularies.Common.v1.ChangedBy",
    OriginalProtocolVersion = "com.sap.vocabularies.Common.v1.OriginalProtocolVersion",
    ApplyMultiUnitBehaviorForSortingAndFiltering = "com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering",
    mediaUploadLink = "com.sap.vocabularies.Common.v1.mediaUploadLink",
    PrimitivePropertyPath = "com.sap.vocabularies.Common.v1.PrimitivePropertyPath",
    WebSocketBaseURL = "com.sap.vocabularies.Common.v1.WebSocketBaseURL"
}
export declare const enum CommonAnnotationTypes {
    SemanticObjectMappingType = "com.sap.vocabularies.Common.v1.SemanticObjectMappingType",
    FilterExpressionRestrictionType = "com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType",
    ApplicationType = "com.sap.vocabularies.Common.v1.ApplicationType",
    ErrorResolutionType = "com.sap.vocabularies.Common.v1.ErrorResolutionType",
    IntervalType = "com.sap.vocabularies.Common.v1.IntervalType",
    SAPObjectNodeTypeType = "com.sap.vocabularies.Common.v1.SAPObjectNodeTypeType",
    ValueListType = "com.sap.vocabularies.Common.v1.ValueListType",
    ValueListMappingType = "com.sap.vocabularies.Common.v1.ValueListMappingType",
    ValueListParameter = "com.sap.vocabularies.Common.v1.ValueListParameter",
    ValueListParameterIn = "com.sap.vocabularies.Common.v1.ValueListParameterIn",
    ValueListParameterConstant = "com.sap.vocabularies.Common.v1.ValueListParameterConstant",
    ValueListParameterConstants = "com.sap.vocabularies.Common.v1.ValueListParameterConstants",
    ValueListParameterInOut = "com.sap.vocabularies.Common.v1.ValueListParameterInOut",
    ValueListParameterOut = "com.sap.vocabularies.Common.v1.ValueListParameterOut",
    ValueListParameterDisplayOnly = "com.sap.vocabularies.Common.v1.ValueListParameterDisplayOnly",
    ValueListParameterFilterOnly = "com.sap.vocabularies.Common.v1.ValueListParameterFilterOnly",
    DraftRootType = "com.sap.vocabularies.Common.v1.DraftRootType",
    DraftNodeType = "com.sap.vocabularies.Common.v1.DraftNodeType",
    SideEffectsType = "com.sap.vocabularies.Common.v1.SideEffectsType",
    SortOrderType = "com.sap.vocabularies.Common.v1.SortOrderType",
    RecursiveHierarchyType = "com.sap.vocabularies.Common.v1.RecursiveHierarchyType"
}
export type SemanticObjectMappingTypeTypes = SemanticObjectMappingType;
export type FilterExpressionRestrictionTypeTypes = FilterExpressionRestrictionType;
export type ApplicationTypeTypes = ApplicationType;
export type ErrorResolutionTypeTypes = ErrorResolutionType;
export type IntervalTypeTypes = IntervalType;
export type SAPObjectNodeTypeTypeTypes = SAPObjectNodeTypeType;
export type ValueListTypeTypes = ValueListType;
export type ValueListMappingTypeTypes = ValueListMappingType;
export type ValueListParameterTypes = ValueListParameterInTypes | ValueListParameterConstantTypes | ValueListParameterConstantsTypes | ValueListParameterInOutTypes | ValueListParameterOutTypes | ValueListParameterDisplayOnlyTypes | ValueListParameterFilterOnlyTypes;
export type ValueListParameterInTypes = ValueListParameterIn;
export type ValueListParameterConstantTypes = ValueListParameterConstant;
export type ValueListParameterConstantsTypes = ValueListParameterConstants;
export type ValueListParameterInOutTypes = ValueListParameterInOut;
export type ValueListParameterOutTypes = ValueListParameterOut;
export type ValueListParameterDisplayOnlyTypes = ValueListParameterDisplayOnly;
export type ValueListParameterFilterOnlyTypes = ValueListParameterFilterOnly;
export type DraftRootTypeTypes = DraftRootType;
export type DraftNodeTypeTypes = DraftNodeType | DraftRootTypeTypes;
export type SideEffectsTypeTypes = SideEffectsType;
export type SortOrderTypeTypes = SortOrderType;
export type RecursiveHierarchyTypeTypes = RecursiveHierarchyType;
