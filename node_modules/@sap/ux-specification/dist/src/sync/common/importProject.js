"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importProjectSchemaAndConfig = exports.importProjectSchema = exports.getEntityTypeEntitySetFromContextPath = exports.getEntitySetByEntitySetName = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const generate_1 = require("../v2/generate");
const appProvider_1 = require("../v2/import/app/appProvider");
const ovpProvider_1 = require("../v2/import/app/ovpProvider");
const generate_2 = require("../v4/generate");
const utils_1 = require("../v4/utils/utils");
const app_1 = require("../v4/import/app");
const utils_2 = require("./utils");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../extensionLogger");
const i18n_1 = require("../../i18n/i18n");
const schemaAccess_1 = require("../../specification/schemaAccess");
const distTagEvaluator_1 = require("./distTagEvaluator");
/**
 * Generates an object comprising all generic schemas
 * @param {TemplateType} templateType - Template type
 * @param {FioriElementsVersion} fioriElementsVersion - Fiori Elements version
 * @returns {Object} genericSchemas
 */
async function getGenericSchemas(templateType, fioriElementsVersion) {
    const genericSchemas = {};
    let schemaTypes = [];
    schemaTypes = [ux_specification_types_1.SchemaType.Application];
    switch (templateType) {
        case ux_specification_types_1.TemplateType.ListReportObjectPageV4:
        case ux_specification_types_1.TemplateType.AnalyticalListPageV4:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage, ux_specification_types_1.SchemaType.FPMCustomPage);
            break;
        case ux_specification_types_1.TemplateType.FreestylePageV4:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage, ux_specification_types_1.SchemaType.FreestylePage, ux_specification_types_1.SchemaType.FPMCustomPage);
            break;
        case ux_specification_types_1.TemplateType.ListReportObjectPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        case ux_specification_types_1.TemplateType.AnalyticalListPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.AnalyticalListPage, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        case ux_specification_types_1.TemplateType.OverviewPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.OverviewPage);
            break;
        default:
            break;
    }
    for (const schemaType of schemaTypes) {
        const schemaFile = (0, utils_2.getSchemaFilePath)(schemaType);
        genericSchemas[schemaFile.filename] = await (0, schemaAccess_1.getGenericSchema)(fioriElementsVersion, schemaType);
    }
    return genericSchemas;
}
/**
 * Get the relevant UI.ListItem and UI.Facet entity sets
 * @param {ConvertedMetadata} oDataServiceAVT - Annotations as converted by AVT
 * @returns a fitered list of facet and line item annotations
 */
function getAnnotationsForUi(oDataServiceAVT) {
    const filteredEntityTypes = {
        Facets: [],
        LineItems: []
    };
    const allEntityTypes = oDataServiceAVT?.entityTypes;
    if (!allEntityTypes) {
        return filteredEntityTypes;
    }
    const alias = (0, utils_2.findAlias)(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    for (const entity of allEntityTypes) {
        if (!entity.annotations || !entity.annotations[alias]) {
            continue;
        }
        const { LineItem, Facets } = entity.annotations[alias];
        if (LineItem && !LineItem.qualifier) {
            filteredEntityTypes.LineItems.push(entity.name);
        }
        if (Facets && !Facets.qualifier) {
            filteredEntityTypes.Facets.push(entity.name);
        }
    }
    return filteredEntityTypes;
}
function getEntitySetByEntitySetName(entitySetName, oDataServiceAVT) {
    return oDataServiceAVT?.entitySets && oDataServiceAVT.entitySets.find((es) => es.name === entitySetName);
}
exports.getEntitySetByEntitySetName = getEntitySetByEntitySetName;
/**
 * Determines the target entitySet and entityType of a contextPath that uses at least one NavigationProperty
 * @param {ResolutionTarget<any>} resolvedContextPath - contextPath, as resolved by AVT
 * @param {ConvertedMetadata} oDataServiceAVT - service AVT
 *
 * @returns { entityType: EntityType; entitySet: EntitySet } - target entityType and entitySet
 */
function resolveNavigationProperty(resolvedContextPath, oDataServiceAVT) {
    const entityType = resolvedContextPath.target.targetType;
    let entitySet = resolvedContextPath.objectPath[1];
    for (let index = 2; index < resolvedContextPath.objectPath.length; index++) {
        const element = resolvedContextPath.objectPath[index];
        if (entitySet && element['_type'] === 'NavigationProperty') {
            //Consider containment relations
            const bindingName = element['containsTarget']
                ? `${element['name']}/${element['partner']}`
                : element['name'];
            const navPropertyBinding = entitySet.navigationPropertyBinding?.[bindingName];
            entitySet = oDataServiceAVT.entitySets.find((set) => set.name === navPropertyBinding?.name);
        }
    }
    return { entityType, entitySet };
}
/**
 * The function returns an EntityType, EntitySet based on the given contextPath or entitySet
 * @param {ConvertedMetadata} oDataServiceAVT service AVT
 * @param {string} contextPath contextPath of a page
 * @param {string} entitySetName entitySet of a page
 * @param {ExtensionLogger} [logger] - Logger class for logging messages
 *
 * @returns {EntityType} entityType of a page
 */
function getEntityTypeEntitySetFromContextPath(oDataServiceAVT, contextPath, entitySetName, logger) {
    const resolvedContextPath = oDataServiceAVT?.resolvePath(contextPath || `/${entitySetName}`);
    let entityType, entitySet;
    if (resolvedContextPath?.target?._type === 'EntitySet') {
        entityType = resolvedContextPath.target?.entityType;
        entitySet = resolvedContextPath?.target;
    }
    else if (resolvedContextPath?.target?._type === 'NavigationProperty') {
        ({ entityType, entitySet } = resolveNavigationProperty(resolvedContextPath, oDataServiceAVT));
    }
    else {
        (0, extensionLogger_1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('CONTEXTPATHCOULDNOTBERESOLVED', { entitySet: entitySetName, contextPath }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH
            }
        });
    }
    if (entitySetName && !entityType) {
        (0, extensionLogger_1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOENTITYTYPE4SET', { entitySetName: entitySetName })
        });
    }
    return { entityType, entitySet };
}
exports.getEntityTypeEntitySetFromContextPath = getEntityTypeEntitySetFromContextPath;
/**
 * The function generates one app schema per entitySet that is linked with an object page in V2
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schema} genericSchemas - The generic schemas
 * @param {Schema} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas) {
    const allPages = (0, appProvider_1.getPages)(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_OBJECT_PAGE, generateParameters.logger);
    for (const page in allPages) {
        const entitySetName = allPages[page].entitySet;
        const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
        if (!entitySet) {
            (0, extensionLogger_1.log)(generateParameters.logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('ENTITYSETNOTFOUND', { entitySetName: entitySetName })
            });
        }
        generateParameters.entitySet = entitySet;
        const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ObjectPage, entitySet?.name || entitySetName);
        const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = (0, generate_1.generateObjectPageSchemaV2)(generateParameters, genericSchemas[genericSchemaFile.filename]);
    }
}
/**
 * The function generates one app schema per entitySet that is linked with a list report/alp page in V4
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateListReportSchemasV4(generateParameters, genericSchemas, appSchemas) {
    const lrPages = (0, app_1.getPages)(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_LIST_REPORT);
    const alpPages = (0, app_1.getPages)(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_ALP);
    const pages = { ...lrPages, ...alpPages };
    const serviceAVT = generateParameters?.serviceAVT;
    for (const pageId in pages) {
        const entitySetName = pages[pageId].options.settings?.entitySet;
        const contextPath = pages[pageId].options.settings?.contextPath;
        const { entitySet, entityType } = getEntityTypeEntitySetFromContextPath(serviceAVT, contextPath, entitySetName, generateParameters.logger);
        generateParameters.entityType = entityType;
        generateParameters.entitySet = entitySet;
        const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ListReport, pageId);
        const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ListReport);
        // Get ALP/LR template type for existing LR page in freestyle app
        if (generateParameters.templateType === ux_specification_types_1.TemplateType.FreestylePageV4) {
            generateParameters.templateType = (0, utils_2.determineV4PageTemplateType)(pages[pageId]);
        }
        appSchemas[schemaFile.filename] = (0, generate_2.generateListReportSchemaV4)(generateParameters, genericSchemas[genericSchemaFile.filename], pages[pageId].name, contextPath);
    }
}
/**
 * Looks for List Report(s) in a V2 manifest and triggers the schema generation
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateAppSchemaV2LR(generateParameters, appSchemas, genericSchemas) {
    const allPages = (0, appProvider_1.getPages)(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_LIST_REPORT, generateParameters.logger);
    for (const page in allPages) {
        //Should only be one entry
        const entitySetName = allPages[page].entitySet;
        generateParameters.entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
        const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ListReport, generateParameters.entitySet?.name || entitySetName);
        const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ListReport);
        appSchemas[schemaFile.filename] = (0, generate_1.generateListReportSchemaV2)(generateParameters, genericSchemas[genericSchemaFile.filename]);
    }
}
/**
 * The function generates one app schema per entitySet that is linked with an object page in V4
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas) {
    const pages = (0, app_1.getPages)(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_OBJECT_PAGE);
    const serviceAVT = generateParameters.serviceAVT;
    for (const page in pages) {
        const entitySetName = pages[page].options.settings?.entitySet;
        const contextPath = pages[page].options.settings?.contextPath;
        const { entityType, entitySet } = getEntityTypeEntitySetFromContextPath(serviceAVT, contextPath, entitySetName);
        generateParameters.entitySet = entitySet;
        generateParameters.entityType = entityType;
        const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ObjectPage, page);
        const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.ObjectPage);
        const genericMacroSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.FPMCustomPage);
        appSchemas[schemaFile.filename] = (0, generate_2.generateObjectPageSchemaV4)(generateParameters, genericSchemas[genericSchemaFile.filename], contextPath, genericSchemas[genericMacroSchemaFile.filename]);
    }
}
/**
 * Generates all app specific schemas for a Fiori Elements V2 application
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType) {
    const appSchemas = {};
    if (templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV2 && uiEntityTypes) {
        /*--- List Report ----*/
        generateAppSchemaV2LR(generateParameters, appSchemas, genericSchemas);
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV2 && uiEntityTypes) {
        /*--- Analytical List Page ----*/
        const allPages = (0, appProvider_1.getPages)(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_ALP, generateParameters.logger);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            generateParameters.entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
            const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.AnalyticalListPage, generateParameters.entitySet?.name || entitySetName);
            const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.AnalyticalListPage);
            appSchemas[schemaFile.filename] = (0, generate_1.generateAnalyticalListReportSchemaV2)(generateParameters, genericSchemas[genericSchemaFile.filename]);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === ux_specification_types_1.TemplateType.OverviewPageV2) {
        /*--- Overview Page ----*/
        const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.OverviewPage);
        const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.OverviewPage);
        appSchemas[schemaFile.filename] = (0, generate_1.generateOVPInterfaceV2)(genericSchemas[genericSchemaFile.filename], generateParameters.manifest);
    }
    return { ...genericSchemas, ...appSchemas };
}
/**
 * The function generates one app schema per custom page in V4.
 * @param {GenerateAppSchemaParameters} generateParameters List of API input parameters.
 * @param {Schemas} genericSchemas The generic schemas.
 * @param {Schemas} appSchemas The list of app schemas that shall get extended.
 */
function generateCustomPageSchemasV4(generateParameters, genericSchemas, appSchemas) {
    if (!(0, utils_2.isFeatureSupported)(generateParameters.featureToggles, ux_specification_types_1.Features.BuildingBlocks)) {
        return;
    }
    const pages = (0, app_1.getPages)(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE);
    for (const pageId in pages) {
        const page = pages[pageId];
        // Resolve view name and app id
        const viewData = (0, utils_1.getPageCustomViewFile)(generateParameters.views || [], pageId, generateParameters.manifest, generateParameters.logger);
        const viewId = page['viewId'] || page['id'] || pageId;
        if (viewData) {
            const schemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.FPMCustomPage, undefined, viewId);
            const genericSchemaFile = (0, utils_2.getSchemaFilePath)(ux_specification_types_1.SchemaType.FPMCustomPage);
            appSchemas[schemaFile.filename] = (0, generate_2.generateMacrosSchemaDefinition)(genericSchemas[genericSchemaFile.filename], viewData, generateParameters.serviceAVT, generateParameters.logger);
        }
    }
}
/**
 * Generates all app specific schemas for a Fiori Elements V4 application
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes) {
    const appSchemas = {};
    if (uiEntityTypes) {
        generateListReportSchemasV4(generateParameters, genericSchemas, appSchemas);
        generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas);
        generateCustomPageSchemasV4(generateParameters, genericSchemas, appSchemas);
    }
    return { ...genericSchemas, ...appSchemas };
}
/**
 * Generates app specific schemas by adding annotation information to copies of the generic schemas, thus replacing all generic definitions.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types from the service metadata
 * @param templateType - type of the Fiori Elements' template
 */
async function generateAppSchemas(generateParameters, uiEntityTypes, templateType) {
    const genericSchemas = await getGenericSchemas(templateType, generateParameters.fioriElementsVersion);
    if (generateParameters.fioriElementsVersion === ux_specification_types_1.FioriElementsVersion.v4) {
        return generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes);
    }
    else {
        return generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType);
    }
}
/**
 * Imports manifest and flex changes into configuration files with aid of the relevant app provider
 * @param {ImportAllConfigsParameters} importParameters - structure comprising all input parameters
 *
 * @returns {File[]} a list of all configuration files as generated by the function
 */
function importConfigs(importParameters) {
    let provider;
    const files = [];
    switch (importParameters.templateType) {
        case ux_specification_types_1.TemplateType.ListReportObjectPageV2:
        case ux_specification_types_1.TemplateType.AnalyticalListPageV2:
            provider = new appProvider_1.V2AppProvider(importParameters);
            break;
        case ux_specification_types_1.TemplateType.AnalyticalListPageV4:
        case ux_specification_types_1.TemplateType.ListReportObjectPageV4:
        case ux_specification_types_1.TemplateType.FreestylePageV4:
            provider = new app_1.V4AppProvider(importParameters);
            break;
        case ux_specification_types_1.TemplateType.OverviewPageV2:
            provider = new ovpProvider_1.V2OvpProvider(importParameters);
            break;
        default:
            break;
    }
    if (provider) {
        const { appConfig, pageConfigs } = provider.createConfigFiles();
        for (const app in appConfig) {
            files.push({ dataSourceUri: app, fileContent: JSON.stringify(appConfig[app], null, 4) });
        }
        for (const config in pageConfigs) {
            files.push({ dataSourceUri: config, fileContent: JSON.stringify(pageConfigs[config], null, 4) });
        }
    }
    return files;
}
function getFileList(appSchemas, configs) {
    let files = [];
    for (const schemaName of Object.keys(appSchemas).sort()) {
        let dataSourceUri;
        if (schemaName === ux_specification_types_1.SchemaType.Application) {
            dataSourceUri = `${ux_specification_types_1.DirName.Schemas}/${ux_specification_types_1.FileName.App[0].toUpperCase()}${ux_specification_types_1.FileName.App.slice(1)}`;
        }
        else {
            dataSourceUri = `${ux_specification_types_1.DirName.Schemas}/${schemaName}.json`;
        }
        files.push({ dataSourceUri, fileContent: JSON.stringify(appSchemas[schemaName], null, 4) });
    }
    if (configs) {
        files = files.concat(configs);
    }
    return files;
}
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchema(importProjectParameters) {
    // Initialize i18next
    (0, i18n_1.initI18n)();
    const { manifest, annotations, logger, fragments, views, featureToggles } = importProjectParameters;
    const versionChecker = new distTagEvaluator_1.DistTagEvaluator();
    versionChecker.doesUi5VersionFitDistTags(manifest['sap.ui5']?.dependencies?.minUI5Version, logger);
    const fioriElementsVersion = (0, utils_2.getVersionFromManifest)(manifest);
    const oDataServiceAVT = (0, utils_2.parseAndMergeAndConvert)(annotations, logger);
    const uiEntityTypes = getAnnotationsForUi(oDataServiceAVT);
    const templateType = (0, utils_2.getTemplateTypeFromManifest)(manifest, fioriElementsVersion, logger);
    const generateParameters = {
        templateType,
        manifest,
        serviceAVT: oDataServiceAVT,
        fragments,
        views,
        fioriElementsVersion,
        logger,
        featureToggles
    };
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    return getFileList(appSchemas);
}
exports.importProjectSchema = importProjectSchema;
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchemaAndConfig(importProjectParameters) {
    // Initialize i18next
    (0, i18n_1.initI18n)();
    const { manifest, annotations, logger, fragments, views, flex, featureToggles } = importProjectParameters;
    const versionChecker = new distTagEvaluator_1.DistTagEvaluator();
    versionChecker.doesUi5VersionFitDistTags(manifest['sap.ui5']?.dependencies?.minUI5Version, logger);
    const fioriElementsVersion = (0, utils_2.getVersionFromManifest)(manifest);
    const oDataServiceAVT = (0, utils_2.parseAndMergeAndConvert)(annotations, logger);
    const templateType = (0, utils_2.getTemplateTypeFromManifest)(manifest, fioriElementsVersion, logger);
    //Generate Schemas
    const generateParameters = {
        templateType,
        manifest,
        serviceAVT: oDataServiceAVT,
        fragments,
        views,
        fioriElementsVersion,
        logger,
        featureToggles
    };
    const uiEntityTypes = getAnnotationsForUi(oDataServiceAVT);
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    //Import to configs
    const importConfigsParameters = {
        manifest,
        flexChanges: flex,
        appSchemas,
        templateType,
        logger,
        serviceAVT: oDataServiceAVT,
        fragments,
        views
    };
    const configFiles = importConfigs(importConfigsParameters);
    return getFileList(appSchemas, configFiles);
}
exports.importProjectSchemaAndConfig = importProjectSchemaAndConfig;
//# sourceMappingURL=importProject.js.map