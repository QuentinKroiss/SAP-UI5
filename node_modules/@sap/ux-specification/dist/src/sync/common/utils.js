"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceNamespaces = exports.removeNamespaces = exports.getJSONPropertyByPath = exports.updatePropertyIndices = exports.isFeatureSupported = exports.getErrorMessage = exports.getDefinitionsRef = exports.getDefinitionKey = exports.convertActionKeyToStableId = exports.convertEnumToCSV = exports.arrayCombineMerge = exports.getNextTargetDefinition = exports.findMatchingKeysByAdditionalProperties = exports.generatePageId = exports.getSchemaFilePath = exports.deleteEmptyStructure = exports.getObjectPageFacetSection = exports.createDefaultSection = exports.addTargetTitleAndSectionDescription = exports.addSectionTitleAndDescription = exports.getTemplateTypeFromManifest = exports.determineV4Template = exports.determineV4PageTemplateType = exports.determineV2Template = exports.getVersionFromManifest = exports.getObjectPageFacets = exports.getObjectPageHeaderFacets = exports.getAnnotationPathUsingFullyQualifiedName = exports.getSchemaKeyOfLineItemRecord = exports.setManifestSectionByPathV4 = exports.getManifestSectionByPathV4 = exports.prepareValueForPath = exports.getSectionFacet = exports.getAnnotationFromMetaPath = exports.findAlias = exports.getPageTypeV4 = exports.getPageTypeV2 = exports.prepareRef = exports.getDataFieldDescription = exports.getLabelForDataField = exports.getLabelForPropertyPath = exports.evaluateCommonLabel = exports.getAnnotationPropertyValue = exports.parseAndMergeAndConvert = exports.createAnnotationPath = exports.arrayIncludes = exports.DEFINITION_LINK_PREFIX = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const i18next_1 = __importDefault(require("i18next"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const extensionLogger_1 = require("../../extensionLogger");
exports.DEFINITION_LINK_PREFIX = '#/definitions/';
const arrayIncludes = (arr, target) => target.every((v) => arr.includes(v));
exports.arrayIncludes = arrayIncludes;
/**
 * Function returns annotation path for schema based on received params.
 * @param entityTypeName - Entity type name.
 * @param term - Annotation term.
 * @param qualifier - Annotation qualifier.
 * @returns Annotation path based on received params
 */
const createAnnotationPath = (entityTypeName, term, qualifier) => {
    if (!entityTypeName) {
        return undefined;
    }
    let annotationPath = `/${entityTypeName}/@${term}`;
    if (qualifier) {
        annotationPath += `#${qualifier}`;
    }
    return annotationPath;
};
exports.createAnnotationPath = createAnnotationPath;
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles - The list of all annotation files, in JSON format
 * @returns the complete service information
 */
function parseAndMergeAndConvert(annotationFiles, logger) {
    const parseResult = [];
    let converterOutput;
    if (annotationFiles) {
        annotationFiles.forEach(function (annotationData) {
            try {
                parseResult.push((0, edmx_parser_1.parse)(annotationData.fileContent, annotationData.dataSourceUri));
            }
            catch (error) {
                (0, extensionLogger_1.log)(logger, {
                    severity: "error" /* LogSeverity.Error */,
                    message: i18next_1.default.t('ANNOERR'),
                    location: { path: i18next_1.default.t('ANNOTATIONFILE', { file: annotationData.dataSourceUri }) }
                }, error);
                return converterOutput;
            }
        });
    }
    if (parseResult.length > 0) {
        converterOutput = (0, annotation_converter_1.convert)((0, edmx_parser_1.merge)(...parseResult));
    }
    return converterOutput;
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
const getAnnotationPropertyValue = (annotationProperty) => annotationProperty?.value || annotationProperty?.path;
exports.getAnnotationPropertyValue = getAnnotationPropertyValue;
/**
 * Checks for Common.Label and overwrites the label from it if present
 * @param {PropertyAnnotations} annotations - property annotations
 * @param {EntityType} entityType - entity type
 * @param {string} label - label, to be actualized
 */
function evaluateCommonLabel(annotations, entityType, label) {
    if (annotations?.Common?.Label) {
        if (typeof annotations.Common.Label === 'string') {
            label = annotations.Common.Label;
        }
        else if (annotations.Common.Label['type'] === 'Path') {
            const targetProperty = entityType && entityType.resolvePath(annotations.Common.Label['path']);
            if (targetProperty?.value) {
                label = targetProperty.value;
            }
            else if (typeof targetProperty?.Common?.Label === 'string') {
                label = targetProperty.annotations.Common.Label;
            }
        }
        else if (typeof annotations.Common?.Label?.toString() === 'string') {
            label = annotations.Common.Label.toString();
        }
    }
    return label;
}
exports.evaluateCommonLabel = evaluateCommonLabel;
/**
 * Determines the label for a property path
 * @param {PropertyPath} propertyPath - property path
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
function getLabelForPropertyPath(propertyPath, entityType) {
    let label = propertyPath.value;
    if (propertyPath.$target) {
        label = evaluateCommonLabel(propertyPath.$target.annotations, entityType, label);
    }
    return label;
}
exports.getLabelForPropertyPath = getLabelForPropertyPath;
/**
 * Determines the label for a LineItem record
 * @param {DataFieldAbstractType} field - Line item record
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
function getLabelForDataField(field, entityType) {
    let label, property;
    if (field['Value']) {
        if (typeof field['Value'] === 'string') {
            property = entityType && entityType.entityProperties.find((ep) => ep.name === field['Value']);
        }
        else {
            property = entityType && entityType.resolvePath(field['Value'].path);
            if (!property) {
                property = field['Value'].$target;
            }
        }
    }
    else if (field['Target'] && field['Target'].$target) {
        if (field['Target'].$target.Value) {
            property = field['Target'].$target.Value.$target;
        }
        else if (field['Target'].$target.Label) {
            label = field['Target'].$target.Label;
        }
    }
    if (property?.annotations?.Common?.Label) {
        label = evaluateCommonLabel(property.annotations, entityType, label);
    }
    return label;
}
exports.getLabelForDataField = getLabelForDataField;
/**
 * Function to resolve the dataField label
 * @param dataFieldLabel - Given dataField label; might be of type string, or an object in case of a path reference
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 * @returns undefined or the right string value
 */
function getLabel(dataFieldLabel, entityType) {
    if (typeof dataFieldLabel === 'string') {
        return dataFieldLabel;
    }
    else if (typeof dataFieldLabel === 'object' && dataFieldLabel.path) {
        const property = entityType && entityType.resolvePath(dataFieldLabel.path);
        if (!property || property.length === 0) {
            return undefined;
        }
        else {
            const singleProperty = property[0];
            if (singleProperty?.annotations?.Common?.Label) {
                const label = dataFieldLabel;
                return evaluateCommonLabel(singleProperty.annotations, entityType, label);
            }
        }
    }
    else {
        return undefined;
    }
}
function getTitleForDataField(dataField, entityType, dataFieldLabel) {
    const propertyCommonLabel = getLabelForDataField(dataField, entityType);
    return (dataFieldLabel ||
        propertyCommonLabel ||
        (dataField.Value.$target ? dataField.Value.$target.name : dataField.Value.value || dataField.Value.path));
}
/**
 * Determines the description of a data field, e.g. for the column header
 * @param dataFieldAbstract - the given record of the line item annotation
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 */
function getDataFieldDescription(dataFieldAbstract, entityType) {
    let title = '', propertyCommonLabel, dataField, actionName = '';
    try {
        const dataFieldLabel = getLabel(dataFieldAbstract.Label, entityType);
        switch (dataFieldAbstract.$Type) {
            case "com.sap.vocabularies.UI.v1.DataField" /* UIAnnotationTypes.DataField */:
                title = getTitleForDataField(dataFieldAbstract, entityType, dataFieldLabel);
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* UIAnnotationTypes.DataFieldWithUrl */:
                propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
                title =
                    dataFieldLabel ||
                        propertyCommonLabel ||
                        (typeof dataFieldAbstract.Value === 'string'
                            ? dataFieldAbstract.Value
                            : dataFieldAbstract.Value.path);
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* UIAnnotationTypes.DataFieldForAnnotation */:
                dataField = dataFieldAbstract;
                propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
                title =
                    dataFieldLabel ||
                        propertyCommonLabel ||
                        dataField.Target?.$target?.Title ||
                        dataField.Target?.value.split('UI.v1.')[1];
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */:
            case "com.sap.vocabularies.UI.v1.DataFieldWithAction" /* UIAnnotationTypes.DataFieldWithAction */:
            case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* UIAnnotationTypes.DataFieldForIntentBasedNavigation */:
                dataField = dataFieldAbstract;
                actionName = typeof dataFieldAbstract.Action === 'string' ? dataField.Action : dataField.Action?.path;
                if (dataFieldLabel) {
                    title = typeof dataFieldLabel === 'string' ? dataFieldLabel : actionName;
                }
                else {
                    title = actionName;
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* UIAnnotationTypes.DataFieldWithIntentBasedNavigation */:
                propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
                title = propertyCommonLabel || dataFieldAbstract.Value.path;
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* UIAnnotationTypes.DataFieldWithNavigationPath */:
                dataField = dataFieldAbstract;
                title = getTitleForDataField(dataField, entityType, dataFieldLabel);
                break;
            default:
                break;
        }
        return title;
    }
    catch (error) {
        return title;
    }
}
exports.getDataFieldDescription = getDataFieldDescription;
/**
 * Prepare string for reference use in schema
 * @param refInput string to be character checked and replaced
 * @returns string with replaced characters
 */
function prepareRef(refInput) {
    return refInput.replace('#', '::').replace(/\//g, ':2f');
}
exports.prepareRef = prepareRef;
/**
 * Return the page type for a given V2 page in manifest
 * @param name - page component name
 */
function getPageTypeV2(name) {
    if (name) {
        const templatePart = `${ux_specification_types_1.v2.FE_TEMPLATE_V2}.`;
        return name.split(templatePart)[1];
    }
}
exports.getPageTypeV2 = getPageTypeV2;
/**
 * Return the page type for a given V4 page in manifest
 * @param name - page component name
 */
function getPageTypeV4(v4App) {
    if (v4App.name && v4App.name !== ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE) {
        const templatePart = `${ux_specification_types_1.v4.FE_TEMPLATE_V4}.`;
        return v4App.name.split(templatePart)[1];
    }
    else if (v4App?.name === ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE) {
        return ux_specification_types_1.PageTypeV4.FPMCustomPage;
    }
    else if (v4App.viewId ||
        v4App.viewName) {
        return ux_specification_types_1.PageTypeV4.CustomPage;
    }
}
exports.getPageTypeV4 = getPageTypeV4;
function getTargetAnnotationName(targetAnnotation, keyForRelatedFacetKeys = false) {
    const termWithQualifier = `${targetAnnotation.term}#${targetAnnotation.qualifier}`;
    return `${!keyForRelatedFacetKeys ? '@' : ''}${targetAnnotation.qualifier ? termWithQualifier : targetAnnotation.term}`;
}
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {string} namespace - complete namespace, e.g. 'com.sap.vocabularies.UI.v1'
 * @param {ConvertedMetadata} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @returns alias for the given namespace
 */
function findAlias(namespace, oDataServiceAVT) {
    if (!oDataServiceAVT) {
        return;
    }
    let aliasReference = oDataServiceAVT.references.find((reference) => {
        return reference.namespace === namespace;
    });
    if (!aliasReference) {
        aliasReference = oDataServiceAVT.references.find((reference) => {
            return reference.alias === namespace;
        });
    }
    if (!aliasReference) {
        aliasReference = oDataServiceAVT.references.find((reference) => {
            return (reference.alias.toUpperCase() ===
                namespace.split('SAP__')[namespace.split('SAP__').length - 1].toUpperCase());
        });
    }
    return aliasReference?.alias;
}
exports.findAlias = findAlias;
/**
 * Method returns annotation from passed meta path.
 * @param metaPath - annotation meta path
 * @returns annotation name
 */
function getAnnotationFromMetaPath(metaPath) {
    return metaPath.substring(metaPath.lastIndexOf('.') + 1, metaPath.length);
}
exports.getAnnotationFromMetaPath = getAnnotationFromMetaPath;
/**
 * Determines the target annotation
 * @param navigationParts - parts of the target annotation path
 * @param entityType - entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @returns the target annotation
 */
function determineTargetAnnotation(navigationParts, entityType, oDataServiceAVT) {
    const lastNavigationPart = navigationParts[navigationParts.length - 1];
    const annotation = getAnnotationFromMetaPath(lastNavigationPart);
    const alias = findAlias(lastNavigationPart.substring(0, lastNavigationPart.lastIndexOf('.')).replace('@', ''), oDataServiceAVT);
    return entityType?.annotations?.[alias]?.[annotation];
}
/**
 * Adjust key by considering navigation
 * @param key - given key
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @param navigationParts - parts of the target annotation path
 */
function adjustKey(key, navigationParts, keyForRelatedFacetKeys) {
    const uiClass = navigationParts[navigationParts.length - 1].split('#')[0];
    if (uiClass.includes('.LineItem')) {
        const pathParts = key.split('::');
        pathParts[pathParts.length - 1] = `${!keyForRelatedFacetKeys ? '@' : ''}${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
        key = pathParts.join('::');
    }
    else {
        key = uiClass.replace('@UI', `${!keyForRelatedFacetKeys ? '@' : ''}${ux_specification_types_1.UIVOCABULARY}`);
    }
    return key;
}
function getKeyAndEntityTypeOfReferenceFacet(oDataServiceAVT, key, entityType, propertyValue, oDataVersion = ux_specification_types_1.FioriElementsVersion.v2, keyForRelatedFacetKeys = false) {
    let stopProcessing = false;
    let namespace;
    const navigationParts = propertyValue.split('/');
    const navigation = navigationParts.length > 1;
    if (navigation && entityType) {
        entityType = entityType.resolvePath(propertyValue.substring(0, propertyValue.lastIndexOf('/')))?.targetType;
    }
    key = adjustKey(key, navigationParts, keyForRelatedFacetKeys);
    const targetAnnotation = determineTargetAnnotation(navigationParts, entityType, oDataServiceAVT);
    if (targetAnnotation) {
        const separator = oDataVersion === ux_specification_types_1.FioriElementsVersion.v2 ? '::' : '#';
        key = getTargetAnnotationName(targetAnnotation, keyForRelatedFacetKeys).replace('#', separator);
        namespace = targetAnnotation.fullyQualifiedName?.split('@')[0];
    }
    else {
        stopProcessing = true;
        return { key, entityType, stopProcessing, namespace };
    }
    if (navigation) {
        const navSeparator = oDataVersion === ux_specification_types_1.FioriElementsVersion.v2 ? '::' : '/';
        navigationParts.pop();
        const navigationIDs = [...navigationParts].join(navSeparator);
        key = `${navigationIDs}${navSeparator}${key}`;
    }
    return { key, entityType, stopProcessing, namespace };
}
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {FacetSection} - object comprising the relevant facet information
 */
function getSectionFacet(facetDefinition, sourceEntityType, oDataServiceAVT, logger, oDataVersion = ux_specification_types_1.FioriElementsVersion.v2, keyForRelatedFacetKeys = false) {
    //Take facet ID as fallback
    const facetName = facetDefinition.fullyQualifiedName?.substring(facetDefinition.fullyQualifiedName?.lastIndexOf('@'));
    let key = facetDefinition.ID ? facetDefinition.ID.toString() : facetName;
    let namespace = facetDefinition.fullyQualifiedName?.split('@')[0];
    let entityType = sourceEntityType; //default
    //If reference facet: overwrite with target annotation if present
    if (facetDefinition.$Type !== "com.sap.vocabularies.UI.v1.CollectionFacet" /* UIAnnotationTypes.CollectionFacet */ && 'Target' in facetDefinition) {
        const propertyValue = (0, exports.getAnnotationPropertyValue)(facetDefinition.Target);
        if (!propertyValue) {
            (0, extensionLogger_1.log)(logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOTARGET', { target: facetDefinition.Target })
            });
            return;
        }
        const { key: newKey, entityType: newEntityType, stopProcessing, namespace: sectionNameSpace } = getKeyAndEntityTypeOfReferenceFacet(oDataServiceAVT, key, entityType, propertyValue, oDataVersion, keyForRelatedFacetKeys);
        if (stopProcessing) {
            return;
        }
        key = newKey;
        entityType = newEntityType;
        namespace = sectionNameSpace;
    }
    key = key.replace(/\//gi, '::');
    if (key) {
        return {
            key,
            ...(facetDefinition.Label && { label: facetDefinition.Label.toString() }),
            ...(facetDefinition.ID && { ID: facetDefinition.ID.toString() }),
            entityType,
            namespace
        };
    }
    else {
        return undefined;
    }
}
exports.getSectionFacet = getSectionFacet;
/**
 * Decodes encoded path element and returns it in form as used in manifest settings
 * @param {string} pathElement - path of the property in the manifest
 * @param {string} targetAnnotation - target annotation (optional)
 * @param {string} targetAnnotationEncoded - target annotation in its encoded form, as used in manifest settings (optional)
 * @returns returns decoded element (manifest setting key)
 */
function getDecodedPathElement(pathElement, targetAnnotation, targetAnnotationEncoded) {
    let decodedElement;
    if (targetAnnotationEncoded && targetAnnotationEncoded === pathElement) {
        decodedElement = targetAnnotation;
    }
    else {
        decodedElement = pathElement.replace(/\?\?/g, '/');
    }
    return decodedElement;
}
/**
 * Method prepares value as empty object or array based on passed path.
 * For array path should end with '[]'.
 * @param {string} path - path of the property in the manifest
 * @returns prepared value based on passed path
 */
const prepareValueForPath = (path) => {
    if (path?.endsWith('[]')) {
        return [];
    }
    return {};
};
exports.prepareValueForPath = prepareValueForPath;
/**
 * Method find object by given path in format "sap.ui5/extends/extensions".
 * An empty object is created if the path element does not exist yet.
 * Exception: if an empty array is the next element  of the 'path' definition, an empty array is created instead of an empty object.
 * @param {object} manifest - manifest that is being modified during export
 * @param {string} path - path of the property in the manifest
 * @param {string} targetAnnotation - target annotation (optional)
 * @param {string} targetAnnotationEncoded - target annotation in its encoded form, as used in manifest settings
 * @param {boolean} value - specific value to apply for unexisting property for given path
 * @param {boolean} [readOnly=false] - indicates if the function should create object/array if existing value not found by given path
 * @returns returns section of the manifest based on path
 */
const resolveManifestPath = (manifest, path, targetAnnotation, targetAnnotationEncoded, value, readOnly = false) => {
    if (!path) {
        return undefined;
    }
    let manifestSection = manifest;
    const pathElements = path.split('/');
    for (let index = 0; index < pathElements.length; index++) {
        const element = pathElements[index];
        if (element === '[]') {
            continue;
        }
        const decodedElement = getDecodedPathElement(element, targetAnnotation, targetAnnotationEncoded);
        if (value !== undefined && !readOnly && pathElements.length - 1 === index) {
            // Apply or overwrite if value passed
            manifestSection[decodedElement] = value;
        }
        else if (!manifestSection[decodedElement]) {
            if (readOnly) {
                return undefined;
            }
            manifestSection[decodedElement] = (0, exports.prepareValueForPath)(pathElements[index + 1]);
        }
        manifestSection = manifestSection[decodedElement];
    }
    return manifestSection;
};
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata.
 * An empty object is created if the path element does not exist yet.
 * Exception: if an empty array is the next element  of the 'path' definition, an empty array is created instead of an empty object.
 * @param {object} manifest - manifest that is being modified during export
 * @param {string} path - path of the property in the manifest
 * @param {string} targetAnnotation - target annotation (optional)
 * @param {string} targetAnnotationEncoded - target annotation in its encoded form, as used in manifest settings
 * @param {boolean} [readOnly=false] - indicates if the function should create object/array if existing value not found by given path
 * @returns returns section of the manifest based on path, generates an empty object in case it does not exists
 */
const getManifestSectionByPathV4 = (manifest, path, targetAnnotation, targetAnnotationEncoded, readOnly = false) => {
    return resolveManifestPath(manifest, path, targetAnnotation, targetAnnotationEncoded, undefined, readOnly);
};
exports.getManifestSectionByPathV4 = getManifestSectionByPathV4;
/**
 * Method sets value for passed path in manifest.
 * @param {object} manifest - manifest that is being modified during export
 * @param {string} path - path of the property in the manifest
 * @param {unknown} value - value to apply
 * @param {string} targetAnnotation - target annotation (optional)
 * @param {string} targetAnnotationEncoded - target annotation in its encoded form, as used in manifest settings
 */
const setManifestSectionByPathV4 = (manifest, path, value, targetAnnotation, targetAnnotationEncoded) => {
    resolveManifestPath(manifest, path, targetAnnotation, targetAnnotationEncoded, value);
};
exports.setManifestSectionByPathV4 = setManifestSectionByPathV4;
function getSchemaKeyOfLineItemRecord(lineItemRecord) {
    let schemaKey, target, value;
    switch (lineItemRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* UIAnnotationTypes.DataField */:
            schemaKey = (0, exports.getAnnotationPropertyValue)(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* UIAnnotationTypes.DataFieldWithUrl */:
            schemaKey =
                typeof lineItemRecord.Value === 'string'
                    ? lineItemRecord.Value
                    : (0, exports.getAnnotationPropertyValue)(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* UIAnnotationTypes.DataFieldForAnnotation */:
            target = lineItemRecord.Target.value;
            if (target) {
                schemaKey =
                    'DataFieldForAnnotation:::sTarget::' +
                        target
                            .replace('@UI', `@${ux_specification_types_1.UIVOCABULARY}`)
                            .replace('@Communication', '@com.sap.vocabularies.Communication.v1')
                            .replace('@Contact', '@com.sap.vocabularies.Contact.v1');
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */:
            if (lineItemRecord.Inline) {
                schemaKey = `DataFieldForAction:::sAction::${prepareRef(lineItemRecord.Action)}`;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* UIAnnotationTypes.DataFieldWithIntentBasedNavigation */:
            value = (0, exports.getAnnotationPropertyValue)(lineItemRecord.Value);
            schemaKey = `DataFieldWithIntentBasedNavigation:::sProperty::${value}:::sSemanticObject::${lineItemRecord.SemanticObject}:::sAction::${lineItemRecord.Action}`;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* UIAnnotationTypes.DataFieldForIntentBasedNavigation */:
            if (lineItemRecord.Inline) {
                schemaKey = `DataFieldForIntentBasedNavigation:::sSemanticObject::${lineItemRecord.SemanticObject}:::sAction::${prepareRef(lineItemRecord.Action)}`;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* UIAnnotationTypes.DataFieldWithNavigationPath */:
            value = (0, exports.getAnnotationPropertyValue)(lineItemRecord.Value);
            target = (0, exports.getAnnotationPropertyValue)(lineItemRecord.Target);
            schemaKey = 'DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target;
            break;
        default:
            break;
    }
    return schemaKey;
}
exports.getSchemaKeyOfLineItemRecord = getSchemaKeyOfLineItemRecord;
/**
 * Determines if type of given annotation term is of UIAnnotationTerm
 * @param {string} path path in manifest
 * @param {string} alias for a given namespace
 * @param {EntityType} entityType - the entity type
 * @returns UI annotation term type
 */
function getUIAnnotationTerm(path, alias, entityType) {
    if (path.includes("com.sap.vocabularies.UI.v1.Chart" /* UIAnnotationTerms.Chart */) || path.includes(alias + '.Chart')) {
        return "com.sap.vocabularies.UI.v1.Chart" /* UIAnnotationTerms.Chart */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */) || path.includes(alias + '.Identification')) {
        return "com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */;
    }
    else if ((entityType && path.includes("com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */)) || path.includes(alias + '.LineItem')) {
        return "com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.FieldGroup" /* UIAnnotationTerms.FieldGroup */) || path.includes(alias + '.FieldGroup')) {
        return "com.sap.vocabularies.UI.v1.FieldGroup" /* UIAnnotationTerms.FieldGroup */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.DataPoint" /* UIAnnotationTerms.DataPoint */) || path.includes(alias + '.DataPoint')) {
        return "com.sap.vocabularies.UI.v1.DataPoint" /* UIAnnotationTerms.DataPoint */;
    }
    else if (path.includes("com.sap.vocabularies.UI.v1.PresentationVariant" /* UIAnnotationTerms.PresentationVariant */) || path.includes(alias + '.PresentationVariant')) {
        return "com.sap.vocabularies.UI.v1.PresentationVariant" /* UIAnnotationTerms.PresentationVariant */;
    }
    else {
        return undefined;
    }
}
/**
 * Determines if type of given annotation term is of CommunicationAnnotationTerm
 * @param {string} path path in manifest
 * @param {string} alias for a given namespace
 * @param {EntityType} entityType - the entity type
 * @returns Communication annotation term type
 */
function getCommunicationAnnotationTerm(path, alias) {
    if (path.includes('com.sap.vocabularies.Communication.v1.Contact') || path.includes(alias + '.Contact')) {
        return "com.sap.vocabularies.Communication.v1.Contact" /* CommunicationAnnotationTerms.Contact */;
    }
    else if (path.includes('com.sap.vocabularies.Communication.v1.Address') || path.includes(alias + '.Address')) {
        return "com.sap.vocabularies.Communication.v1.Address" /* CommunicationAnnotationTerms.Address */;
    }
    else {
        return undefined;
    }
}
/**
 * Determines the type of given annotation term
 * @param {string} path path in manifest
 * @param {string} alias for a given namespace
 * @param {EntityType} entityType - the entity type
 * @returns annotation term type
 */
function getAnnotationTerm(path, alias, entityType) {
    return getUIAnnotationTerm(path, alias, entityType) || getCommunicationAnnotationTerm(path, alias);
}
/**
 * Evaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {EntityType} entityType - the entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function evaluateTargetAnnotation(section, annotationRecord, facets, entityType, oDataServiceAVT) {
    const alias = findAlias(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    let path = section ? section.key : '';
    const targetEntityType = section.entityType;
    const annotationTerm = getAnnotationTerm(path, alias, entityType);
    switch (annotationTerm) {
        case "com.sap.vocabularies.UI.v1.Chart" /* UIAnnotationTerms.Chart */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.Chart };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.Identification };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */: {
            if (!path.includes("com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */) && path.includes('.LineItem')) {
                const pathParts = path.split('::');
                pathParts[pathParts.length - 1] = `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
                path = pathParts.join('::');
            }
            facets[path] = { base: ux_specification_types_1.FacetBase.LineItem };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.UI.v1.FieldGroup" /* UIAnnotationTerms.FieldGroup */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.Form };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.UI.v1.DataPoint" /* UIAnnotationTerms.DataPoint */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.DataPoint };
            facets[path].Label = annotationRecord?.Target?.$target['Title'];
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.UI.v1.PresentationVariant" /* UIAnnotationTerms.PresentationVariant */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.PresentationVariant };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.Communication.v1.Contact" /* CommunicationAnnotationTerms.Contact */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.Contact };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        case "com.sap.vocabularies.Communication.v1.Address" /* CommunicationAnnotationTerms.Address */: {
            facets[path] = { base: ux_specification_types_1.FacetBase.Address };
            facets[path].target = annotationRecord?.Target?.$target;
            facets[path].entityType = targetEntityType;
            facets[path].namespace = section.namespace;
            break;
        }
        default: {
            facets[path] = { base: ux_specification_types_1.FacetBase.Unknown };
        }
    }
    if (facets[path]) {
        facets[path].annotationPath = `/${annotationRecord.fullyQualifiedName.replace('@com.sap.vocabularies', ux_specification_types_1.VOCWITHSLASH)}`;
        if (annotationRecord.Label) {
            facets[path].Label = annotationRecord.Label;
        }
        // Add Facet ID
        if (annotationRecord.ID) {
            facets[path]['ID'] = annotationRecord.ID;
        }
        if (section && section.entityType) {
            facets[path].entityType = section.entityType;
        }
    }
}
/**
 * Method returns schema annotation path for passed fullyQualifiedName.
 * @param {EntityType} entityType entity type.
 * @param {string} fullyQualifiedName fully qualifier name.
 * @returns {TemplateType} Schema annotation path.
 */
function getAnnotationPathUsingFullyQualifiedName(entityType, fullyQualifiedName) {
    return `/${entityType.fullyQualifiedName}/${fullyQualifiedName.split(entityType.fullyQualifiedName)[1]}`;
}
exports.getAnnotationPathUsingFullyQualifiedName = getAnnotationPathUsingFullyQualifiedName;
/**
 * Adds the information from facets to the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addFacetToConfig(annotationRecord, oDataServiceAVT, serviceName, entityType, facets, oDataVersion = ux_specification_types_1.FioriElementsVersion.v2, logger) {
    const section = getSectionFacet(annotationRecord, entityType, oDataServiceAVT, logger, oDataVersion, false);
    if (section) {
        switch (annotationRecord.$Type) {
            case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* UIAnnotationTypes.ReferenceFacet */: {
                evaluateTargetAnnotation(section, annotationRecord, facets, entityType, oDataServiceAVT);
                break;
            }
            case "com.sap.vocabularies.UI.v1.CollectionFacet" /* UIAnnotationTypes.CollectionFacet */: {
                const annotationPath = getAnnotationPathUsingFullyQualifiedName(entityType, annotationRecord.fullyQualifiedName);
                const facet = (facets[section.key] = {
                    base: ux_specification_types_1.FacetBase.CollectionFacet,
                    facets: {},
                    ID: section.ID,
                    annotationPath: annotationPath,
                    Label: section.label,
                    namespace: section.namespace
                });
                if (!facet.ID && oDataVersion === ux_specification_types_1.FioriElementsVersion.v4) {
                    (0, extensionLogger_1.log)(logger, {
                        severity: "error" /* LogSeverity.Error */,
                        message: i18next_1.default.t('NOID4SECTION', { facet: annotationRecord.fullyQualifiedName })
                    });
                }
                annotationRecord.Facets?.forEach((collectionItem) => {
                    addFacetToConfig(collectionItem, oDataServiceAVT, serviceName, entityType, facet.facets, oDataVersion, logger);
                });
                break;
            }
        }
    }
}
/**
 * Retrieve header facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function getObjectPageHeaderFacets(entityType, oDataServiceAVT, oDataVersion = ux_specification_types_1.FioriElementsVersion.v2, logger) {
    const facets = {};
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    const facetAnnotation = alias && entityType?.annotations?.[alias]?.HeaderFacets;
    if (facetAnnotation) {
        const lastDot = entityType && entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType && entityType.fullyQualifiedName.substring(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityType, facets, oDataVersion, logger);
        });
    }
    return facets;
}
exports.getObjectPageHeaderFacets = getObjectPageHeaderFacets;
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function getObjectPageFacets(entityType, oDataServiceAVT, oDataVersion = ux_specification_types_1.FioriElementsVersion.v2, logger) {
    const facets = {};
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    const facetAnnotation = alias && entityType?.annotations[alias]?.Facets;
    if (facetAnnotation) {
        const lastDot = entityType && entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType && entityType.fullyQualifiedName.substring(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityType, facets, oDataVersion, logger);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest[ux_specification_types_1.ManifestSection.generic] || manifest[ux_specification_types_1.ManifestSection.ovp]) {
        return ux_specification_types_1.FioriElementsVersion.v2;
    }
    else {
        return ux_specification_types_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
/**
 * Determines the template type of a V2 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function determineV2Template(manifest, logger) {
    let templateType;
    if (manifest[ux_specification_types_1.ManifestSection.generic]) {
        const v2Pages = manifest[ux_specification_types_1.ManifestSection.generic].pages;
        if (!v2Pages) {
            (0, extensionLogger_1.log)(logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
                location: {
                    path: ux_specification_types_1.MANIFESTPATH,
                    range: [ux_specification_types_1.ManifestSection.generic]
                }
            });
            return;
        }
        for (const pageKey in v2Pages) {
            const v2Page = v2Pages[pageKey];
            if (getPageTypeV2(v2Page.component?.name) === ux_specification_types_1.PageTypeV2.AnalyticalListPage) {
                templateType = ux_specification_types_1.TemplateType.AnalyticalListPageV2;
                break;
            }
            else if (getPageTypeV2(v2Page.component?.name) === ux_specification_types_1.PageTypeV2.ListReport) {
                templateType = ux_specification_types_1.TemplateType.ListReportObjectPageV2;
                break;
            }
        }
    }
    else {
        if (!templateType) {
            (0, extensionLogger_1.log)(logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOTEMPLATE', { section: ux_specification_types_1.ManifestSection.generic }),
                location: {
                    path: ux_specification_types_1.MANIFESTPATH,
                    range: [ux_specification_types_1.ManifestSection.generic]
                }
            });
        }
    }
    return templateType;
}
exports.determineV2Template = determineV2Template;
/**
 * Determines the template type of a single page
 * @param v4Page - single page from routing targets
 * @returns {TemplateType | undefined} the template type
 */
function determineV4PageTemplateType(v4Page) {
    let templateType;
    const pageType = getPageTypeV4(v4Page);
    if (pageType === ux_specification_types_1.PageTypeV4.AnalyticalListPage) {
        templateType = ux_specification_types_1.TemplateType.AnalyticalListPageV4;
    }
    else if (pageType === ux_specification_types_1.PageTypeV4.ListReport) {
        const viewPath = v4Page.options?.settings?.views?.paths?.[0];
        if (viewPath && (viewPath[ux_specification_types_1.ALPViewType.Primary] || viewPath[ux_specification_types_1.ALPViewType.Secondary])) {
            templateType = ux_specification_types_1.TemplateType.AnalyticalListPageV4;
        }
        else {
            templateType = ux_specification_types_1.TemplateType.ListReportObjectPageV4;
        }
    }
    else if (pageType === ux_specification_types_1.PageTypeV4.ObjectPage) {
        templateType = ux_specification_types_1.TemplateType.ListReportObjectPageV4;
        //fixed now for FEOP scenario, bit continue to check if LR/ALP exists
    }
    else if ([ux_specification_types_1.PageTypeV4.CustomPage, ux_specification_types_1.PageTypeV4.FPMCustomPage].includes(pageType)) {
        templateType = ux_specification_types_1.TemplateType.FreestylePageV4;
    }
    return templateType;
}
exports.determineV4PageTemplateType = determineV4PageTemplateType;
/**
 * Determines the template type, based on the given manifest routing target entries of the app
 * @param v4Pages - pages from routing targets
 * @returns {TemplateType | undefined} the template type
 */
function determineV4TemplateFromPages(v4Pages) {
    let templateType;
    for (const pageKey in v4Pages) {
        const v4Page = v4Pages[pageKey];
        templateType = determineV4PageTemplateType(v4Page);
        if (templateType) {
            break;
        }
    }
    return templateType;
}
/**
 * Determines the template type of a V4 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function determineV4Template(manifest, logger) {
    const v4Pages = manifest[ux_specification_types_1.ManifestSection.ui5].routing &&
        manifest[ux_specification_types_1.ManifestSection.ui5].routing.targets;
    // if there are no pages in routing targets, we use LROPV4 as default template type
    if (!v4Pages || Object.keys(v4Pages).length === 0) {
        (0, extensionLogger_1.log)(logger, {
            severity: "info" /* LogSeverity.Info */,
            message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.ui5, 'routing']
            }
        });
        return ux_specification_types_1.TemplateType.ListReportObjectPageV4;
    }
    // else try to determine template type from routing targets
    const templateType = determineV4TemplateFromPages(v4Pages);
    if (!templateType) {
        (0, extensionLogger_1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOTEMPLATE', { section: ux_specification_types_1.ManifestSection.ui5 }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.ui5, 'routing', 'targets']
            }
        });
    }
    return templateType;
}
exports.determineV4Template = determineV4Template;
/**
 * Determines the template type, based on the given manifest entries of the app
 * @param manifest - the manifest.json file
 * @param {FioriElementsVersion} fioriElementsVersion - OData or FE version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger) {
    let templateType;
    if (manifest[ux_specification_types_1.ManifestSection.ovp]) {
        templateType = ux_specification_types_1.TemplateType.OverviewPageV2;
    }
    else if (fioriElementsVersion === ux_specification_types_1.FioriElementsVersion.v2) {
        templateType = determineV2Template(manifest, logger);
    }
    else if (fioriElementsVersion === ux_specification_types_1.FioriElementsVersion.v4) {
        templateType = determineV4Template(manifest, logger);
    }
    else {
        if (!templateType) {
            (0, extensionLogger_1.log)(logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOFE'),
                location: {
                    path: ux_specification_types_1.MANIFESTPATH
                }
            });
        }
    }
    return templateType;
}
exports.getTemplateTypeFromManifest = getTemplateTypeFromManifest;
/**
 * Adds title and description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
function addSectionTitleAndDescription(facet, section, facetKey) {
    if (facet?.ID) {
        section.title = ux_specification_types_1.FacetTitlePrefix + facet.ID;
        section[ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.id, value: facet.ID }];
    }
    else {
        section.title = facetKey.replace(/@com.sap/g, 'com.sap');
        section[ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.id, value: facetKey.replace(ux_specification_types_1.UIVOCABULARYALPHADOT, '') }];
    }
    // Description
    if (facet?.Label) {
        section.description = facet.Label;
    }
    else if (facet?.ID) {
        section.description = facet.ID;
    }
    else {
        section.description = facetKey.substring(facetKey.lastIndexOf('.') + 1);
    }
}
exports.addSectionTitleAndDescription = addSectionTitleAndDescription;
/**
 * Adds target title or description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
function addTargetTitleAndSectionDescription(facet, section, facetKey) {
    addSectionTitleAndDescription(facet, section, facetKey);
    if (facet?.ID || facet?.Label) {
        return;
    }
    if (facet?.Title) {
        section.description = facet.Title;
    }
    else if (facet?.target?.['Title']) {
        section.description = facet.target['Title'];
    }
    else if (facet?.target?.['Label']) {
        section.description = facet.target['Label'];
    }
}
exports.addTargetTitleAndSectionDescription = addTargetTitleAndSectionDescription;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
function createDefaultSection(appSchema, facet, facetKey) {
    if (!facet) {
        return undefined;
    }
    let section;
    if (appSchema.definitions.ObjectPageSection) {
        //base type in V2, with properties
        section = JSON.parse(JSON.stringify(appSchema.definitions.ObjectPageSection));
    }
    else {
        section = {
            type: 'object',
            properties: {},
            additionalProperties: false
        };
        section[ux_specification_types_1.SchemaTag.isViewNode] = true;
    }
    section[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    addTargetTitleAndSectionDescription(facet, section, facetKey);
    return section;
}
exports.createDefaultSection = createDefaultSection;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {EntityType} entityType The actual entityType
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {boolean} [checkUnresolvableFacets=false] - Check and avoid facets and sections without ID and Target.
 * @returns {FacetSection[]} - Array of facets or sections
 */
function getObjectPageFacetSection(entityType, oDataServiceAVT, logger, oDataVersion = ux_specification_types_1.FioriElementsVersion.v2, checkUnresolvableFacets = false) {
    const alias = findAlias(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    let sections = [];
    if (entityType) {
        const facetAnnotation = alias && entityType?.annotations?.[alias]?.Facets;
        if (facetAnnotation) {
            sections = facetAnnotation.reduce(function (result, item) {
                if (checkUnresolvableFacets && !item['ID'] && !('Target' in item && item['Target'])) {
                    return result;
                }
                const section = getSectionFacet(item, entityType, oDataServiceAVT, logger, oDataVersion, true);
                if (section) {
                    result.push(section);
                }
                return result;
            }, sections);
        }
        return sections;
    }
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param {object} manifest - manifest.json part of the export result
 * @param {string} path  - path in the manifest
 * @param {boolean} deletionRequest - if set to true, any manifest setting specified by entityPath gets deleted even if it comprises any unknown property
 * @param {string[]} entityPathArray (optional) - array of elements, describing a path to a subsection of the config.
 *                                                If specified, only elements from this subsection are getting deleted
 * @param {string} targetAnnotation (optional) - target annotation (optional, in case of sections, subsections)
 * @param {string} targetAnnotationEncoded (optional) - encoded version of the target annotation, as represented in the manifest
 */
const deleteEmptyStructure = (manifest, path, deletionRequest, entityPathArray, targetAnnotation, targetAnnotationEncoded) => {
    if (!path) {
        return;
    }
    let manifestSection = manifest;
    const pathArray = path.split('/');
    pathArray.forEach(function (element) {
        const decodedElement = targetAnnotationEncoded && targetAnnotationEncoded === element
            ? targetAnnotation
            : element.replace(/\?\?/g, '/');
        if (!manifestSection[decodedElement]) {
            return;
        }
        if (Object.keys(manifestSection[decodedElement]).length === 0 ||
            //deletion explicitly requested by using entityPath
            (entityPathArray && entityPathArray[entityPathArray.length - 1] === decodedElement && deletionRequest)) {
            if (Array.isArray(manifestSection)) {
                manifestSection.splice(Number(decodedElement), 1);
            }
            else {
                delete manifestSection[decodedElement];
            }
            pathArray.pop();
            (0, exports.deleteEmptyStructure)(manifest, pathArray.join('/'), deletionRequest, entityPathArray, targetAnnotation, targetAnnotationEncoded);
            return;
        }
        manifestSection = manifestSection && manifestSection[decodedElement];
    });
};
exports.deleteEmptyStructure = deleteEmptyStructure;
/**
 * Method which returns generic schema file name.
 * @param {SchemaType | PageTypeV2} schemaType Schema type or Page type.
 * @return {string} File name of generic schema.
 */
const getGenericSchemaFileName = (schemaType) => {
    if (schemaType === ux_specification_types_1.SchemaType.FreestylePage) {
        return ux_specification_types_1.PageTypeV2.CustomPage;
    }
    if (schemaType === ux_specification_types_1.SchemaType.FPMCustomPage) {
        // FPM custom pages uses generic schema generated for building blocks
        return ux_specification_types_1.SchemaType.BuildingBlocks;
    }
    return `${schemaType}`;
};
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageTypeV2} schemaType Schema type or Page type.
 * @param {string} [pageId] target page id from manifest.json
 * @return {SchemaFilePath} File path info.
 */
const getSchemaFilePath = (schemaType, pageId, viewId) => {
    const schemaFile = {
        filename: '',
        path: ''
    };
    switch (schemaType) {
        // Application schema
        case ux_specification_types_1.SchemaType.Application: {
            // File name
            schemaFile.filename = `App`;
            // Full path
            schemaFile.path = `./${ux_specification_types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // List report and object page
        case ux_specification_types_1.SchemaType.ListReport:
        case ux_specification_types_1.SchemaType.ObjectPage: {
            // File name
            schemaFile.filename = pageId ? `${schemaType}_${pageId}` : getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${ux_specification_types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        case ux_specification_types_1.PageTypeV4.FPMCustomPage:
        case ux_specification_types_1.SchemaType.FPMCustomPage: {
            // File name
            schemaFile.filename = viewId
                ? `${ux_specification_types_1.SchemaType.FPMCustomPage}_${viewId}`
                : getGenericSchemaFileName(ux_specification_types_1.SchemaType.FPMCustomPage);
            // Full path
            schemaFile.path = `../${ux_specification_types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // Other page configs
        default: {
            // File name
            schemaFile.filename = getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${ux_specification_types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
    }
    schemaFile.path += '.json';
    return schemaFile;
};
exports.getSchemaFilePath = getSchemaFilePath;
/**
 * Method which generates id of page according to passed parameters
 * @param appVersion - Fiori Elements version - V2 or V4
 * @param pageType - Page type
 * @param entitySet - Entity Set
 * @param viewId - Custom page's viewId (optional)
 * @param pageName - Page name in manifest. Used if entitySet is empty
 * @returns {string} Generated page id
 */
function generatePageId(pageType, entitySet, viewId, pageName) {
    if (pageType === ux_specification_types_1.PageTypeV2.CustomPage) {
        const names = viewId && viewId.split('.');
        return names && names[names.length - 1] + 'Page';
    }
    const parts = [];
    parts.push(pageType);
    if (entitySet) {
        parts.push(entitySet);
    }
    else if (pageName) {
        parts.push(pageName.replace('|', '').replace(pageType, ''));
    }
    return parts.join('_');
}
exports.generatePageId = generatePageId;
/**
 * Method finds matching objects against passed interface of 'additionalProperties' and returns array of matching object keys.
 * @param {Definition} appSchema - App-specific JSON schema.
 * @param {Definition} additionalProperties - Allowed additional properties.
 * @param {object} configObject -Container object to find matching childs.
 * @returns {string[]} Array of matching object keys
 */
function findMatchingKeysByAdditionalProperties(appSchema, additionalProperties, configObject) {
    let properties = additionalProperties?.properties;
    let required = additionalProperties?.required;
    if (!properties && additionalProperties?.$ref) {
        const reference = additionalProperties?.$ref;
        const definition = appSchema.definitions[reference.split(exports.DEFINITION_LINK_PREFIX)[1]];
        if (typeof definition === 'object') {
            properties = definition.properties;
            required = definition.required;
        }
    }
    if (!properties || Object.keys(properties).length === 0) {
        return [];
    }
    const result = [];
    required = required || [];
    // Merge new entries for creation into list
    for (const key in configObject) {
        const entry = configObject[key];
        // Check if interface of config entry matches additionalProperties - all required properties should exist in entry
        if (typeof entry === 'object' && required.every((property) => entry[property])) {
            result.push(key);
        }
    }
    return result;
}
exports.findMatchingKeysByAdditionalProperties = findMatchingKeysByAdditionalProperties;
function fillArrayFromAnyOfReference(element, appSchema, currentConfigObject, definitionArray) {
    const $ref = element.$ref;
    if (!$ref) {
        return;
    }
    const definitionKey = $ref.split(exports.DEFINITION_LINK_PREFIX)[1];
    const innerDefinition = appSchema.definitions[definitionKey];
    if (typeof innerDefinition === 'object' && typeof currentConfigObject === 'object') {
        const controlProperty = innerDefinition['controlProperty'];
        if (controlProperty) {
            if ($ref.includes(currentConfigObject[controlProperty])) {
                definitionArray.push(definitionKey);
            }
        }
        else if (typeof innerDefinition.additionalProperties === 'object') {
            // Check if potential object already exists in schema properties
            const properties = Object.keys(innerDefinition.properties || {});
            const matchingKeys = findMatchingKeysByAdditionalProperties(appSchema, innerDefinition.additionalProperties, currentConfigObject);
            if (properties.some((property) => property in currentConfigObject) || matchingKeys.length) {
                definitionArray.push(definitionKey);
            }
        }
    }
}
/**
 * Fills an array of next definitions from given references in the JSON schema
 * @param propertyDefinition - Definition of the current property in schema
 * @param currentConfigObject - Current object in the config JSON. Evaluated to get the right value of a controlling property,
 *                              for making the right choice in case of multiple options (anyOf)
 * @param appSchema - app-specific JSON schema
 * @returns an array of definitions to proceed with
 */
function fillArrayFromPropertyDefinition(propertyDefinition, currentConfigObject, appSchema) {
    const definitionArray = [];
    if (propertyDefinition.$ref) {
        definitionArray.push(propertyDefinition.$ref.split(exports.DEFINITION_LINK_PREFIX)[1]);
    }
    else if (propertyDefinition.anyOf) {
        if (currentConfigObject) {
            propertyDefinition.anyOf.forEach((element) => {
                fillArrayFromAnyOfReference(element, appSchema, currentConfigObject, definitionArray);
            });
        }
        if (definitionArray.length === 0) {
            return undefined;
        }
    }
    return definitionArray;
}
/**
 * Determines the next definition to be handled, based on the definition array.
 * It also creates the Metadata instance for the next definition, to subsequently access metadata like the syncRule
 * @param definitionArray - Array of definitions, as determined by fillArrayFromNextDefinition
 * @param appSchema - app-specific JSON schema
 * @param title - default title
 * @param currentConfigObject - Current object in the config JSON.
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 * @param propertyDefinition - Definition of the current property in schema
 * @returns {NextDefinition} - Next target definition to process
 */
function determineNextDefinitionFromDefinitionArray(definitionArray, appSchema, title, currentConfigObject, key, factory, pageType, propertyDefinition) {
    let nextDefinition = {
        configObject: undefined,
        targetDefinition: {},
        title: ''
    };
    if (definitionArray.length) {
        const lastDefinition = definitionArray[definitionArray.length - 1];
        nextDefinition.targetDefinition = appSchema['definitions'][lastDefinition];
        if (nextDefinition?.targetDefinition?.['$ref'] || nextDefinition?.targetDefinition?.['type'] === 'array') {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            nextDefinition = getNextTargetDefinition(appSchema, title, currentConfigObject, nextDefinition.targetDefinition, key, factory, pageType);
            return nextDefinition;
        }
        if (definitionArray.length > 1) {
            definitionArray.forEach((element) => {
                if (element !== '') {
                    nextDefinition.targetDefinition['properties'] = {
                        ...nextDefinition.targetDefinition['properties'],
                        ...appSchema['definitions'][element]['properties']
                    };
                }
            });
        }
        nextDefinition.title = nextDefinition?.targetDefinition?.['title']
            ? nextDefinition.targetDefinition['title']
            : title;
        const factoryKey = lastDefinition?.split('<')[0];
        const targetObject = currentConfigObject ? currentConfigObject : {};
        nextDefinition.configObject = factory.createInstance(pageType, factoryKey, targetObject, nextDefinition?.targetDefinition?.['controlProperty']);
    }
    else {
        //e.g. sections ==> loop over all properties = subsections or other
        nextDefinition.targetDefinition = propertyDefinition;
        nextDefinition.title = nextDefinition.targetDefinition['title']
            ? nextDefinition.targetDefinition['title']
            : key;
        nextDefinition.configObject = currentConfigObject;
    }
    return nextDefinition;
}
/**
 * Recursive function to determine the next config part, next definition in the app schema and the title
 * @param appSchema - app-specific JSON schema
 * @param title - default title
 * @param currentConfigObject - current part of the configuration that gets traversed
 * @param propertyDefinition - definition of a given property in the app schema
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 */
function getNextTargetDefinition(appSchema, title, currentConfigObject, propertyDefinition, key, factory, pageType) {
    let nextDefinition;
    if (propertyDefinition['type'] === 'array') {
        nextDefinition = getNextTargetDefinition(appSchema, title, currentConfigObject, propertyDefinition['items'], key, factory, pageType);
        return nextDefinition;
    }
    const definitionArray = fillArrayFromPropertyDefinition(propertyDefinition, currentConfigObject, appSchema);
    if (!definitionArray) {
        return undefined;
    }
    nextDefinition = determineNextDefinitionFromDefinitionArray(definitionArray, appSchema, title, currentConfigObject, key, factory, pageType, propertyDefinition);
    return nextDefinition;
}
exports.getNextTargetDefinition = getNextTargetDefinition;
/**
 * Custom array merge function called by deepmerge's merge function
 *
 * @param {*} target Target array
 * @param {*} source Source array
 * @param {*} options options object provided by deepmerge's merge function
 * @returns
 */
const arrayCombineMerge = (target, source, options) => {
    const destination = target.slice();
    source.forEach((item, index) => {
        if (typeof destination[index] === 'undefined') {
            destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
        }
        else if (options.isMergeableObject(item)) {
            destination[index] = (0, deepmerge_1.default)(target[index], item, options);
        }
        else if (target.indexOf(item) === -1) {
            destination.push(item);
        }
    });
    return destination;
};
exports.arrayCombineMerge = arrayCombineMerge;
/**
 * Converts an enum into a CSV
 * @param {object} manifestSection - manifestSection where the key exists
 * @param {object} configPart - Property as mentioned in config file
 * @param {string} key - Property to be exported to manifest
 */
function convertEnumToCSV(manifestSection, configPart, key) {
    manifestSection[key] = JSON.parse(JSON.stringify(configPart[key]));
    // convert enum array to joined string
    const field = configPart[key];
    manifestSection[key] = field.join();
}
exports.convertEnumToCSV = convertEnumToCSV;
/**
 * Converts an action ID from the internal format (schema, config) to the stable ID representation
 * @param actionId - the (unique) internal format of the action ID
 * @returns the converted action ID
 */
function convertActionKeyToStableId(actionId) {
    if (!actionId) {
        return;
    }
    return (actionId.indexOf('??') > -1 ? actionId.split('??')[1] : actionId).replace(/@/g, '::');
}
exports.convertActionKeyToStableId = convertActionKeyToStableId;
/**
 * Method returns definition key for passed '$ref' property by removing 'definition' prefix
 * @param {string} $ref Definition reference.
 * @returns Definition key.
 */
function getDefinitionKey($ref) {
    return $ref?.split(exports.DEFINITION_LINK_PREFIX)[1];
}
exports.getDefinitionKey = getDefinitionKey;
/**
 * Method returns definition $ref' property for passed definition key.
 * @param {string} key Definition key.
 * @returns Definition reference.
 */
function getDefinitionsRef(key) {
    return `#/definitions/${key}`;
}
exports.getDefinitionsRef = getDefinitionsRef;
/**
 * Returns the message property if the error is an instance of `Error` else a string representation of the error.
 *
 * @param error {Error | unknown} - the error instance
 * @returns {string} the error message
 */
function getErrorMessage(error) {
    return error instanceof Error ? error.message : String(error);
}
exports.getErrorMessage = getErrorMessage;
/**
 * Method checks if passed array of features contains required feature.
 *
 * @param {FeatureToggle[]} [featureToggles] Array of features.
 * @param {FeatureToggle} [feature] Feature to check if it is supported.
 * @returns {boolean} True if passed feature is supported.
 */
function isFeatureSupported(featureToggles, feature) {
    return featureToggles?.includes(feature);
}
exports.isFeatureSupported = isFeatureSupported;
/**
 * Method adds indices (propertyIndex property) to app-specific JSON schema properties.
 *
 * @param {Definition} [schema] App-specific JSON schema.
 * @param {string[]} [order] Order of properties.
 * @returns {void} Updates app-specific JSON schema properties with indices.
 */
function updatePropertyIndices(schema, order) {
    order.forEach((propertyName, index) => {
        if (schema.properties[propertyName]) {
            schema.properties[propertyName]['propertyIndex'] = index;
        }
    });
}
exports.updatePropertyIndices = updatePropertyIndices;
/**
 * Method to get value for passed path in passed object.
 * @param obj Object to check.
 * @param paths Path for searching property/value.
 * @returns Found value for passed path.
 */
function getJSONPropertyByPath(obj, paths) {
    let current = obj;
    for (const path of paths) {
        if (path === undefined) {
            continue;
        }
        if (typeof current === 'object' && path in current) {
            // found and continue
            current = current[path];
        }
        else {
            return undefined;
        }
    }
    return current;
}
exports.getJSONPropertyByPath = getJSONPropertyByPath;
/**
 * Method to remove namespaces
 * @param {string } [sId]
 * @returns {string} modified string without namespace
 */
function removeNamespaces(sId) {
    sId = sId.replace(ux_specification_types_1.UIVOCABULARYDOT, '');
    sId = sId.replace('com.sap.vocabularies.Communication.v1.', '');
    return sId;
}
exports.removeNamespaces = removeNamespaces;
/**
 * Method to replace namespaces with short hand form
 * @param {string } [sId]
 * @returns {string} modified string with replaced namespaces
 */
function replaceNamespaces(sId) {
    sId = sId.replace(ux_specification_types_1.UIVOCABULARY, 'UI');
    sId = sId.replace('com.sap.vocabularies.Communication.v1', 'Communication');
    return sId;
}
exports.replaceNamespaces = replaceNamespaces;
//# sourceMappingURL=utils.js.map