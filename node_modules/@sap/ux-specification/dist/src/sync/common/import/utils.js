"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeEmptyStructure = exports.getTargetFromCustomColumnRef = exports.getSectionTitle = exports.checkDeprecatedProperties = exports.importProperty = void 0;
const __1 = require("../");
const extensionLogger_1 = require("../../../extensionLogger");
const dist_1 = require("@sap/ux-specification-types/dist");
/**
 * Transfers the value of a single manifest setting to the config
 * @param syncRule - Metadata rule
 * @param manifestSection - Section in manifest.json
 * @param propertyKey - Key of the property or setting
 * @param configPart - Part of the config JSON
 * @param sectionId - Section or facet ID
 * @param breadcrumbs - list of breadcrumbs or id's describing the keys of all hierarchy levels
 */
function importProperty(syncRule, manifestSection, propertyKey, configPart, sectionId, breadcrumbs) {
    const manifestKey = syncRule.manifest.key || propertyKey;
    const importHandler = syncRule.manifest.import;
    if (importHandler && typeof importHandler === 'function') {
        const value = importHandler(manifestSection, sectionId, propertyKey, breadcrumbs);
        if (value !== undefined) {
            configPart[propertyKey] = value;
        }
    }
    else if (manifestSection[manifestKey] !== undefined) {
        configPart[propertyKey] = manifestSection[manifestKey];
    }
}
exports.importProperty = importProperty;
/**
 * Validation during import: check if properties are marked as deprecated.
 * If so, log them.
 * @param deprecatedProperties - existing list, to be actualized
 * @param manifestSection - Section in manifest.json
 * @param path - path to the section in manifest
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function checkDeprecatedProperties(deprecatedProperties, manifestSection, path, logger) {
    if (manifestSection && deprecatedProperties) {
        for (const key in manifestSection) {
            const deprecated = deprecatedProperties[key];
            if (deprecated) {
                (0, extensionLogger_1.log)(logger, {
                    severity: "warning" /* LogSeverity.Warning */,
                    message: (0, __1.getTextForDeprecated)(key, deprecated),
                    location: {
                        path: 'webapp/manifest.json/',
                        range: path.split('/')
                    }
                });
                delete deprecatedProperties[key];
            }
        }
    }
}
exports.checkDeprecatedProperties = checkDeprecatedProperties;
/**
 * Determines the title of a section representation in the app schema, main aspect is checking the facet ID
 * @param schemaSection - Section in manifest.json
 * @param jsonSchema - app specific schema
 */
function getSectionTitle(schemaSection, jsonSchema) {
    if (schemaSection.$ref && !schemaSection.title) {
        const refTitle = jsonSchema.definitions[schemaSection.$ref.split(__1.DEFINITION_LINK_PREFIX)[1]];
        return getSectionTitle(refTitle, jsonSchema);
    }
    else if (schemaSection.title) {
        if (schemaSection.title.startsWith(dist_1.FacetTitlePrefix)) {
            return schemaSection.title.split(dist_1.FacetTitlePrefix)[1].replace(/com.sap/g, '@com.sap');
        }
        else {
            return schemaSection.title.replace(/com.sap/g, '@com.sap');
        }
    }
    else {
        return undefined;
    }
}
exports.getSectionTitle = getSectionTitle;
/**
 * Method returns target by resolving custom column reference name.
 * For example - 'TableCustomColumns<dummyTarget>' is resolved as 'dummyTarget'.
 * @param {string} ref Reference key.
 * @returns {string | undefined} Resolved target.
 */
function getTargetFromCustomColumnRef(ref) {
    const refParts = ref.split(`${dist_1.DefinitionName.CustomColumns}<`);
    if (refParts[1]) {
        return refParts[1].split('>')[0];
    }
    return undefined;
}
exports.getTargetFromCustomColumnRef = getTargetFromCustomColumnRef;
/**
 * Removes part of a given config, if empty
 * @param {object} config - config part
 * @param {string} structure - part of config to be removed
 */
function removeEmptyStructure(config, structure) {
    if (!config[structure]) {
        return;
    }
    if (Object.keys(config[structure]).length < 1) {
        delete config[structure];
    }
}
exports.removeEmptyStructure = removeEmptyStructure;
//# sourceMappingURL=utils.js.map