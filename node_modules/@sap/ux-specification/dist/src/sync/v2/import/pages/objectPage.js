"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createObjectPageConfigV2 = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const table_1 = require("../controls/table");
const extensionLogger_1 = require("../../../../extensionLogger");
const utils_1 = require("../utils");
const common_1 = require("../../../common");
const manifest_1 = require("../../export/manifest");
const i18next_1 = __importDefault(require("i18next"));
const i18n_1 = require("../../../../i18n/i18n");
const factory_1 = require("../../export/factory");
const types_1 = require("../../types");
const common_2 = require("../common");
// Comprises list of flexChanges that do not require a facet id
const SupportedFlexChangesWithoutFacetId = [ux_specification_types_1.ControlType.Avatar, ux_specification_types_1.ControlType.ObjectPageLayout, ux_specification_types_1.ControlType.DynamicPage];
/**
 * Determines Facet ID from single string selector Id
 * @param {string} selectorId Selector ID
 * @returns {string} FacetID
 */
function getSingleSelectorIdPart(selectorIdParts, facetID) {
    const lastIdParts = selectorIdParts[0].split('-');
    const id = lastIdParts[lastIdParts.length - 1];
    if (selectorIdParts[0].indexOf('::action::') >= 0 || selectorIdParts[0].startsWith('action::')) {
        // Object Page ToolBar Actions
        facetID =
            lastIdParts[0].split('::action::')[0] ||
                lastIdParts[0].split(`${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}::`)[1].split('::')[0];
        facetID = `${ux_specification_types_1.ActionTitlePrefix}${facetID}`;
    }
    else if (selectorIdParts[0].indexOf("com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */) >= 0 ||
        selectorIdParts[0].indexOf('UI.LineItem') >= 0 ||
        selectorIdParts[0].indexOf('::Table') >= 0) {
        facetID = lastIdParts[0].split('::Table')[0].split('::responsiveTable')[0];
    }
    else {
        const idParts = id.split('::');
        if (idParts.length > 1) {
            facetID = idParts[0];
        }
        else if (lastIdParts[0].indexOf('::') > -1) {
            facetID = lastIdParts[0].split('::')[0];
        }
    }
    return facetID;
}
/**
 * Determines Facet ID of flex change
 * @param {string} selectorId Control ID of flex change
 * @returns {string} FacetID
 */
function getFacetID(selectorId) {
    let facetID;
    const selectorIdParts = selectorId.split(':::');
    if (selectorIdParts.length === 1) {
        facetID = getSingleSelectorIdPart(selectorIdParts, facetID);
    }
    else if (selectorId.indexOf('sSmartTableId') >= 0) {
        for (const element of selectorIdParts) {
            if (element.startsWith('sSmartTableId')) {
                facetID = element
                    .split('sSmartTableId::')[1]
                    .split('::Table')[0]
                    .split('/responsiveTable')[0]
                    .replace(`::${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`, `/@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`);
                break;
            }
        }
    }
    else {
        facetID = selectorIdParts[0];
    }
    return facetID;
}
/**
 * Prepares the list of flex changes
 * @param change - the flex change (UI Adaptation)
 * @returns {FlexChangesForTransfer} - list of prepared flex changes
 */
function prepareFlexChanges(changes, entitySet, logger) {
    const result = {};
    const complexIdMatch = /.+DataField.+:::sSmartTableId::.+/;
    changes.forEach((changeString) => {
        try {
            const change = (0, common_1.parseChangeString)(changeString);
            const changeId = (change && change.controlId?.split('--')) || [];
            if (change && changeId[0]?.includes(ux_specification_types_1.v2.FE_TEMPLATE_V2_OBJECT_PAGE) && changeId[0]?.endsWith(entitySet)) {
                let selectorId = changeId[1].replace(/:3a:3a/g, '::');
                if (complexIdMatch.exec(selectorId) !== null) {
                    selectorId = selectorId.split('template:::TableColumn:::')[1];
                }
                const facetID = getFacetID(selectorId);
                selectorId = (0, common_2.convertSelector)(selectorId)
                    .replace(/:3a:3a/g, '::')
                    .replace(/\/@com.sap.vocabularies/g, '::com.sap.vocabularies');
                result[`${selectorId}::${change.content.property}`] = {
                    controlId: selectorId,
                    propertyId: change.content.property,
                    facetId: facetID,
                    newValue: change.content.newBinding !== undefined ? change.content.newBinding : change.content.newValue,
                    controlType: change.controlType,
                    creation: change.creation
                };
            }
        }
        catch (error) {
            (0, extensionLogger_1.log)(logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('FLEXERROR')
            }, ...error);
        }
    });
    const sortedList = Object.entries(result).sort((a, b) => a[1].creation - b[1].creation);
    return sortedList.reduce((accum, [k, v]) => {
        accum[k] = v;
        return accum;
    }, {});
}
/**
 * Returns the type of a given section
 * @param schemaSection - current section
 * @returns {SectionTypeV2} - type of section, differentiated by level (Sub/Section)
 */
const getSectionType = (schemaSection) => {
    let reference;
    if (schemaSection['$ref']) {
        reference = schemaSection['$ref'].includes('<') ? schemaSection['$ref'].split('<')[0] : schemaSection['$ref'];
        return reference.replace(common_1.DEFINITION_LINK_PREFIX, '');
    }
    else if (schemaSection['properties']?.['subsections']?.['$ref']) {
        reference = schemaSection['properties']['subsections']['$ref'];
        reference = reference.includes('<') ? reference.split('<')[0] : reference;
        return reference.replace(common_1.DEFINITION_LINK_PREFIX, '');
    }
    else if (schemaSection['properties']?.['subsections']) {
        return types_1.SectionTypeV2.SubSection;
    }
};
/**
 * Import of flex changes of a table to the config JSON of OP
 * @param flexChanges - list of flex changes (pre-processed by prepareFlexChanges)
 * @param propertyKey - key of the current property in the app schema
 * @param configPart - part of the configuration to be filled
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising all input data
 * @param sectionTitle - title of the section (optional)
 * @param sectionId - ID of the given section (optional)
 */
function importFlexChangesOfTable(flexChanges, propertyKey, configPart, importParameters, sectionTitle, sectionId) {
    let facetIds;
    if (sectionTitle) {
        facetIds = [sectionTitle.replace(/@/g, '')];
    }
    else {
        facetIds = [sectionId.replace(/@/g, ''), sectionId?.replace(/::@com.sap.vocabularies/g, ux_specification_types_1.VOCWITHSLASH)];
    }
    for (const selector in flexChanges) {
        const flexChange = flexChanges[selector];
        const propertyIdMatch = flexChange.propertyId === propertyKey;
        const isTableColumn = propertyKey === 'columns' && flexChange.controlType === ux_specification_types_1.ControlType.TableColumn;
        if ((propertyIdMatch || isTableColumn) && facetIds.indexOf(flexChange?.facetId) > -1) {
            (0, table_1.addFlexForTable)(configPart, flexChange, importParameters.jsonSchema);
        }
    }
}
/**
 * Helper function to evaluate if flex change is for standard action
 * @param flexChange - flex change
 * @param controlIdMatch - if ID of the control matches RegEx
 * @returns {boolean} is standard action flex change
 */
function isStandardActionFlexChange(flexChange, controlIdMatch) {
    return flexChange.facetId === 'template' && controlIdMatch;
}
/**
 * Helper function to check if Flex change Id and config/schema Id match
 * @param changeId Control Id of flex change to compare against
 * @param targetId Schema/Section Id
 * @param checkTitle flag if check consists of schema title
 * @returns {boolean} if flex change id and config/schema Id match
 */
const idElementChecker = (changeId, targetId, checkTitle = false) => {
    if (!checkTitle) {
        return targetId.every((v) => changeId.includes(v));
    }
    // Check that qualifier matches too
    const startIndex = changeId.indexOf(targetId[0]);
    const endIndex = changeId.length - startIndex > targetId.length ? changeId.length - 1 : undefined;
    const arrayToCheck = changeId.slice(startIndex, endIndex);
    return arrayToCheck.length === targetId.length && targetId.every((v) => arrayToCheck.includes(v));
};
/**
 * RegEx check of the control Id and/or the section Id against the selector of a flex change
 * @param schemaDefinition - current section of the app specific schema
 * @param flexChange - flex change
 * @param controlIdChecker - RegEx for the controlId
 * @param selectionIdChecker - RegEx for the selectionId
 * @param sectionId - title of the section (optional)
 * @param controlId - ID of the given control, for e.g. GroupElement, Action (optional)
 * @returns the result of all checks
 */
function matchSelector(schemaDefinition, flexChange, controlIdChecker, selectionIdChecker, sectionId, controlId) {
    let idMatch = false, controlIdMatch = false;
    if (controlId) {
        idMatch = controlIdMatch = controlIdChecker.test(flexChange.controlId);
        if (sectionId) {
            idMatch = controlIdMatch && selectionIdChecker.test(flexChange.controlId);
        }
    }
    else if (sectionId) {
        idMatch = selectionIdChecker.test(flexChange.controlId);
    }
    const controlIdParts = flexChange.controlId.split('::');
    const isGroupId = flexChange.controlType === ux_specification_types_1.ControlType.GroupElement && controlIdMatch;
    const isActionId = flexChange.facetId?.includes(ux_specification_types_1.ActionTitlePrefix) && !sectionId && idMatch;
    const isSectionId = sectionId && idElementChecker(controlIdParts, sectionId.split('::')) && idMatch;
    const isSchemaTitle = schemaDefinition.title && idElementChecker(controlIdParts, schemaDefinition.title.split('::'), true);
    const isSupportedWithoutFacetId = !flexChange.facetId && SupportedFlexChangesWithoutFacetId.includes(flexChange.controlType);
    const isStandardAction = isStandardActionFlexChange(flexChange, controlIdMatch);
    return isGroupId || isActionId || isSectionId || isSchemaTitle || isSupportedWithoutFacetId || isStandardAction;
}
/**
 * Import of (regular) flex changes to the config JSON of OP
 * @param schemaDefinition - current section of the app specific schema
 * @param configPart - part of the configuration to be filled
 * @param flexChanges - list of flex changes (pre-processed by prepareFlexChanges)
 * @param propertyKey - key of the current property in the app schema
 * @param sectionId - title of the section (optional)
 * @param elementId - stable ID part of the given element, for e.g. GroupElement, Action (optional)
 */
function importFlexChanges(schemaDefinition, configPart, flexChanges, propertyKey, sectionId, elementId) {
    const controlIdChecker = new RegExp(`.*${elementId}`);
    const selectionIdChecker = new RegExp(`.*${sectionId}`);
    for (const selector in flexChanges) {
        const flexChange = flexChanges[selector];
        //Property match?
        if (flexChange.propertyId !== propertyKey) {
            continue;
        }
        //Control type match?
        if (flexChange.controlType !== schemaDefinition.properties[flexChange.propertyId]?.[ux_specification_types_1.SchemaTag.controlType]) {
            continue;
        }
        const match = matchSelector(schemaDefinition, flexChange, controlIdChecker, selectionIdChecker, sectionId, elementId);
        if (match) {
            configPart[propertyKey] = flexChange.newValue;
        }
    }
}
/**
 * Checks for deprecated properties and writes them to the log
 * @param manifestSection - given section in the manifest
 * @param deprecatedProperties - list of deperecated properties
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising all input data
 * @param manifestPath - manifest path, as calcualted by the sync rule
 */
function checkDeprecatedProperties(manifestSection, deprecatedProperties, importParameters, manifestPath) {
    if (manifestSection && deprecatedProperties) {
        for (const key in manifestSection) {
            const deprecated = deprecatedProperties[key];
            if (deprecated) {
                (0, extensionLogger_1.log)(importParameters.logger, {
                    severity: "warning" /* LogSeverity.Warning */,
                    message: (0, common_1.getTextForDeprecated)(key, deprecated),
                    location: {
                        path: 'webapp/manifest.json/',
                        range: manifestPath.split('/')
                    }
                });
                delete deprecatedProperties[key];
            }
        }
    }
}
/**
 * Imports manifest settings to the object page config
 * @param syncRule - sync rule for accessing the reflect-metadata
 * @param pageKeys - list of page keys (comprises the one entry describing the given page)
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising all input data
 * @param configPart - part of the configuration to be filled
 * @param propertyKey  - key of the current property of the schema definition
 * @param deprecatedProperties - list od deperecated properties
 * @param sectionId - ID of the given section (optional)
 * @param sectionTitle - title of the section (optional)
 */
function importManifestSetting(syncRule, pageKeys, importParameters, configPart, propertyKey, deprecatedProperties, sectionPart) {
    const sectionIdInManifest = sectionPart?.id
        ? sectionPart.id.replace(/\/@/g, '::').replace(/@com.sap/g, 'com.sap')
        : undefined;
    let manifestPath;
    let manifestSection;
    if (sectionPart?.title) {
        manifestPath = syncRule.manifest.path(pageKeys, {}, sectionPart.title);
        manifestSection = (0, manifest_1.ensureManifestSectionByPathV2)(importParameters.manifest, manifestPath);
        if (Object.values(manifestSection).length === 0) {
            manifestPath = syncRule.manifest.path(pageKeys, {}, sectionIdInManifest);
            manifestSection = (0, manifest_1.ensureManifestSectionByPathV2)(importParameters.manifest, manifestPath);
        }
    }
    else {
        manifestPath = syncRule.manifest.path(pageKeys, {}, sectionIdInManifest);
        manifestSection = (0, manifest_1.ensureManifestSectionByPathV2)(importParameters.manifest, manifestPath);
    }
    const importHandler = syncRule.manifest.import;
    if (importHandler && typeof importHandler === 'function') {
        const value = importHandler(manifestSection, sectionPart?.id);
        if (value !== undefined) {
            configPart[propertyKey] = value;
        }
    }
    else {
        const manifestKey = syncRule.manifest.key || propertyKey;
        if (manifestKey in manifestSection) {
            configPart[propertyKey] = manifestSection[manifestKey];
        }
    }
    // Check for deprecated properties.
    checkDeprecatedProperties(manifestSection, deprecatedProperties, importParameters, manifestPath);
    return manifestSection;
}
/**
 * Transfers settings from manifest and flexChanges to object page config
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising all input data
 * @param configPart - part of the configuration to be filled
 * @param schemaDefinition - current section of the app specific schema
 * @param configParameters - comprises page keys and flex changes
 * @param sectionPart - structure comprising the section information
 * @param elementId - stable ID part of the given element (action, column, ...) (optional)
 */
function transferSettingsAndFlexChanges(importParameters, configPart, schemaDefinition, configParameters, sectionPart, elementId) {
    if (!schemaDefinition) {
        return;
    }
    const deprecatedProperties = configPart?.getDeprecated ? configPart.getDeprecated() : {};
    for (const propertyKey in schemaDefinition.properties || schemaDefinition) {
        const syncRule = (0, common_1.getReflectMetadata)(configPart, propertyKey);
        if (propertyKey === 'columns' || syncRule?.flex) {
            if (sectionPart?.type?.startsWith('ObjectPageSectionTableV2') ||
                sectionPart?.type?.startsWith('ObjectPageSubSectionTableV2')) {
                importFlexChangesOfTable(configParameters.flexChanges, propertyKey, configPart, importParameters, sectionPart.title, sectionPart.id);
            }
            else {
                const facetId = sectionPart?.title || sectionPart?.id;
                importFlexChanges(schemaDefinition, configPart, configParameters.flexChanges, propertyKey, facetId, elementId);
            }
        }
        else if (syncRule?.manifest) {
            importManifestSetting(syncRule, configParameters.pageKeys, importParameters, configPart, propertyKey, deprecatedProperties, sectionPart);
        }
    }
}
/**
 *
 * @param actionType - type of action
 * @param configActionId - id of action in config
 * @param {ActionTypeV2|string} importTypeId - type of action that was be initiated
 * @returns {string} actionId - to be used for import of flex changes
 */
function getActionId(actionType, configActionId, importTypeId, facetId) {
    let actionId = (0, common_1.convertActionKeyToStableId)(configActionId);
    switch (actionType) {
        case types_1.ActionTypeV2.Form: {
            actionId = `action::${actionId}::${facetId}::${importTypeId}`;
            break;
        }
        case types_1.ActionTypeV2.OPFooter: {
            actionId = `action::${actionId}::Determining`;
            break;
        }
        case types_1.ActionTypeV2.OPToolBar: {
            actionId = actionId.includes('sAction::')
                ? `action::${actionId.split('sAction::')[1]}`
                : `action::${actionId.replace(':2f', '::')}`;
            break;
        }
        case types_1.ActionTypeV2.OPHeaderStandard: {
            actionId = `${types_1.OP_STANDARD_HEADER_ACTION_PREFIX}${actionId}`;
            break;
        }
        case types_1.ActionTypeV2.OPFooterStandard: {
            actionId = `${types_1.OP_STANDARD_FOOTER_ACTION_PREFIX}${actionId}`;
            break;
        }
    }
    return actionId.replace(/@/g, '');
}
/**
 * Adds standard actions to the corresponding header/footer config
 * @param config actions config
 * @param actions existing actions definition
 */
function fillStandardActions(config, actions, importParameters, configParameters) {
    for (const action in actions) {
        const actionType = actions[action].$ref.split(common_1.DEFINITION_LINK_PREFIX)[1].split('<')[0];
        if ([types_1.ActionTypeV2.OPHeaderStandard, types_1.ActionTypeV2.OPFooterStandard].includes(actionType)) {
            const actionRef = actions[action].$ref.split('<')?.[1].split('>')[0];
            const actionId = getActionId(actionType, action, '', '');
            config.actions[action] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, actionRef, {});
            transferSettingsAndFlexChanges(importParameters, config[ux_specification_types_1.PropertyName.actions][action], importParameters.jsonSchema.definitions[actionRef], configParameters, {}, actionId);
        }
    }
}
/**
 *  Fills the action of the configuration
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {object} actionProperties - current properties' list (of action)
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 * @param {ActionTypeV2|string} importTypeId - type of action that should be initiated
 */
function fillActions(importParameters, actionProperties, configPart, configParameters, importTypeId, facetId) {
    configPart[ux_specification_types_1.PropertyName.actions] = {};
    const actionType = importTypeId.split('::').pop();
    if (configParameters.flexChanges && Object.keys(configParameters.flexChanges).length > 0) {
        const sectionPart = {};
        if (facetId) {
            sectionPart.id = facetId;
        }
        for (const actionProperty in actionProperties) {
            const configActionId = (0, common_2.convertActionKey)(actionProperty);
            const actionId = getActionId(actionType, configActionId, importTypeId, facetId);
            if (actionId) {
                configPart[ux_specification_types_1.PropertyName.actions][configActionId] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, actionType);
                transferSettingsAndFlexChanges(importParameters, configPart[ux_specification_types_1.PropertyName.actions][configActionId], importParameters.jsonSchema.definitions[actionType], configParameters, sectionPart, actionId);
            }
            if (configPart[ux_specification_types_1.PropertyName.actions]?.[configActionId] &&
                Object.keys(configPart[ux_specification_types_1.PropertyName.actions][configActionId]).length === 0) {
                delete configPart[ux_specification_types_1.PropertyName.actions][configActionId];
            }
        }
    }
    fillStandardActions(configPart, actionProperties, importParameters, configParameters);
    if (Object.keys(configPart[ux_specification_types_1.PropertyName.actions]).length === 0) {
        delete configPart[ux_specification_types_1.PropertyName.actions];
    }
}
/**
 *  Fills the fields of an object page form
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {sectionPartProperties} sectionPart - current properties' list of form section
 * @param fieldProperties - current properties' list (of fields)
 * @param configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 */
function fillFields(importParameters, sectionPart, fieldProperties, configPart, configParameters) {
    let fieldId;
    configPart[sectionPart.id]['form']['fields'] = {};
    for (const fieldProperty in fieldProperties) {
        fieldId = `${fieldProperty}::GroupElement`;
        configPart[sectionPart.id]['form']['fields'][fieldProperty] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, 'Field');
        const elementId = sectionPart.title?.includes(ux_specification_types_1.UIVOCABULARYALPHADOT)
            ? `${sectionPart.id.replace(/@/g, '')}::${fieldId}`
            : `${sectionPart.title}::${fieldId}`;
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id]['form']['fields'][fieldProperty], importParameters.jsonSchema.definitions[ux_specification_types_1.DefinitionName.Field], configParameters, {}, elementId);
        if (Object.keys(configPart[sectionPart.id]['form']['fields'][fieldProperty]).length === 0) {
            delete configPart[sectionPart.id]['form']['fields'][fieldProperty];
        }
    }
    if (Object.keys(configPart[sectionPart.id]['form']['fields']).length === 0) {
        delete configPart[sectionPart.id]['form']['fields'];
    }
}
/**
 * Adjusts the app schema by choosing the right table definition, depending on the table type
 * @param tableType - the type of the given table
 * @param {SectionPartProperties} sectionPart - current properties' list
 * @param schemaDefinitions - definitions' section of the app schema
 * @returns the right schema definition for the given table
 */
function prepareTableSchema(tableType, sectionPart, schemaDefinitions) {
    let tableSchema;
    if (tableType === 'TreeTable' || tableType === 'AnalyticalTable' || tableType === 'GridTable') {
        tableSchema = schemaDefinitions[`ObjectPage${tableType}<${sectionPart.id}>`];
    }
    else if (schemaDefinitions[`ObjectPageResponsiveTableWithMultiSelect<${sectionPart.id}>`] &&
        schemaDefinitions[`ObjectPageResponsiveTableWithInlineDelete<${sectionPart.id}>`]) {
        tableSchema = JSON.parse(JSON.stringify(schemaDefinitions[`ObjectPageResponsiveTableWithMultiSelect<${sectionPart.id}>`]));
        tableSchema['properties'] = {
            ...tableSchema['properties'],
            ...schemaDefinitions[`ObjectPageResponsiveTableWithInlineDelete<${sectionPart.id}>`]['properties']
        };
    }
    return tableSchema;
}
/**
 *  Fills the table section of the object page config
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {SectionPartProperties} sectionPart - current properties' list
 * @param {Settings} manifestSettings - object page settings section of the manifest
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 */
function fillTableInConfig(importParameters, sectionPart, manifestSettings, configPart, configParameters) {
    const manifestKey = sectionPart.title || sectionPart.id.replace('@com.sap', 'com.sap');
    const manifestSection = manifestSettings && manifestSettings.sections && manifestSettings.sections[manifestKey];
    if (manifestSection || configParameters.flexChanges) {
        const tableType = manifestSection?.tableSettings?.type || 'ResponsiveTable';
        //Instantiate metadata
        const OPtable = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, `ObjectPage${tableType}`, {
            toolBar: {}
        });
        configPart[sectionPart.id] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, sectionPart.type, {
            table: {}
        });
        configPart[sectionPart.id][ux_specification_types_1.PropertyName.table] = OPtable;
        const schemaDefinitions = importParameters.jsonSchema.definitions;
        const tableSchema = prepareTableSchema(tableType, sectionPart, schemaDefinitions);
        //Transfer settings of (sub)section
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id], sectionPart.schema, configParameters, { title: sectionPart.title });
        //Transfer settings of table
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id][ux_specification_types_1.PropertyName.table], tableSchema, configParameters, sectionPart);
        //Transfer settings of table toolbar actions
        const toolBarActions = JSON.parse(JSON.stringify(schemaDefinitions))[`Actions<${sectionPart.id}>`];
        if (toolBarActions?.properties) {
            const facetId = sectionPart?.title
                ? sectionPart.title.replace(/@/g, '::').replace(/::com/g, 'com')
                : sectionPart?.id?.replace(/@/g, '::').replace(/::com/g, 'com');
            fillActions(importParameters, toolBarActions.properties, configPart[sectionPart.id][ux_specification_types_1.PropertyName.table]['toolBar'], configParameters, types_1.ActionTypeV2.OPToolBar, facetId);
        }
        if (Object.keys(configPart[sectionPart.id][ux_specification_types_1.PropertyName.table]['toolBar']).length === 0) {
            delete configPart[sectionPart.id][ux_specification_types_1.PropertyName.table]['toolBar'];
        }
    }
}
/**
 * Fills custom columns in a V2 object page config JSON
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {string} escapedSectionId - escaped version of the section ID
 * @param {string} sectionTitle - title of current section, if available
 * @param {object} configPart - the given part of the object page config
 * @param {SapUiAppPageV2} v2Page - v2 page from manifest.
 */
function fillCustomColumnsInConfig(importParameters, escapedSectionId, configPart, v2Page) {
    const customColumnSchemaProp = importParameters.jsonSchema.definitions[escapedSectionId].properties.custom;
    const customColumnTarget = customColumnSchemaProp
        ? (0, common_1.getTargetFromCustomColumnRef)(customColumnSchemaProp.$ref)
        : undefined;
    if (customColumnTarget) {
        const objectPageSectionData = {
            key: escapedSectionId.replace('@', ''),
            target: customColumnTarget
        };
        (0, common_2.addFragments)(configPart[escapedSectionId], importParameters.manifest, v2Page, ux_specification_types_1.PageTypeV2.ObjectPage, importParameters.fragments, objectPageSectionData);
    }
}
/**
 *  Fills the sections and subsections of the object page config (recursive function)
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising all input data
 * @param {sectionPartProperties} sectionPart - current properties' list of chart section
 * @param {Settings} manifestSettings - object page settings section of the manifest
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 */
function fillChartSection(importParameters, sectionPart, manifestSettings, configPart, configParameters) {
    const manifestKey = sectionPart.id.replace('@com.sap', 'com.sap');
    const manifestSection = manifestSettings && manifestSettings.sections && manifestSettings.sections[manifestKey];
    configPart[sectionPart.id] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, sectionPart.type, {
        chart: {}
    });
    configPart[sectionPart.id][ux_specification_types_1.PropertyName.chart] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, 'ObjectPageChart');
    if (manifestSection || configParameters.flexChanges) {
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id], sectionPart.schema, configParameters, { title: sectionPart.title });
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id][ux_specification_types_1.PropertyName.chart], importParameters.jsonSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageChart], configParameters, sectionPart);
    }
}
/**
 * Fills the header section of the object page config
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {sectionPartProperties} sectionPart - current properties' list of form section
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 */
function fillHeaderSection(importParameters, sectionPart, configPart, configParameters) {
    configPart[sectionPart.id] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, sectionPart.type, {});
    if (configParameters.flexChanges) {
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id], sectionPart.schema, configParameters, { title: sectionPart.title });
    }
    if (Object.keys(configPart[sectionPart.id]).length === 0) {
        delete configPart[sectionPart.id];
    }
}
/**
 * Fills the form section of the object page config
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {sectionPartProperties} sectionPart - current properties' list of form section
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 */
function fillFormSection(importParameters, sectionPart, configPart, configParameters) {
    const formId = sectionPart.schema['properties']['form']['$ref'].split('SectionForm')[1];
    configPart[sectionPart.id] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, sectionPart.type, {
        form: {}
    });
    if (configParameters.flexChanges) {
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id], sectionPart.schema, configParameters, { title: sectionPart.title });
    }
    const formActions = importParameters.jsonSchema.definitions[`SectionActions${formId}`];
    const facetId = sectionPart?.title
        ? sectionPart.title.replace(/@/g, '::').replace(/::com/g, 'com')
        : sectionPart?.id?.replace(/@/g, '::').replace(/::com/g, 'com');
    if (formActions?.properties) {
        fillActions(importParameters, formActions.properties, configPart[sectionPart.id]['form'], configParameters, types_1.ActionTypeV2.Form, facetId);
    }
    const formFields = importParameters.jsonSchema.definitions[`SectionFields${formId}`];
    if (formFields?.properties) {
        fillFields(importParameters, sectionPart, formFields.properties, configPart, configParameters);
    }
    if (Object.keys(configPart[sectionPart.id]['form']).length === 0) {
        delete configPart[sectionPart.id]['form'];
    }
    if (Object.keys(configPart[sectionPart.id]).length === 0) {
        delete configPart[sectionPart.id];
    }
}
/**
 *  Fills the subsection of the object page config
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {sectionPartProperties} sectionPart - current properties' list of subsection
 * @param {Settings} manifestSettings - object page settings section of the manifest
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig
 */
function fillSubSection(importParameters, sectionPart, manifestSettings, configPart, configParameters) {
    configPart[sectionPart.id] = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, sectionPart.type, {
        subsections: {}
    });
    if (configParameters.flexChanges) {
        transferSettingsAndFlexChanges(importParameters, configPart[sectionPart.id], sectionPart.schema, configParameters, sectionPart);
    }
    let currentSchemaSection;
    const schemaProperties = sectionPart.schema.properties;
    if (schemaProperties?.subsections?.properties) {
        currentSchemaSection = schemaProperties.subsections.properties;
    }
    else {
        currentSchemaSection = schemaProperties;
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    fillSectionsInConfig(importParameters, currentSchemaSection, manifestSettings, configPart[sectionPart.id]['subsections'], configParameters);
    if (Object.keys(configPart[sectionPart.id]['subsections']).length < 1) {
        delete configPart[sectionPart.id]['subsections'];
    }
}
/**
 * Fills the sections and subsections of the object page config (recursive function)
 * @param {ImportObjectPageV2Parameters} importParameters - object comprising all input data
 * @param {object} sectionProperties - current properties' list (of sections or subsections)
 * @param {Settings} manifestSettings - object page settings section of the manifest
 * @param {object} configPart - the given part of the object page config
 * @param {ObjectPageV2ConfigParameters} configParameters - container for factory, pageKeys, flexChanges, v2Page, ObjectPageConfig.
 */
function fillSectionsInConfig(importParameters, sectionProperties, manifestSettings, configPart, configParameters) {
    const appSchemaDefinitions = importParameters.jsonSchema.definitions;
    for (const sectionId in sectionProperties) {
        const escapedSectionId = sectionId.replace(/\/@/g, '::');
        const sectionPart = {
            id: escapedSectionId,
            type: getSectionType(sectionProperties[sectionId]),
            schema: sectionProperties[sectionId],
            title: (0, common_1.getSectionTitle)(sectionProperties[sectionId], importParameters.jsonSchema)
        };
        if (sectionPart.schema['$ref'] && sectionPart.type) {
            switch (sectionPart.type) {
                case types_1.SectionTypeV2.SectionTable:
                case types_1.SectionTypeV2.SubSectionTable: {
                    sectionPart.schema = appSchemaDefinitions[`${sectionPart.type}<${sectionId}>`];
                    fillTableInConfig(importParameters, sectionPart, manifestSettings, configPart, configParameters);
                    // Custom column ref
                    fillCustomColumnsInConfig(importParameters, escapedSectionId, configPart, configParameters.v2Page);
                    break;
                }
                case types_1.SectionTypeV2.SectionChart:
                case types_1.SectionTypeV2.SubSectionChart: {
                    // Section without subsections
                    sectionPart.schema = appSchemaDefinitions[`${sectionPart.type}<${sectionId}>`];
                    fillChartSection(importParameters, sectionPart, manifestSettings, configPart, configParameters);
                    break;
                }
                case types_1.SectionTypeV2.SectionForm:
                case types_1.SectionTypeV2.SubSectionForm: {
                    sectionPart.schema = appSchemaDefinitions[`${sectionPart.type}<${sectionId}>`];
                    fillFormSection(importParameters, sectionPart, configPart, configParameters);
                    break;
                }
                case types_1.SectionTypeV2.Section:
                case types_1.SectionTypeV2.SectionAddress:
                case types_1.SectionTypeV2.SubSectionAddress:
                case types_1.SectionTypeV2.SectionContact:
                case types_1.SectionTypeV2.SubSectionContact:
                case types_1.SectionTypeV2.SubSection:
                case types_1.SectionTypeV2.HeaderSection: {
                    // Section with subsections
                    sectionPart.schema = appSchemaDefinitions[`${sectionPart.type}<${sectionId}>`];
                    fillSubSection(importParameters, sectionPart, manifestSettings, configPart, configParameters);
                    break;
                }
                case types_1.SectionTypeV2.HeaderSectionAddress:
                case types_1.SectionTypeV2.HeaderSectionChart:
                case types_1.SectionTypeV2.HeaderSectionDataPoint:
                case types_1.SectionTypeV2.HeaderSectionForm: {
                    // Header Section
                    sectionPart.schema = appSchemaDefinitions[`${sectionPart.type}<${sectionId}>`];
                    fillHeaderSection(importParameters, sectionPart, configPart, configParameters);
                    break;
                }
            }
        }
        else if (sectionPart.schema.properties?.['subsections']) {
            sectionPart.schema = appSchemaDefinitions[`${sectionPart.type}<${sectionId}>`];
            fillSubSection(importParameters, sectionPart, manifestSettings, configPart, configParameters);
        }
    }
}
/**
 * Fills the custom sections in the v2 object page config
 * @param {object} customSections - list of custom sections, as defined in manifest
 * @param {ObjectPageConfig} objectPageConfig - the object page configuration (JSON)
 * @param {ObjectPageV2ConfigParameters} configParameters - object comprising input for filling the config
 * @param schemaDefinitions - definitions in the object page schema
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising API input data
 */
function fillCustomSectionsInConfig(customSections, objectPageConfig, configParameters, schemaDefinitions, importParameters) {
    if (Object.keys(customSections).length > 0) {
        objectPageConfig.sections.custom = [];
        for (const sectionId in customSections) {
            const customSection = 'fragmentName' in customSections[sectionId]
                ? configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, 'ObjectPageCustomSectionFragment')
                : configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, 'ObjectPageCustomSectionView');
            const customSectionDefinition = schemaDefinitions['fragmentName' in customSections[sectionId]
                ? 'ObjectPageCustomSectionFragment'
                : 'ObjectPageCustomSectionView'];
            transferSettingsAndFlexChanges(importParameters, customSection, customSectionDefinition, configParameters, { id: sectionId });
            objectPageConfig.sections.custom.push(customSection);
        }
    }
}
/**
 * Fill properties of object page confg based on manifest settings
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising API input data
 * @param {ObjectPageV2ConfigParameters} configParameters - object comprising input for filling the config
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @returns {ObjectPageConfig} - the object page configuration (JSON)
 */
function fillConfig(importParameters, configParameters) {
    const objectPageConfig = configParameters.factory.createPageInstance(ux_specification_types_1.PageTypeV2.ObjectPage);
    // Transfer page information
    transferSettingsAndFlexChanges(importParameters, objectPageConfig, importParameters.jsonSchema['properties'], configParameters);
    // Transfer global table settings
    objectPageConfig.globalTableSettings = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, ux_specification_types_1.DefinitionName.GlobalTableSettings);
    const definitions = importParameters.jsonSchema.definitions;
    transferSettingsAndFlexChanges(importParameters, objectPageConfig.globalTableSettings, definitions[ux_specification_types_1.DefinitionName.GlobalTableSettings], configParameters);
    if (Object.keys(objectPageConfig.globalTableSettings).length === 0) {
        delete objectPageConfig.globalTableSettings;
    }
    // Transfer header information
    objectPageConfig.header = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, ux_specification_types_1.DefinitionName.ObjectPageHeader);
    const schemaDefinition = definitions[ux_specification_types_1.DefinitionName.ObjectPageHeader]
        ? definitions[ux_specification_types_1.DefinitionName.ObjectPageHeader]
        : definitions['ObjectPageHeader<GenericActions>'];
    transferSettingsAndFlexChanges(importParameters, objectPageConfig.header, schemaDefinition, configParameters);
    const headerAction = definitions[ux_specification_types_1.DefinitionName.ObjectPageHeaderActions];
    if (headerAction) {
        fillActions(importParameters, headerAction.properties, objectPageConfig.header, configParameters, types_1.ActionTypeV2.OPHeader);
    }
    objectPageConfig.footer = {};
    const footerAction = definitions[ux_specification_types_1.DefinitionName.FooterActions];
    if (footerAction) {
        fillActions(importParameters, footerAction.properties, objectPageConfig.footer, configParameters, types_1.ActionTypeV2.OPFooter);
    }
    // Transfer Layout information
    objectPageConfig.layout = configParameters.factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, 'ObjectPageLayout');
    transferSettingsAndFlexChanges(importParameters, objectPageConfig.layout, definitions[ux_specification_types_1.DefinitionName.ObjectPageLayout], configParameters);
    if (Object.keys(objectPageConfig.layout).length === 0) {
        delete objectPageConfig.layout;
    }
    // Fill header sections and subsections
    objectPageConfig.header.sections = {};
    const headerSections = definitions[ux_specification_types_1.DefinitionName.HeaderSections];
    if (headerSections) {
        const manifestSettings = configParameters.v2Page.component?.settings;
        fillSectionsInConfig(importParameters, headerSections.properties, manifestSettings, objectPageConfig.header.sections, configParameters);
    }
    if (Object.keys(objectPageConfig.header.sections).length === 0) {
        delete objectPageConfig.header.sections;
    }
    // Fill sections and subsections
    objectPageConfig.sections = {};
    const sections = definitions[ux_specification_types_1.DefinitionName.Sections];
    if (sections) {
        const manifestSettings = configParameters.v2Page.component?.settings;
        fillSectionsInConfig(importParameters, sections.properties, manifestSettings, objectPageConfig.sections, configParameters);
    }
    // Find custom sections
    const customSections = (0, utils_1.findCustomSectionExtensions)(importParameters.manifest, importParameters.entitySet);
    fillCustomSectionsInConfig(customSections, objectPageConfig, configParameters, definitions, importParameters);
    return objectPageConfig;
}
/**
 * Creates the configuration (file content) for a V2 object page
 * @param {ImportObjectPageV2Parameters} importParameters  - object comprising all input data
 *
 * @returns {ObjectPageConfig} - the object page configuration (JSON)
 */
function createObjectPageConfigV2(importParameters) {
    // Initialize i18next
    (0, i18n_1.initI18n)();
    const v2Pages = (0, utils_1.getV2Pages)(importParameters);
    if (!v2Pages) {
        return;
    }
    const entitySet = importParameters.entitySet;
    const pageKeys = [];
    const v2Page = (0, utils_1.findObjectPageV2)(v2Pages, importParameters.entitySet, pageKeys);
    (0, utils_1.checkV2Page)(v2Page, importParameters.logger, entitySet);
    if (!v2Page) {
        return;
    }
    const flexChangesForTransfer = prepareFlexChanges(importParameters.flex, entitySet);
    const factory = new factory_1.MetadataInstanceFactoryV2();
    //Fill config.json with manifest settings and flex changes
    return fillConfig(importParameters, { pageKeys, flexChanges: flexChangesForTransfer, v2Page, factory });
}
exports.createObjectPageConfigV2 = createObjectPageConfigV2;
//# sourceMappingURL=objectPage.js.map