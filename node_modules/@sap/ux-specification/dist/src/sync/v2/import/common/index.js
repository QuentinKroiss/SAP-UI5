"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importHeaderActions = exports.addFragments = exports.determineTableType = exports.transferSettingsOfObject = exports.addFlex = exports.convertSelector = exports.convertActionKey = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const table_1 = require("../controls/table");
const common_1 = require("../../../common");
const decorators_1 = require("../../../common/decoration/decorators");
const manifest_1 = require("../../export/manifest");
const extensionLogger_1 = require("../../../../extensionLogger");
const i18next_1 = __importDefault(require("i18next"));
const xml_js_1 = require("xml-js");
const controls_1 = require("../../export/controls");
const types_1 = require("../../types");
function convertActionKey(actionProperty) {
    return actionProperty.replace('/', '::');
}
exports.convertActionKey = convertActionKey;
/**
 * Unescapes the selector ID of a flex change
 * @param selectorId - escaped selector ID
 * @returns unescaped ID
 */
function convertSelector(selectorId) {
    return selectorId.replace(/:2f/g, '/').replace(/:23/g, '#').replace(/:40/g, '@');
}
exports.convertSelector = convertSelector;
/**
 * Adds flex changes to Smart Filter Bar in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changePropertyKey - property key of current change
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addSmartFilterBarFlex(config, changePropertyKey, change, jsonSchema) {
    const schemaProperty = jsonSchema['definitions']?.['ListReportFilterBar']?.properties[changePropertyKey] ||
        jsonSchema['definitions']?.['AnalyticalListPageFilterBar']?.properties[changePropertyKey];
    if (schemaProperty) {
        config.filterBar[changePropertyKey] = change.content.newBinding
            ? change.content.newBinding
            : change.content.newValue;
    }
}
/**
 * Creates a map to connect action types to the correct schema definition and config part
 * @param definitionType action type that will be filtered for
 * @param jsonSchema application specific schema
 * @returns {Map} actionMap - mapping of actionId, id for schema reference and id for config
 */
function filterActions(definitionType, jsonSchema) {
    const actions = Object.keys(jsonSchema['definitions']).filter((definition) => definition.startsWith(`${definitionType}`) && definition.includes('<'));
    const actionMap = new Map();
    actions.forEach((definitionActionId) => {
        const fullActionId = (0, common_1.convertActionKeyToStableId)(definitionActionId.split('<')[1]?.split('>')[0]);
        const splitPoint = fullActionId.indexOf(':::');
        if (fullActionId.startsWith('DataField') && splitPoint > -1) {
            const actionIdParts = fullActionId.split(':::');
            const sSemanticObject = actionIdParts.find((part) => part.startsWith('sSemanticObject'));
            const sAction = actionIdParts.find((part) => part.startsWith('sAction'));
            const shortAction = sAction.split('sAction::')[1].replace(':2f', '::');
            if (sSemanticObject) {
                const shortActionId = `${sSemanticObject.split('::')[1]}::${shortAction}`;
                const shortDefinitionActionId = `${actionIdParts[0]}:::${sSemanticObject}:::${sAction}`;
                actionMap.set(shortActionId, definitionActionId);
                actionMap.set(definitionActionId, shortDefinitionActionId);
            }
            else {
                actionMap.set(shortAction, definitionActionId);
                actionMap.set(definitionActionId, fullActionId);
            }
        }
        else {
            actionMap.set(fullActionId.replace(':2f', '::'), definitionActionId);
            actionMap.set(definitionActionId, fullActionId);
        }
    });
    return actionMap;
}
/**
 * Adds a new action column to config
 * @param action - action part of config to be filled
 * @param config - the config of ALP/LR
 * @param configId - id of action to be used in config
 */
function addColumnActionConfigPart(action, config, configId) {
    if (!action.configPart) {
        action.configPart = config.table.columns = {};
    }
    if (!action.configPart[`${configId}`]) {
        action.configPart[`${configId}`] = {};
    }
}
/**
 * Return action id of change
 * @param {ChangeDefinition} change - change definition
 * @returns {string} action id
 */
function getActionId(change) {
    if (change.controlId?.includes('--template::')) {
        return change.controlId.split('--template::')[1];
    }
    return change.controlId?.split('--action::')[1];
}
/**
 * Adds flex changes to Actions in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changePropertyKey - property key of current change
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addActionFlex(config, changePropertyKey, change, jsonSchema, id) {
    const actionTypes = [
        { name: types_1.ActionTypeV2.HeaderStandard, configPart: config.header.actions, id },
        { name: types_1.ActionTypeV2.OPHeaderStandard, configPart: config.header.actions, id },
        {
            name: types_1.ActionTypeV2.Footer,
            configPart: config.footer.actions,
            id: id && id.includes('Determining') && id.split('::Determining')[0]
        },
        { name: types_1.ActionTypeV2.OPFooterStandard, configPart: config.footer.actions, id },
        { name: types_1.ActionTypeV2.ToolBar, configPart: config.table.toolBar.actions, id },
        { name: types_1.ActionTypeV2.Column, configPart: config.table.columns, id }
    ];
    actionTypes.forEach((action) => {
        const schemaActions = filterActions(action.name, jsonSchema);
        if (schemaActions.has(action.id)) {
            const referenceId = schemaActions.get(action.id);
            const configId = referenceId.split('<')[1]?.split('>')[0];
            if (action.name === types_1.ActionTypeV2.Column) {
                addColumnActionConfigPart(action, config, configId);
            }
            const configPart = action.configPart[configId];
            const schemaProperty = jsonSchema.definitions[referenceId]?.properties[changePropertyKey];
            if (schemaProperty && configPart) {
                configPart[changePropertyKey] = change.content.newBinding
                    ? change.content.newBinding
                    : change.content.newValue;
            }
        }
    });
}
/**
 * Adds flex changes to Smart Chart in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changePropertyKey - property key of current change
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addSmartChartFlex(config, changePropertyKey, change, jsonSchema) {
    const schemaProperty = jsonSchema['definitions']['ChartSettings'].properties[changePropertyKey];
    if (schemaProperty) {
        const syncRule = (0, decorators_1.getReflectMetadata)(config[ux_specification_types_1.PropertyName.chart], changePropertyKey);
        if (syncRule?.flex?.importFlexValue) {
            syncRule.flex.importFlexValue(change, config[ux_specification_types_1.PropertyName.chart], changePropertyKey);
        }
        else {
            config[ux_specification_types_1.PropertyName.chart][changePropertyKey] = change.content.newBinding
                ? change.content.newBinding
                : change.content.newValue;
        }
    }
}
/**
 * Checks and adds further flex changes to in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addAdditionalFlexChanges(config, change, jsonSchema) {
    const flexForTransfer = {
        controlId: change.controlId,
        propertyId: change.content.property,
        newValue: change.content.newBinding ? change.content.newBinding : change.content.newValue,
        controlType: change.controlType,
        creation: change.creation
    };
    let constructorName;
    if ((!config.table.type || config.table.type === ux_specification_types_1.v2.TableTypeV2.ResponsiveTable) &&
        !flexForTransfer.controlId?.includes(ux_specification_types_1.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP.get(ux_specification_types_1.PageTypeV2.AnalyticalListPage))) {
        constructorName = 'ResponsiveTableWithMultiSelect';
    }
    else {
        constructorName = config.table.constructor.name;
    }
    const schemaProperty = jsonSchema['definitions'][`${constructorName}<LineItems>`].properties[flexForTransfer.propertyId];
    if (schemaProperty || flexForTransfer.controlType === ux_specification_types_1.ControlType.TableColumn) {
        (0, table_1.addFlexForTable)(config.table, flexForTransfer, jsonSchema);
    }
}
/**
 * Adds flex changes to config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changeString - change file as string
 * @param {object} appSchema - application specific schema
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addFlex(config, changeString, appSchema, logger) {
    try {
        const change = (0, common_1.parseChangeString)(changeString);
        const changePropertyKey = change.content.property;
        if (change.controlId?.includes(ux_specification_types_1.PageTypeV2.ListReport) ||
            change.controlId?.includes(ux_specification_types_1.PageTypeV2.AnalyticalListPage)) {
            change.controlId = convertSelector(change.controlId);
            switch (change.controlType) {
                case ux_specification_types_1.ControlType.SmartFilterBar: {
                    addSmartFilterBarFlex(config, changePropertyKey, change, appSchema);
                    break;
                }
                case ux_specification_types_1.ControlType.DynamicPage: {
                    const schemaProperty = appSchema['properties'][changePropertyKey];
                    if (schemaProperty) {
                        config[change.content.property] = change.content.newValue;
                    }
                    break;
                }
                case ux_specification_types_1.ControlType.Button: {
                    const actionId = getActionId(change);
                    actionId && addActionFlex(config, changePropertyKey, change, appSchema, actionId);
                    break;
                }
                case ux_specification_types_1.ControlType.SmartChart: {
                    addSmartChartFlex(config, changePropertyKey, change, appSchema);
                    break;
                }
                default: {
                    addAdditionalFlexChanges(config, change, appSchema);
                    break;
                }
            }
        }
    }
    catch (error) {
        (0, extensionLogger_1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('FLEXERROR')
        }, ...error);
    }
}
exports.addFlex = addFlex;
/**
 * Special post-processing for quickVariantSelectionX during the import
 * @param propertyKey - key of the current schema property
 * @param configPart  - part of the configuration to be enhanced
 */
function adjustQuickVariantSelectionX(propertyKey, configPart) {
    if (propertyKey === 'quickVariantSelectionX' && configPart[propertyKey]) {
        for (const variant in configPart[propertyKey]['variants']) {
            const currentQuickVariantX = configPart[propertyKey]['variants'][variant];
            if (currentQuickVariantX['tableSettings']) {
                for (const key in currentQuickVariantX['tableSettings']) {
                    currentQuickVariantX[key] = currentQuickVariantX['tableSettings'][key];
                }
                delete currentQuickVariantX['tableSettings'];
            }
        }
    }
}
/**
 * Transfers settings from manifest to object page config
 * @param configPart - part of the configuration to be filled
 * @param manifest - manifest.json of the app
 * @param appSchema - app specific schema
 * @param pageID - ID of the given object page
 * @param sectionId (optional) - ID of the given section (optional)
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function transferSettingsOfObject(configPart, manifest, appSchema, pageKey, logger, kpiKey) {
    if (!appSchema) {
        return;
    }
    let manifestSection = {};
    const deprecatedProperties = configPart.getDeprecated ? configPart.getDeprecated() : undefined;
    if (appSchema['properties']) {
        for (const propertyKey in appSchema['properties']) {
            const syncRule = (0, decorators_1.getReflectMetadata)(configPart, propertyKey);
            if (syncRule?.manifest) {
                const path = syncRule.manifest.path([pageKey], manifest, kpiKey);
                manifestSection = (0, manifest_1.ensureManifestSectionByPathV2)(manifest, path);
                (0, common_1.importProperty)(syncRule, manifestSection, propertyKey, configPart);
                (0, common_1.checkDeprecatedProperties)(deprecatedProperties, manifestSection, path, logger);
            }
            // Adjustment of 'quickVariantSelectionX' - tableSettings
            adjustQuickVariantSelectionX(propertyKey, configPart);
        }
    }
}
exports.transferSettingsOfObject = transferSettingsOfObject;
/**
 * Determines the table type for a given LR or ALP table, based on the component name and its table settings
 * This does not exactly reflect the run time behavior of Fiori elements but a best guess and expectation.
 * @param manifest - manifest.json file content of the app
 * @param pageKey - key of the page in the manifest
 */
function determineTableType(manifest, pageKey) {
    const page = manifest[ux_specification_types_1.ManifestSection.generic].pages[pageKey];
    let tableType = ux_specification_types_1.v2.TableTypeV2.ResponsiveTable;
    if (manifest[ux_specification_types_1.ManifestSection.generic].pages[pageKey].component?.settings &&
        (manifest[ux_specification_types_1.ManifestSection.generic].pages[pageKey].component.settings?.tableSettings?.['type'] ||
            manifest[ux_specification_types_1.ManifestSection.generic].pages[pageKey].component.settings?.['tableType'])) {
        tableType = page.component?.settings?.tableSettings?.['type'] || page.component?.settings['tableType'];
    }
    else if (page.component?.name === 'sap.suite.ui.generic.template.AnalyticalListPage') {
        tableType = ux_specification_types_1.v2.TableTypeV2.AnalyticalTable;
    }
    return tableType;
}
exports.determineTableType = determineTableType;
function evaluateFragmentColumn(column, viewExtensionsOfPage, manifestKey, keyPart3, config, extensionType, cellsFragmentName) {
    if (column['customData'] || column['table:customData']) {
        const p13nData = column['customData']
            ? column['customData']['core:CustomData']._attributes.value
            : column['table:customData']['core:CustomData']._attributes.value;
        const columnParts = JSON.parse(p13nData.substr(1, p13nData.length));
        let columnText = column['Text'] && column['Text']._attributes && column['Text']._attributes['text'];
        if (!columnText) {
            columnText = column['Label'] && column['Label']._attributes && column['Label']._attributes['text'];
        }
        const customElement = {
            id: column._attributes && column._attributes['id'],
            text: columnText,
            ...columnParts,
            columnKey: columnParts['columnKey'],
            columnIndex: columnParts['columnIndex'] !== undefined ? Number(columnParts['columnIndex']) : undefined,
            leadingProperty: columnParts['leadingProperty'],
            className: viewExtensionsOfPage[manifestKey].className,
            fragmentName: viewExtensionsOfPage[manifestKey].fragmentName,
            tabKey: keyPart3,
            extensionType
        };
        if (cellsFragmentName) {
            customElement.cellsFragmentName = cellsFragmentName;
        }
        if (!config.table['columns']['custom']) {
            config.table['columns']['custom'] = [];
        }
        const customColumns = config.table['columns']['custom'];
        customColumns.push(customElement);
    }
}
function determineCellsFragmentName(extensionType, viewExtensionsOfPage, keyEntitySet, referenceId) {
    let cellsFragmentName;
    if (extensionType === ux_specification_types_1.ViewTemplateType.ResponsiveTableColumnsExtension) {
        for (const cellsKey of Object.keys(viewExtensionsOfPage)) {
            const [cellsKeyType, cellsKeyEntitySet, cellsKeyTab] = cellsKey.split('|');
            if (cellsKeyType === ux_specification_types_1.ViewTemplateType.ResponsiveTableCellsExtension &&
                cellsKeyEntitySet === keyEntitySet &&
                cellsKeyTab === referenceId) {
                cellsFragmentName = viewExtensionsOfPage[cellsKey].fragmentName;
            }
        }
    }
    return cellsFragmentName;
}
function analyzeFilteredFragments(filteredFragments, config, viewExtensionsOfPage, manifestKey, keyTab, extensionType, cellsFragmentName) {
    if (filteredFragments[0]) {
        const fragmentJson = JSON.parse((0, xml_js_1.xml2json)(filteredFragments[0].fileContent, { compact: true }));
        const fragmentDefintion = fragmentJson[controls_1.FRAGMENT_DEFINITION];
        const columnDefinition = (0, controls_1.getRootCustomColumnFromFragmentJSON)(fragmentDefintion);
        if (columnDefinition) {
            if (!config[ux_specification_types_1.PropertyName.table]?.['columns']) {
                config[ux_specification_types_1.PropertyName.table]['columns'] = {};
            }
            if (Array.isArray(columnDefinition)) {
                for (const def of columnDefinition) {
                    evaluateFragmentColumn(def, viewExtensionsOfPage, manifestKey, keyTab, config, extensionType, cellsFragmentName);
                }
            }
            else {
                evaluateFragmentColumn(columnDefinition, viewExtensionsOfPage, manifestKey, keyTab, config, extensionType, cellsFragmentName);
            }
        }
    }
}
function processViewExtensions(viewExtensionsOfPage, targetKeyEntitySet, objectPageSectionData, config, fragments) {
    for (const manifestKey of Object.keys(viewExtensionsOfPage)) {
        const manifestKeyParts = manifestKey.split('|');
        const [keyExtensionType, keyEntitySet] = manifestKeyParts;
        // If Object Page section have key, then Ignore it as it is not from QuickVariantSelectionX
        const referenceId = manifestKeyParts[2];
        const keyTab = objectPageSectionData && referenceId === objectPageSectionData.key ? undefined : referenceId;
        const extensionType = ux_specification_types_1.ViewTemplateType[keyExtensionType];
        if (extensionType && '|' + keyEntitySet === targetKeyEntitySet) {
            const fragmentType = viewExtensionsOfPage[manifestKey].type
                ? viewExtensionsOfPage[manifestKey].type.toLowerCase()
                : 'xml';
            let fragmentName = viewExtensionsOfPage[manifestKey].fragmentName;
            if (!fragmentName) {
                continue;
            }
            // Responsive Table ==> check cells' fragment name
            const cellsFragmentName = determineCellsFragmentName(extensionType, viewExtensionsOfPage, keyEntitySet, referenceId);
            // Retrieve information from fragment
            const fragmentParts = fragmentName.split('.');
            fragmentName = fragmentParts[fragmentParts.length - 1] + ux_specification_types_1.FRAGMENTNAMEPART + fragmentType;
            const filteredFragments = fragments.filter((fragment) => fragment['dataSourceUri'].endsWith(fragmentName));
            analyzeFilteredFragments(filteredFragments, config, viewExtensionsOfPage, manifestKey, keyTab, extensionType, cellsFragmentName);
        }
    }
}
/**
 * Adds custom column information from manifest and fragments to the configuration
 * @param config - configuration, to be enhanced
 * @param manifest - actual manifest.json
 * @param v2Page - actual page in the manifest
 * @param pageType - type of the page
 * @param fragments - list of all fragments
 * @param objectPageSectionData - optional information, for object page
 */
function addFragments(config, manifest, v2Page, pageType, fragments, objectPageSectionData) {
    if (!fragments) {
        return;
    }
    const targetKeyEntitySet = '|' + (objectPageSectionData && objectPageSectionData.target ? objectPageSectionData.target : v2Page.entitySet);
    if (manifest[ux_specification_types_1.ManifestSection.ui5] &&
        manifest[ux_specification_types_1.ManifestSection.ui5]['extends'] &&
        manifest[ux_specification_types_1.ManifestSection.ui5]['extends']['extensions'] &&
        manifest[ux_specification_types_1.ManifestSection.ui5]['extends']['extensions']['sap.ui.viewExtensions']) {
        const viewExtension = ux_specification_types_1.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP.get(pageType);
        const viewExtensionsOfPage = manifest[ux_specification_types_1.ManifestSection.ui5]['extends']['extensions']['sap.ui.viewExtensions'][viewExtension];
        if (!viewExtensionsOfPage) {
            return;
        }
        processViewExtensions(viewExtensionsOfPage, targetKeyEntitySet, objectPageSectionData, config, fragments);
    }
}
exports.addFragments = addFragments;
/**
 * Prepares header standard actions information for LR/ALP config
 * @param {ListReportConfig} listReportConfig - LR config, to be filled
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param {Definition} schemaDefinitions - app schema definitions
 */
function importHeaderActions(listReportConfig, factory, schemaDefinitions) {
    listReportConfig.header = { actions: {} };
    if (schemaDefinitions[ux_specification_types_1.DefinitionName.HeaderActionsStandard]) {
        const headerActions = schemaDefinitions[ux_specification_types_1.DefinitionName.HeaderActionsStandard].properties;
        for (const actionKey in headerActions) {
            listReportConfig.header.actions[actionKey] = factory.createInstance(ux_specification_types_1.PageTypeV2.ListReport, actionKey, {});
        }
    }
}
exports.importHeaderActions = importHeaderActions;
//# sourceMappingURL=index.js.map