"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateObjectPageSchemaV2 = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const common_1 = require("../../common");
const utils_1 = require("./utils");
const import_1 = require("../import");
const extensionLogger_1 = require("../../../extensionLogger");
const i18next_1 = __importDefault(require("i18next"));
const i18n_1 = require("../../../i18n/i18n");
const types_1 = require("../types");
const StableIdHelper_1 = require("../../v4/utils/StableIdHelper");
const ROOT_PROPERTIES_ORDER = ['header', 'sections', 'footer'];
/**
 * Adds flexChange properties for sub(sections)
 * @param appSchema - app schema in general
 * @param schemaSection - current section
 * @param property - property that will be enhanced
 * @param sectionType - type of section
 */
function addFlexChangeForSection(appSchema, schemaSection, property, sectionType) {
    schemaSection.properties[property][ux_specification_types_1.SchemaTag.artifactType] = ux_specification_types_1.ArtifactType.FlexChange;
    let controlType;
    switch (sectionType) {
        case types_1.SectionTypeV2.Section:
        case types_1.SectionTypeV2.SectionForm:
        case types_1.SectionTypeV2.SectionChart:
        case types_1.SectionTypeV2.SectionTable:
            controlType = ux_specification_types_1.ControlType.Section;
            break;
        case types_1.SectionTypeV2.SubSection:
            controlType = ux_specification_types_1.ControlType.SubSection;
            break;
        case types_1.SectionTypeV2.SubSectionForm:
            controlType = ux_specification_types_1.ControlType.Group;
            break;
        case types_1.SectionTypeV2.SubSectionChart:
            controlType = ux_specification_types_1.ControlType.SmartChart;
            break;
        case types_1.SectionTypeV2.SubSectionTable:
            controlType = ux_specification_types_1.ControlType.SmartTable;
            break;
        case types_1.SectionTypeV2.HeaderSection:
        case types_1.SectionTypeV2.HeaderSectionAddress:
        case types_1.SectionTypeV2.HeaderSectionChart:
        case types_1.SectionTypeV2.HeaderSectionDataPoint:
        case types_1.SectionTypeV2.HeaderSectionForm:
            controlType = ux_specification_types_1.ControlType.ObjectPageHeaderSection;
            break;
    }
    if (!controlType) {
        return;
    }
    (0, common_1.addPatternForBindingChangeOfEnumOP)(appSchema, schemaSection, property);
    schemaSection.properties[property][ux_specification_types_1.SchemaTag.controlType] = controlType;
}
/**
 * Callback for adding a single action to headerActions of V2
 * @param {EntityType} entityType - current entity type
 * @param {object} appSchema Schema of the app
 * @param actionAnnotation - annotation as present in AVT ConvertedMetadata
 * @param headerActions - list of header actions, to be enhanced
 */
function addHeaderActionCallBackV2(entityType, appSchema, identification, headerActions, oDataServiceAVT) {
    identification?.forEach((item) => {
        if (!item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */) {
            const { actionName, actionId, namespace } = (0, common_1.getActionNameAndId)(item, oDataServiceAVT);
            //actionId is used as key in V2, as this is the right part for building the full stable ID
            if (!actionId) {
                return;
            }
            const description = item.Label || actionName;
            const actionDefinitionKey = `ObjectPageHeaderAction<${(0, common_1.prepareRef)(actionId)}>`;
            appSchema.definitions[actionDefinitionKey] = JSON.parse(JSON.stringify(appSchema.definitions['ObjectPageHeaderAction']));
            const convertedIdentification = item.fullyQualifiedName.replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`);
            appSchema.definitions[actionDefinitionKey][ux_specification_types_1.SchemaTag.annotationPath] = `/${convertedIdentification}`;
            appSchema.definitions[actionDefinitionKey][ux_specification_types_1.SchemaTag.actionType] = ux_specification_types_1.ActionType.Annotation;
            appSchema.definitions[actionDefinitionKey].description = description;
            appSchema.definitions[actionDefinitionKey][ux_specification_types_1.SchemaTag.keys] = [
                { name: ux_specification_types_1.SchemaKeyName.action, value: actionName }
            ];
            if (namespace) {
                appSchema.definitions[actionDefinitionKey][ux_specification_types_1.SchemaTag.target] = namespace;
            }
            headerActions.properties[actionId] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
            };
        }
    });
}
/**
 * Callback for adding a single action to footerActions of V2
 * @param {EntityType} entityType - current entity type
 * @param {Definition} appSchema Schema of the app
 * @param {Definition} footerActions - list of footer actions, to be enhanced
 * @param {String} identification - converted UI.Identification term
 */
function addFooterActionCallBackV2(entityType, appSchema, footerActions, identification) {
    identification.forEach((item) => {
        if (item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */) {
            const actionId = (0, StableIdHelper_1.getStableIdPartFromDataField)(item).split('::').splice(1).join('::');
            const description = (0, common_1.getDataFieldDescription)(item, entityType);
            const actionDefinitionKey = (0, common_1.prepareRef)(`${ux_specification_types_1.DefinitionName.ObjectPageFooterAction}<${actionId}>`);
            const convertedIdentification = item.fullyQualifiedName.replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`);
            appSchema.definitions[actionDefinitionKey] = {
                ...JSON.parse(JSON.stringify(appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageFooterAction])),
                description,
                annotationPath: `/${convertedIdentification}`
            };
            footerActions.properties[actionId] = {
                $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
            };
        }
    });
}
/**
 * Method ensures that definitions for custom columns are created for passed entitySet.
 * @param {object} appSchema App schema in general
 * @param {object} manifest manifest.json of the app
 * @param {string} entitySetName Entity set name.
 * @param {string} entityTypeName Entity type name.
 * @param {ConvertedMetadata} oDataServiceAVT Complete service information, as returned by annotation vocabularies tool
 * @param {FacetConfig} facet information
 * @param {string} facetKey - key of the facet, as listed in FacetConfigs
 * @param {FileData[]} [fragments] Array with XML fragments.
 * @return {string} Name of custom columns definition.
 */
function ensureCustomColumnDefinitionExists(appSchema, manifest, entitySetName, entityTypeName, oDataServiceAVT, facet, facetKey, fragments) {
    let suffix, customColumnsDefinitionName;
    if (facet.ID && facet.Label) {
        suffix = facet.ID + facet.Label.replace(/\s+/g, '');
    }
    else if (facet.ID) {
        suffix = facet.ID;
    }
    else if (facet.Label) {
        suffix = facet.Label.replace(/\s+/g, '');
    }
    if (suffix) {
        customColumnsDefinitionName = `${ux_specification_types_1.DefinitionName.CustomColumns}<${entitySetName}><${facetKey}><${suffix}>`;
    }
    else {
        customColumnsDefinitionName = `${ux_specification_types_1.DefinitionName.CustomColumns}<${entitySetName}><${facetKey}>`;
    }
    if (appSchema.definitions[customColumnsDefinitionName]) {
        // Definition is already created - we do not need to create it again
        return customColumnsDefinitionName;
    }
    // Create type specific 'TableCustomColumn' definition - use entity set as type.
    const customColumnDefinitionName = `${ux_specification_types_1.DefinitionName.CustomColumn}<${entitySetName}>`;
    const customColumnDefinition = JSON.parse(JSON.stringify(appSchema.definitions['TableCustomColumn']));
    appSchema.definitions[customColumnDefinitionName] = customColumnDefinition;
    // Update definitions for type specific custom columns
    const pageKeys = [];
    const entityType = oDataServiceAVT?.entityTypes.find((et) => et.name === entityTypeName);
    const v2Page = (0, import_1.findObjectPageV2)(manifest[ux_specification_types_1.ManifestSection.generic].pages, entitySetName, pageKeys);
    (0, utils_1.addTableColumnExtensions)(appSchema, entityType, v2Page, manifest, fragments, customColumnsDefinitionName, customColumnDefinitionName, facet.ID);
    return customColumnsDefinitionName;
}
/**
 * Method fills new app schema section with properties.
 * @param {Definition} appSchema App schema in general
 * @param {object} appSchemaSection app schema section to be filled
 * @param {SectionTypeV2} sectionType (sub)section type
 * @param {SectionTypeV2} mainSectionType main section type, used to fill app schema section
 */
function addAppSchemaDefinition(appSchema, appSchemaSection, sectionType, mainSectionType) {
    appSchemaSection.properties = JSON.parse(JSON.stringify(appSchema.definitions[mainSectionType].properties));
    if (appSchemaSection.properties.visible) {
        addFlexChangeForSection(appSchema, appSchemaSection, 'visible', sectionType);
    }
}
/**
 * Method adds reference to section property key.
 * @param {object} sections - schema of current sections definition
 * @param {string} key section key which will contain the reference
 * @param {string} definitionKey key which the section should point to
 */
function addSectionReference(sections, key, definitionKey) {
    sections.properties[key] = { $ref: `${common_1.DEFINITION_LINK_PREFIX}${definitionKey}` };
}
/**
 * Reuse function for all table types, copies and adapts the generic definition
 * @param tableType - Table type
 * @param facetId - facet ID, as derived for the given section
 * @param facet - facet or section information
 * @param appSchema - app-specific schema, to be updated
 */
function addTableDefinition(tableType, facetId, facet, appSchema) {
    const schemaId = (0, common_1.prepareRef)(`${tableType}<${facetId}>`);
    appSchema.definitions[schemaId] = JSON.parse(JSON.stringify(appSchema.definitions[tableType]));
    appSchema.definitions[schemaId]['properties']['columns']['$ref'] = common_1.DEFINITION_LINK_PREFIX + facetId;
    appSchema.definitions[schemaId].properties.toolBar['$ref'] =
        `${common_1.DEFINITION_LINK_PREFIX}ObjectPageToolBar<${facetId}>`;
    appSchema.definitions[schemaId][ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    if (facet.ID !== undefined) {
        appSchema.definitions[schemaId].title = ux_specification_types_1.FacetTitlePrefix + facet.ID;
        appSchema.definitions[schemaId][ux_specification_types_1.SchemaTag.keys] = [{ name: `ID`, value: facet.ID }];
    }
    appSchema.definitions[schemaId].description = ux_specification_types_1.DefinitionName.Table;
    //adjust quickVariantSelection
    appSchema.definitions[schemaId].properties['quickVariantSelection']['$ref'] =
        `${common_1.DEFINITION_LINK_PREFIX}QuickVariantSelectionOP<${facetId}>`;
    appSchema.definitions[`QuickVariantSelectionOP<${facetId}>`] = JSON.parse(JSON.stringify(appSchema.definitions['QuickVariantSelectionOP']));
    appSchema.definitions[`QuickVariant<${facetId}>`] = JSON.parse(JSON.stringify(appSchema.definitions['QuickVariant']));
    appSchema.definitions[`QuickVariantSelectionOP<${facetId}>`].properties.variants.patternProperties['^[0-9]+$']['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}QuickVariant<${facetId}>`;
    (0, common_1.addEnumForSingleTabVariant)(facet.entityType, appSchema, `QuickVariant<${facetId}>`);
}
/**
 * Adds definitions for line items in object page sections to the app schema
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {string} facetKey - key of the facet, as listed in FacetConfigs
 * @param {Definition} appSchema - app schema in general
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {FacetConfigs} facets - list of all facets
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleLineItem(generateParameters, facetKey, appSchema, facet, facets, sectionType) {
    if (facet.base !== ux_specification_types_1.FacetBase.LineItem || !facetKey) {
        //no properties
        return;
    }
    const navigationProperty = facetKey.split('::')[0];
    const schemaIdForOpSection = `${sectionType}<${facetKey}>`;
    appSchema.definitions[schemaIdForOpSection] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey);
    const appSchemaSection = appSchema.definitions[schemaIdForOpSection];
    addAppSchemaDefinition(appSchema, appSchemaSection, sectionType, types_1.SectionTypeV2.SectionTable);
    appSchemaSection.properties.table = JSON.parse(JSON.stringify(appSchema.definitions[types_1.SectionTypeV2.SectionTable]['properties'][ux_specification_types_1.PropertyName.table]));
    appSchemaSection.properties.table.anyOf = [
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithMultiSelect<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageResponsiveTableWithInlineDelete<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageAnalyticalTable<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageGridTable<${facetKey}>`
        },
        {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}ObjectPageTreeTable<${facetKey}>`
        }
    ];
    appSchemaSection[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    (0, common_1.addSectionTitleAndDescription)(facet, appSchemaSection, facetKey);
    addTableDefinition('ObjectPageResponsiveTableWithMultiSelect', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageResponsiveTableWithInlineDelete', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageGridTable', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageTreeTable', facetKey, facet, appSchema);
    addTableDefinition('ObjectPageAnalyticalTable', facetKey, facet, appSchema);
    let customColumnDefinitionKey;
    // Find target entity
    const targetEntitySet = (0, common_1.determineEntitySetOfEntityType)(facet.entityType, generateParameters.serviceAVT);
    if (targetEntitySet) {
        // Make sure that custom columns definitions are created for passed entity
        customColumnDefinitionKey = ensureCustomColumnDefinitionExists(appSchema, generateParameters.manifest, targetEntitySet.name, facet.entityType.name, generateParameters.serviceAVT, facet, facetKey, generateParameters.fragments);
    }
    for (const facetItem in facets) {
        if (facets[facetItem].base === ux_specification_types_1.FacetBase.LineItem && facetItem.includes(navigationProperty)) {
            (0, utils_1.addLineItemsType)(appSchema, facets[facetItem].target, facets[facetItem].entityType, facetItem, customColumnDefinitionKey);
        }
    }
}
/**
 * Adds definitions for subsections in object page sections to the app schema
 * @param {Definition} appSchema - app schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetId - key of the facet, as listed in FacetConfigs
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleSubSection(appSchema, definitionKey, facet, facetId, sectionType, isHeaderFacet = false) {
    appSchema.definitions[definitionKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetId);
    const appSchemaSection = appSchema.definitions[definitionKey];
    const sectionDefinition = isHeaderFacet ? types_1.SectionTypeV2.HeaderSection : types_1.SectionTypeV2.SubSection;
    addAppSchemaDefinition(appSchema, appSchemaSection, sectionType, sectionDefinition);
    appSchemaSection.properties.subsections = {
        type: 'object',
        description: 'Subsections',
        properties: {},
        additionalProperties: false
    };
    appSchemaSection.properties.subsections[ux_specification_types_1.SchemaTag.isViewNode] = true;
}
/**
 * Method fills new chart section with properties.
 * @param {Definition} appSchema App schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleSectionChart(appSchema, definitionKey, facet, facetKey, sectionType) {
    appSchema.definitions[definitionKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey);
    const appSchemaSection = appSchema.definitions[definitionKey];
    addAppSchemaDefinition(appSchema, appSchemaSection, sectionType, types_1.SectionTypeV2.SectionChart);
}
/**
 * Method fills new header section with properties.
 * @param {Definition} appSchema App schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 */
function handleHeaderFacet(appSchema, definitionKey, facet, facetKey, sectionType, facetDefinition) {
    appSchema.definitions[definitionKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey);
    const appSchemaSection = appSchema.definitions[definitionKey];
    addAppSchemaDefinition(appSchema, appSchemaSection, sectionType, facetDefinition || types_1.SectionTypeV2.CommonHeaderFacetSettings);
    appSchemaSection[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    appSchemaSection[ux_specification_types_1.SchemaTag.isViewNode] = true;
    appSchemaSection[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataTypeOfTarget)(facet?.target);
}
function addDataPointHeaderFacetDataType(appSchema, definitionKey, facet) {
    const appSchemaSection = appSchema.definitions[definitionKey];
    const dataType = (appSchemaSection[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataTypeOfTarget)(facet?.target));
    if (dataType === common_1.DataType.Rating) {
        appSchemaSection.title = `${appSchemaSection.title}::RatingIndicatorVBox`;
    }
    else if (dataType === common_1.DataType.Progress) {
        appSchemaSection.title = `${appSchemaSection.title}::ProgressIndicatorVBox`;
    }
    else {
        appSchemaSection.title = `${appSchemaSection.title}::DataPoint`;
    }
}
/**
 * Method fills new form section in app schema with properties.
 * @param {Definition} appSchema App schema in general
 * @param {string} definitionKey - key of app schema definition to be filled
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 * @return {object} returns filled form section in app schema.
 */
function handleFormSection(appSchema, definitionKey, facet, facetKey, sectionType) {
    appSchema.definitions[definitionKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey);
    const appSchemaSection = appSchema.definitions[definitionKey];
    addAppSchemaDefinition(appSchema, appSchemaSection, sectionType, types_1.SectionTypeV2.SectionForm);
    appSchemaSection[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    appSchemaSection[ux_specification_types_1.SchemaTag.isViewNode] = true;
    return appSchemaSection;
}
/**
 * Mapping of facet type to (sub)section type to enable correct further handling
 * @param {FacetBase} facetType - facet type to be mapped
 * @param {boolean} isSubSection - if section is subsection of section
 * @return {SectionTypeV2} sectionType (sub)section type
 */
function getSectionType(facetType, isSubSection, isHeaderFacet) {
    const headerSectionMap = new Map([
        [ux_specification_types_1.FacetBase.CollectionFacet, types_1.SectionTypeV2.HeaderSection],
        [ux_specification_types_1.FacetBase.Address, types_1.SectionTypeV2.HeaderSectionAddress],
        [ux_specification_types_1.FacetBase.Chart, types_1.SectionTypeV2.HeaderSectionChart],
        [ux_specification_types_1.FacetBase.DataPoint, types_1.SectionTypeV2.HeaderSectionDataPoint],
        [ux_specification_types_1.FacetBase.Form, types_1.SectionTypeV2.HeaderSectionForm],
        [ux_specification_types_1.FacetBase.Identification, types_1.SectionTypeV2.HeaderSectionForm]
    ]);
    const sectionTypeMapping = new Map([
        [ux_specification_types_1.FacetBase.CollectionFacet, types_1.SectionTypeV2.Section],
        [ux_specification_types_1.FacetBase.LineItem, types_1.SectionTypeV2.SectionTable],
        [ux_specification_types_1.FacetBase.Chart, types_1.SectionTypeV2.SectionChart],
        [ux_specification_types_1.FacetBase.Address, types_1.SectionTypeV2.SectionAddress],
        [ux_specification_types_1.FacetBase.Contact, types_1.SectionTypeV2.SectionContact],
        [ux_specification_types_1.FacetBase.Form, types_1.SectionTypeV2.SectionForm],
        [ux_specification_types_1.FacetBase.Identification, types_1.SectionTypeV2.SectionForm]
    ]);
    const subSectionTypeMapping = new Map([
        [ux_specification_types_1.FacetBase.CollectionFacet, types_1.SectionTypeV2.SubSection],
        [ux_specification_types_1.FacetBase.LineItem, types_1.SectionTypeV2.SubSectionTable],
        [ux_specification_types_1.FacetBase.Chart, types_1.SectionTypeV2.SubSectionChart],
        [ux_specification_types_1.FacetBase.Address, types_1.SectionTypeV2.SubSectionAddress],
        [ux_specification_types_1.FacetBase.Contact, types_1.SectionTypeV2.SubSectionContact],
        [ux_specification_types_1.FacetBase.Form, types_1.SectionTypeV2.SubSectionForm],
        [ux_specification_types_1.FacetBase.Identification, types_1.SectionTypeV2.SubSectionForm]
    ]);
    if (isHeaderFacet) {
        return headerSectionMap.get(facetType);
    }
    else if (isSubSection) {
        return subSectionTypeMapping.get(facetType);
    }
    else {
        return sectionTypeMapping.get(facetType);
    }
}
/**
 * Method returns reference key, special handling of (sub)sections
 * @param {FacetConfig} facet facet or section information
 * @param {string} facetKey - facet key.
 * @param {SectionTypeV2} sectionType (sub)section type
 * @return {string} reference key
 */
function getReferenceKey(facet, facetKey, sectionType) {
    let referenceKey = facetKey;
    if (sectionType === (types_1.SectionTypeV2.Section || types_1.SectionTypeV2.SubSection)) {
        referenceKey = referenceKey.replace(`@${"com.sap.vocabularies.UI.v1.Facets" /* UIAnnotationTerms.Facets */}`, facet.base);
    }
    return `${referenceKey}`;
}
/**
 * Creates a section definition in app schema.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {FacetConfigs} facets - list of all facets.
 * @param {string} facetKey - facet key.
 * @param {object} sections - schema of current sections definition.
 * @param {Definition} appSchema - app specific schema that potentially gets enhanced.
 * @param {boolean} isSubSection - if section is subsection of section
 */
function addSection(generateParameters, facets, facetKey, sections, appSchema, isSubSection = false, isHeaderFacet = false) {
    const facet = facets[facetKey];
    const sectionType = getSectionType(facet.base, isSubSection, isHeaderFacet);
    const referenceKey = getReferenceKey(facet, facetKey, sectionType);
    const definitionKey = `${sectionType}<${referenceKey}>`;
    addSectionReference(sections, referenceKey, definitionKey);
    switch (sectionType) {
        case types_1.SectionTypeV2.Section:
        case types_1.SectionTypeV2.SubSection:
        case types_1.SectionTypeV2.HeaderSection: {
            //handle collection facets
            isSubSection = isHeaderFacet ? false : true;
            handleSubSection(appSchema, definitionKey, facet, facetKey, sectionType, isHeaderFacet);
            const subSections = appSchema.definitions[definitionKey].properties
                .subsections;
            for (const key in facet.facets) {
                addSection(generateParameters, facet.facets, key, subSections, appSchema, isSubSection, isHeaderFacet);
            }
            break;
        }
        case types_1.SectionTypeV2.SectionTable:
        case types_1.SectionTypeV2.SubSectionTable: {
            handleLineItem(generateParameters, facetKey, appSchema, facet, facets, sectionType);
            //add fields for createWithParameterDialog
            const floorplanSuffix = 'OP';
            (0, common_1.addFieldsType)(appSchema, facet.entityType, floorplanSuffix);
            break;
        }
        case types_1.SectionTypeV2.SectionChart:
        case types_1.SectionTypeV2.SubSectionChart: {
            //handle reference facet (if comprising chart)
            handleSectionChart(appSchema, definitionKey, facet, facetKey, sectionType);
            break;
        }
        case types_1.SectionTypeV2.SectionForm:
        case types_1.SectionTypeV2.SubSectionForm: {
            const appSchemaSection = handleFormSection(appSchema, definitionKey, facet, facetKey, sectionType);
            (0, common_1.handleForm)(ux_specification_types_1.SectionType.Section, facet, appSchemaSection, appSchema, ux_specification_types_1.FioriElementsVersion.v2, facetKey);
            break;
        }
        case types_1.SectionTypeV2.SectionAddress:
        case types_1.SectionTypeV2.SectionContact: {
            (0, common_1.handleAddressContact)(facet, facetKey, sections, appSchema, ux_specification_types_1.SectionType.Section, undefined, 'V2');
            break;
        }
        case types_1.SectionTypeV2.SubSectionAddress:
        case types_1.SectionTypeV2.SubSectionContact: {
            (0, common_1.handleAddressContact)(facet, facetKey, sections, appSchema, ux_specification_types_1.SectionType.Section, ux_specification_types_1.SectionType.SubSection, 'V2');
            break;
        }
        case types_1.SectionTypeV2.HeaderSectionForm:
        case types_1.SectionTypeV2.HeaderSectionChart:
        case types_1.SectionTypeV2.HeaderSectionAddress: {
            handleHeaderFacet(appSchema, definitionKey, facet, facetKey, sectionType);
            break;
        }
        case types_1.SectionTypeV2.HeaderSectionDataPoint: {
            handleHeaderFacet(appSchema, definitionKey, facet, facetKey, sectionType);
            addDataPointHeaderFacetDataType(appSchema, definitionKey, facet);
            break;
        }
        default: {
            // Other facets -> only default properties of ObjectPageSection
            sections.properties[facetKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey);
        }
    }
}
/**
 * Helper function to add facets to the app schema
 * @param facetsExists flag if facets exists and should be added
 * @param facets collection of facets
 * @param generateParameters list of API input parameters
 * @param sections sections in config to be extended
 * @param appSchema app speci
 * @param isHeaderFacet flag if facet is located in header section
 * @returns void
 */
function addSectionsFromFacets(facetsExists, facets, sections, generateParameters, appSchema, isHeaderFacet = false) {
    if (!facetsExists) {
        return;
    }
    for (const facetKey in facets) {
        addSection(generateParameters, facets, facetKey, sections, appSchema, false, isHeaderFacet);
    }
}
/**
 * Adds the sections to the app schema
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Definition} appSchema - app specific schema that potentially gets enhanced
 * @param {SapUiAppPagesV2} pages - list of (manifest) pages
 */
function addSections(generateParameters, appSchema, pages) {
    const sections = appSchema.definitions[ux_specification_types_1.DefinitionName.Sections];
    sections[ux_specification_types_1.SchemaTag.isViewNode] = true;
    if (generateParameters.entitySet?.entityType) {
        sections[ux_specification_types_1.SchemaTag.annotationPath] =
            `/${generateParameters.entitySet.entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.Facets" /* UIAnnotationTerms.Facets */}`;
    }
    const headerSections = appSchema.definitions[ux_specification_types_1.DefinitionName.HeaderSections];
    headerSections[ux_specification_types_1.SchemaTag.isViewNode] = true;
    if (!headerSections.properties) {
        headerSections.properties = {};
    }
    headerSections.additionalProperties = false;
    if (generateParameters.entitySet?.entityType) {
        headerSections[ux_specification_types_1.SchemaTag.annotationPath] =
            `/${generateParameters.entitySet.entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.HeaderFacets" /* UIAnnotationTerms.HeaderFacets */}`;
    }
    if (!pages) {
        return;
    }
    // Get facet annotations
    const facets = (0, common_1.getObjectPageFacets)(generateParameters.entitySet?.entityType, generateParameters.serviceAVT, ux_specification_types_1.FioriElementsVersion.v2, generateParameters.logger);
    const headerFacets = (0, common_1.getObjectPageHeaderFacets)(generateParameters.entitySet?.entityType, generateParameters.serviceAVT, ux_specification_types_1.FioriElementsVersion.v2, generateParameters.logger);
    const generateFacets = facets && !!Object.keys(facets).length;
    const generateHeaderFacets = headerFacets && !!Object.keys(headerFacets).length;
    if (!generateFacets && !generateHeaderFacets) {
        return;
    }
    // Loop on all pages, look for the right entity set
    for (const key in pages) {
        const element = pages[key];
        if (generateParameters.entitySet?.name?.includes(element.entitySet)) {
            // Loop on all facets (of the given entitySet)
            addSectionsFromFacets(generateFacets, facets, sections, generateParameters, appSchema);
            addSectionsFromFacets(generateHeaderFacets, headerFacets, headerSections, generateParameters, appSchema, true);
        }
        else {
            addSections(generateParameters, appSchema, element.pages);
        }
    }
    // Add custom sections
    const customSections = appSchema.definitions['CustomSections'];
    for (const name in customSections.properties) {
        sections.properties[name] = customSections.properties[name];
    }
}
/**
 * Add Object Page Header to app-specific schema
 *
 * @param {object} appSchema Schema of the app
 * @param {EntitySet} entitySet - current entity set
 * @param {EntityType} entityType - current entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function addHeader(appSchema, entitySet, entityType, oDataServiceAVT) {
    (0, common_1.addCommonHeaderSchema)(appSchema, entityType);
    //Add header actions
    (0, common_1.addHeaderActions)(appSchema, entityType, entitySet, oDataServiceAVT, addHeaderActionCallBackV2, true);
}
/**
 * Adds the related facets keys 'enum' to the app schema
 * @param schema - app specific schema that potentially gets enhanced
 * @param {EntityType} entityType - current entity type
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addRelatedFacetKeysType(schema, entityType, oDataServiceAVT, logger) {
    // Find sections from annotation
    // And create new definition in schema as enum with description
    const facetSections = (0, common_1.getObjectPageFacetSection)(entityType, oDataServiceAVT, logger, undefined, true);
    if (facetSections) {
        (0, common_1.addDefinitionForRelatedFacetKeys)(schema, ['ObjectPageCustomSectionFragment', 'ObjectPageCustomSectionView'], facetSections, ['ID', 'key']);
    }
}
/**
 * Generates an app specific schema out of the generic schema.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param genericSchema - generic JSON schema of an object page
 *
 * @returns the app specific JSON schema
 */
function generateObjectPageSchemaV2(generateParameters, genericSchema) {
    // Initialize i18next
    (0, i18n_1.initI18n)();
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    // Custom sections as part of sections
    const additionalSections = {};
    for (const name in appSchema.definitions['CustomSections']['properties']) {
        additionalSections[name] = appSchema.definitions['CustomSections'].properties[name];
    }
    // Change reference to generated sections
    appSchema.properties[ux_specification_types_1.PropertyName.sections] = {
        $ref: common_1.DEFINITION_LINK_PREFIX + 'Sections'
    };
    const entityType = generateParameters.entitySet?.entityType;
    generateParameters.entityType = entityType;
    const pages = generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages;
    if (!pages) {
        (0, extensionLogger_1.log)(generateParameters.logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOPAGES', { appId: generateParameters.manifest['sap.app']['id'] }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.generic]
            }
        });
        return appSchema;
    }
    // Add header
    addHeader(appSchema, generateParameters.entitySet, entityType, generateParameters.serviceAVT);
    // Add sections
    appSchema.definitions[ux_specification_types_1.DefinitionName.Sections] = {
        type: 'object',
        properties: {},
        description: 'Sections',
        additionalProperties: false
    };
    addSections(generateParameters, appSchema, pages);
    // Custom section facets
    addRelatedFacetKeysType(appSchema, entityType, generateParameters.serviceAVT, generateParameters.logger);
    if (!appSchema.definitions.Sections) {
        if (appSchema.definitions.RelatedFacetKeys && appSchema.definitions.RelatedFacetKeys['oneOf'].length) {
            // If related facets exists - then we need sections definition
            appSchema.definitions.Sections = {
                type: 'object',
                properties: additionalSections,
                additionalProperties: false
            };
            appSchema.definitions.Sections[ux_specification_types_1.SchemaTag.isViewNode] = true;
        }
        else {
            delete appSchema.properties[ux_specification_types_1.PropertyName.sections];
        }
    }
    (0, common_1.addFooterActions)(appSchema, generateParameters, ux_specification_types_1.FioriElementsVersion.v2, addFooterActionCallBackV2, pages);
    // Eliminate generic definitions
    delete appSchema.definitions['GenericSections'];
    delete appSchema.definitions['GenericSubSections'];
    delete appSchema.definitions['ObjectPageSectionTableV2'];
    delete appSchema.definitions['GenericColumns'];
    delete appSchema.definitions['TableColumnAction'];
    delete appSchema.definitions['CommonHeaderFacetSettings'];
    delete appSchema.definitions['ObjectPageHeaderSection'];
    // Currently not used
    delete appSchema.definitions['ObjectPageCustomHeaderSectionFragment'];
    delete appSchema.definitions['ObjectPageSectionFormV2'];
    delete appSchema.definitions['ObjectPageSectionTableV2'];
    delete appSchema.definitions['ObjectPageSubSectionV2'];
    delete appSchema.definitions['ObjectPageResponsiveTableWithMultiSelect'];
    delete appSchema.definitions['ObjectPageResponsiveTableWithInlineDelete'];
    delete appSchema.definitions['ObjectPageAnalyticalTable'];
    delete appSchema.definitions['ObjectPageTreeTable'];
    delete appSchema.definitions['ObjectPageGridTable'];
    delete appSchema.definitions['ObjectPageToolBar'];
    delete appSchema.definitions['ObjectPageToolBarActions'];
    delete appSchema.definitions['ObjectPageForm'];
    delete appSchema.definitions['ObjectPageFormFields'];
    delete appSchema.definitions['ObjectPageFormActions'];
    delete appSchema.definitions['FieldPathOP'];
    (0, common_1.updatePropertyIndices)(appSchema, ROOT_PROPERTIES_ORDER);
    return appSchema;
}
exports.generateObjectPageSchemaV2 = generateObjectPageSchemaV2;
//# sourceMappingURL=objectPage.js.map