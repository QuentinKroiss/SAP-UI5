"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferManifestEntriesAndFlexChange = exports.assignReflectMetadataRules = exports.transferManifestEntriesOVP = void 0;
// Note: the main functions or entry points reside in ./exportPage.ts
const deepmerge_1 = __importDefault(require("deepmerge"));
const controls_1 = require("./controls");
const common_1 = require("../../common");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_1 = require("../import/utils");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const exceptionList = ['colorPalette', 'tabs'];
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param ovp - OVP section of manifest, to be updated
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {
            template: ''
        };
    }
}
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        idParts.push('1');
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current object to traverse
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 * @param {string[]} entityPathArray (optional) - array of elements, describing a path to a subsection of the config.
 *                                                If specified, only elements from this subsection are processed
 */
function transferManifestEntriesOVP(configObject, exportResults, jsonSchema, targetDefinition, factory, pathHierarchy, entityPathArray) {
    if (targetDefinition?.properties) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        processProperties(configObject, exportResults, jsonSchema, targetDefinition.properties, factory, pathHierarchy, entityPathArray);
    }
}
exports.transferManifestEntriesOVP = transferManifestEntriesOVP;
/**
 * Assign sync rules to {currentObject}
 * @param {MetadataInstanceInterface} factory - factory for metadata
 * @param {string} structureName - name of the complex structure in schema
 * @param {object} currentObject - the given part of the configuration
 * @param {string} defaultTypeName - name of the default type that shall be taken if no class is registered for structureName
 */
function assignReflectMetadataRules(factory, structureName, currentObject, defaultTypeName) {
    return factory.createInstance(ux_specification_types_1.PageTypeV2.OverviewPage, defaultTypeName, currentObject, structureName);
}
exports.assignReflectMetadataRules = assignReflectMetadataRules;
/**
 * Processes anyOf definitions of the schema while exporting an OVP config
 * @param {ProcessDefinitionParams} params - sructure comprising all information needed for processing
 * @returns the params.currentObject, with the reflect-metadata assigned
 */
function processAnyOfDefinitionsOfOVP(params) {
    params.pathHierarchy.pop();
    let newConfigObject = params.currentObject;
    for (const anyOfKey in params.propertyList['anyOf']) {
        if (params.propertyList['anyOf'][anyOfKey].$ref) {
            const definitionArray = params.propertyList['anyOf'][anyOfKey].$ref.split(common_1.DEFINITION_LINK_PREFIX);
            const nextTargetDefinition = params.appSchema['definitions'][definitionArray[1]];
            newConfigObject = assignReflectMetadataRules(params.factory, definitionArray[1], newConfigObject, 'CustomCard');
            transferManifestEntriesOVP(newConfigObject, params.exportResults, params.appSchema, nextTargetDefinition, params.factory, [...params.pathHierarchy]);
        }
    }
    return newConfigObject;
}
function checkSyncRuleForExport(exportHandler, manifestSection, configObject, key, currentObject) {
    if (exportHandler && typeof exportHandler === 'function') {
        exportHandler(manifestSection, configObject, key);
    }
    else if (typeof currentObject === 'object' && !exceptionList.includes(key)) {
        // colorPalette is an exception as it can contain anything as per our schema, so just replace the object
        manifestSection[key] = (0, deepmerge_1.default)(manifestSection[key] || {}, currentObject || {}, {
            arrayMerge: common_1.arrayCombineMerge
        });
    }
    else {
        manifestSection[key] = currentObject;
    }
}
/**
 * Transfer manifest settings from config to manifest
 * @param syncRule - metadata rule used for import and export
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 * @param key
 * @param exportResults - overall result list, to be updated
 * @param currentObject
 * @param configObject
 */
function transferToManifest(syncRule, pathHierarchy, key, exportResults, currentObject, configObject) {
    const path = syncRule.manifest.path([...pathHierarchy, key]);
    const manifestSection = (0, manifest_1.ensureManifestSectionByPathV2)(exportResults.manifest, path);
    if (key in ux_specification_types_1.v2.CardSettingsType || key === 'settings') {
        manifestSection['settings'] = (0, deepmerge_1.default)(manifestSection['settings'] || {}, currentObject || {}, {
            arrayMerge: common_1.arrayCombineMerge
        });
    }
    else if (currentObject !== undefined) {
        const exportHandler = syncRule.manifest.export;
        checkSyncRuleForExport(exportHandler, manifestSection, configObject, key, currentObject);
    }
    else if (manifestSection[key] !== undefined) {
        delete manifestSection[key];
    }
}
function transferCards(currentObject, appSchema, factory, exportResults) {
    Object.keys(currentObject).forEach((cardKey) => {
        const cardType = currentObject[cardKey].template;
        //Determine target defintion
        let targetDefinition;
        if (!Object.values(ux_specification_types_1.v2.CardTemplateType).includes(cardType)) {
            targetDefinition = ['CustomCard'];
        }
        else {
            targetDefinition = Object.keys(appSchema.definitions).filter((definition) => {
                const template = appSchema.definitions[definition].properties?.template;
                if (template?.enum) {
                    return template.enum.indexOf(currentObject[cardKey].template) > -1;
                }
                else if (template?.const) {
                    return template.const === currentObject[cardKey].template;
                }
            });
        }
        //Get metadata
        currentObject[cardKey] = assignReflectMetadataRules(factory, targetDefinition[0], currentObject[cardKey], 'CustomCard');
        createCard(cardKey, exportResults['manifest'][ux_specification_types_1.ManifestSection.ovp]);
        transferManifestEntriesOVP(currentObject[cardKey], exportResults, appSchema, appSchema.definitions[targetDefinition[0]], factory, [cardKey]);
    });
    //check for deletions:
    Object.keys(exportResults.manifest[ux_specification_types_1.ManifestSection.ovp].cards).forEach((manifestCard) => {
        if (!currentObject[manifestCard]) {
            delete exportResults.manifest[ux_specification_types_1.ManifestSection.ovp].cards[manifestCard];
        }
    });
}
function exportOfObject(params, key, factory) {
    if (key === 'cards') {
        //inserts and updates:
        transferCards(params.currentObject, params.appSchema, factory, params.exportResults);
    }
    else {
        const nextTargetDefinition = (0, common_1.getNextTargetDefinition)(params.appSchema, '', params.currentObject, params.propertyList[key], key, factory, ux_specification_types_1.PageTypeV2.OverviewPage);
        if (params.propertyList[key].$ref) {
            const definitionArray = params.propertyList[key].$ref.split(common_1.DEFINITION_LINK_PREFIX);
            params.currentObject = assignReflectMetadataRules(params.factory, key, params.currentObject, definitionArray[1]);
            params.pathHierarchy = [...params.pathHierarchy, key];
            transferManifestEntriesOVP(params.currentObject, params.exportResults, params.appSchema, nextTargetDefinition.targetDefinition, factory, params.pathHierarchy);
        }
        else if (params.propertyList[key].anyOf) {
            params.pathHierarchy = [...params.pathHierarchy, key, 'anyOf'];
            processProperties(params.configObject, params.exportResults, params.appSchema, params.propertyList[key], factory, params.pathHierarchy);
        }
        else if (params.propertyList[key]['properties'] !== undefined) {
            params.pathHierarchy = [...params.pathHierarchy, key];
            processProperties(params.configObject[key], params.exportResults, params.appSchema, params.propertyList[key].properties, params.factory, params.pathHierarchy);
        }
    }
}
/**
 * Recursive function that transfers the content of a list of properties of a configuration to the overall exportResults
 * @param configObject - the given part of the configuration
 * @param exportResults - overall result list, to be updated
 * @param appSchema - app-specific JSON schema
 * @param propertyList - current property list of the config (properties or additional properties)
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 * @param {string[]} entityPathArray (optional) - array of elements, describing a path to a subsection of the config.
 *                                                If specified, only elements from this subsection are processed*/
function processProperties(configObject, exportResults, appSchema, propertyList, factory, pathHierarchy, entityPathArray) {
    for (const propertyKey in propertyList) {
        if (propertyKey === 'description') {
            continue;
        }
        if (entityPathArray) {
            if (pathHierarchy &&
                entityPathArray[pathHierarchy.length] !== propertyKey &&
                !(0, common_1.arrayIncludes)(pathHierarchy, entityPathArray)) {
                continue;
            }
        }
        let currentObject = configObject[propertyKey];
        const syncRule = (0, common_1.getReflectMetadata)(configObject, propertyKey);
        const processDefinitionParams = {
            pathHierarchy,
            propertyList,
            appSchema,
            currentObject,
            configObject,
            factory,
            exportResults
        };
        if (pathHierarchy[pathHierarchy.length - 1] === 'anyOf') {
            processDefinitionParams.currentObject = configObject[pathHierarchy[pathHierarchy.length - 2]];
            currentObject = processAnyOfDefinitionsOfOVP(processDefinitionParams);
        }
        else if (currentObject && typeof currentObject === 'object' && propertyList[propertyKey]) {
            exportOfObject(processDefinitionParams, propertyKey, factory);
        }
        if (syncRule?.manifest) {
            transferToManifest(syncRule, pathHierarchy, propertyKey, exportResults, currentObject, configObject);
        }
    }
}
/**
 * Evaluates an export rule for a property, transfers to flex change
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 */
function evaluateFlexRule(transferParameters, breadcrumbs, syncRule, ids, title, configObject, key) {
    let localBreadcrumbs;
    if (breadcrumbs.length === 0) {
        //only added on top = page level, do not forward
        localBreadcrumbs = ['page'];
    }
    else {
        localBreadcrumbs = breadcrumbs;
    }
    const controlId = syncRule.flex.controlId(transferParameters.baseId, ids, localBreadcrumbs, syncRule.flex.controlType, title);
    const flexChange = (0, common_1.fillFlexChangeContent)(configObject, syncRule, transferParameters.ui5Version, key, controlId);
    const localManifest = JSON.parse(JSON.stringify(transferParameters.exportResults.manifest));
    localManifest['sap.app'].id = transferParameters.appId;
    const completeFlexChange = syncRule.flex.createFlexChange(flexChange, localManifest);
    const flexChangeExists = transferParameters.exportResults.flexChanges.find((change) => {
        let result = false, oldChange = JSON.parse(change);
        oldChange = {
            content: oldChange['content'],
            selector: oldChange['selector']
        };
        let newChange = JSON.parse(completeFlexChange);
        newChange = {
            content: newChange['content'],
            selector: newChange['selector']
        };
        if (JSON.stringify(oldChange) === JSON.stringify(newChange)) {
            result = true;
        }
        return result;
    });
    if (!flexChangeExists) {
        transferParameters.exportResults.flexChanges.push(completeFlexChange);
    }
}
/**
 * Exports a given config property value to manifest
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param syncRule - export rule from the object classes decorator
 * @param manifestSection - current section in manifest.json
 * @param configObject - current (sub)object of the configuration file
 * @param key - key of the given property in the config
 * @param manifestKey - key of the given property in manifest
 */
function exportConfigValueToManifest(transferParameters, syncRule, manifestSection, configObject, key, manifestKey) {
    if (
    // In case of arrays we take over complete array
    !(transferParameters.propertyDefinition['type'] !== 'array' &&
        transferParameters.nextDefinition &&
        transferParameters.nextDefinition['targetDefinition'].type === 'object' &&
        transferParameters.nextDefinition['targetDefinition'].properties)) {
        const exportHandler = syncRule.manifest.export;
        if (exportHandler && typeof exportHandler === 'function') {
            exportHandler(manifestSection, configObject, key, manifestKey);
        }
        else if (exportHandler !== false) {
            manifestSection[manifestKey] = configObject[key];
        }
        transferParameters.exportResults.manifestChangeIndicator = ux_specification_types_1.ChangeIndicator.Updated;
    }
    else if (transferParameters.propertyDefinition['type'] !== 'array' &&
        manifestSection[manifestKey] === undefined) {
        manifestSection[manifestKey] = {};
        transferParameters.exportResults.manifestChangeIndicator = ux_specification_types_1.ChangeIndicator.Updated;
    }
}
/**
 * Evaluates an export rule for a property, transfers to manifest setting
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 */
function evaluateManifestRule(transferParameters, path, syncRule, key, configObject) {
    const manifestSection = (0, manifest_1.ensureManifestSectionByPathV2)(transferParameters.exportResults.manifest, path);
    const manifestKey = syncRule.manifest.key || key;
    if (configObject[key] !== undefined) {
        exportConfigValueToManifest(transferParameters, syncRule, manifestSection, configObject, key, manifestKey);
    }
    else {
        //delete value
        const deleteHandler = syncRule.manifest.delete;
        if (deleteHandler && typeof deleteHandler === 'function') {
            deleteHandler(manifestSection, configObject, key, manifestKey);
        }
        else if (Object.prototype.hasOwnProperty.call(manifestSection, manifestKey)) {
            delete manifestSection[manifestKey];
        }
        transferParameters.exportResults.manifestChangeIndicator = ux_specification_types_1.ChangeIndicator.Updated;
        (0, common_1.deleteEmptyStructure)(transferParameters.exportResults.manifest, path, transferParameters.deletionRequest, transferParameters.entityPathArray);
    }
}
function getManifestPathOfSections(breadcrumbs, path, syncRule, transferParameters, title) {
    if (breadcrumbs[1] === 'custom') {
        path = syncRule.manifest.path(transferParameters.pageKeys, {}, breadcrumbs[2]);
    }
    else {
        path = syncRule.manifest.path(transferParameters.pageKeys, {}, title?.startsWith(ux_specification_types_1.FacetTitlePrefix) ? title.split(ux_specification_types_1.FacetTitlePrefix)[1] : breadcrumbs[1], breadcrumbs[breadcrumbs.length - 1]);
        path = path.replace('/@', '::').replace(/VOCWITHCOLONS/g, '::com.sap.vocabularies');
    }
    return path;
}
function getManifestPathOfTable(breadcrumbs, path, syncRule, transferParameters, configObject) {
    if (breadcrumbs[1] === 'columns' && breadcrumbs[2] === 'custom') {
        path = syncRule.manifest.path(transferParameters.pageKeys, transferParameters.exportResults.manifest, configObject['tabKey']);
    }
    else {
        path = syncRule.manifest.path(transferParameters.pageKeys, {}, breadcrumbs[breadcrumbs.length - 1]);
    }
    return path;
}
/**
 * Determines the path to a manifest setting, based on the syncRule
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param {SyncRule} syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @returns the path to the manifest setting
 */
function getManifestPath(transferParameters, breadcrumbs, syncRule, configObject, title) {
    let path;
    if (breadcrumbs[0] === ux_specification_types_1.PropertyName.sections) {
        path = getManifestPathOfSections(breadcrumbs, path, syncRule, transferParameters, title);
    }
    else if (breadcrumbs[0] === ux_specification_types_1.PropertyName.table) {
        path = getManifestPathOfTable(breadcrumbs, path, syncRule, transferParameters, configObject);
    }
    else if (breadcrumbs[0] === 'keyPerformanceIndicators') {
        path = syncRule.manifest.path(transferParameters.pageKeys, transferParameters.exportResults.manifest, title);
    }
    else if (breadcrumbs[0] === 'filterBar' && breadcrumbs[1] === 'selectionFields') {
        path = syncRule.manifest.path(transferParameters.pageKeys, transferParameters.exportResults.manifest, breadcrumbs.slice(2).join('/'));
    }
    else {
        path = syncRule.manifest.path(transferParameters.pageKeys);
    }
    return path;
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param {SyncRule} syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 */
function evaluateExportRule(transferParameters, syncRule, configObject, breadcrumbs, ids, title, key) {
    if (!syncRule) {
        return;
    }
    //eliminate subsections' hierarchy
    let index = breadcrumbs.indexOf('subsections');
    while (index > -1) {
        breadcrumbs.splice(index - 1, 2);
        index = breadcrumbs.indexOf('subsections');
    }
    if (syncRule.flex) {
        evaluateFlexRule(transferParameters, breadcrumbs, syncRule, ids, title, configObject, key);
    }
    else if (syncRule.manifest) {
        const path = getManifestPath(transferParameters, breadcrumbs, syncRule, configObject, title);
        evaluateManifestRule(transferParameters, path, syncRule, key, configObject);
    }
}
/**
 * Deletes an obsolete custom column from manifest
 */
function deleteObsoleteColumn(key, columnParams, manifestSection) {
    const keyParts = key.split('|');
    const keyEntitySet = keyParts[1];
    const keyTab = keyParts[2];
    if (keyEntitySet === columnParams.entitySet) {
        //relevant extension. still present in config?
        const existingConfigEntries = columnParams.config?.filter((column) => (column.tabKey === keyTab ||
            (keyTab === undefined && column.tabKey === '') ||
            (keyTab && columnParams.sectionKey === keyTab)) &&
            column.extensionType === columnParams.extensionType);
        if (!existingConfigEntries || existingConfigEntries.length === 0) {
            (0, controls_1.deleteColumnFromFragment)(manifestSection, key, columnParams.appId, columnParams.exportResults.fragments);
            // delete from manifest
            delete manifestSection[key];
            // delete cells entry
            if (key.startsWith(ux_specification_types_1.ViewTemplateType.ResponsiveTableColumnsExtension)) {
                const cellsPattern = key.replace(ux_specification_types_1.ViewTemplateType.ResponsiveTableColumnsExtension, ux_specification_types_1.ViewTemplateType.ResponsiveTableCellsExtension);
                (0, controls_1.deleteColumnFromFragment)(manifestSection, cellsPattern, columnParams.appId, columnParams.exportResults.fragments);
                // delete from manifest
                delete manifestSection[cellsPattern];
            }
        }
    }
}
/**
 * Walks through the extensions registered in manifest and compares the columns of the fragment with the ones present in config.
 * If not present anymore, the extension column gets deleted from fragment.
 * @param path - path to extesnions section in manifest
 * @param exportResults - result structure, including the fragments that may get updated
 * @param entitySet - current entity set
 * @param config - current config JSON
 * @param sectionKey - section key
 * @param extensionType - extensionType
 * @param appId - application ID
 */
function deleteObsoleteColumnsFromFragment(columnParams) {
    const folderPath = columnParams.path.substring(0, columnParams.path.lastIndexOf('/'));
    const manifestSection = (0, manifest_1.getManifestSectionByPathV2)(columnParams.exportResults.manifest, folderPath);
    const extensionPattern = columnParams.path.substring(columnParams.path.lastIndexOf('/') + 1);
    for (const key in manifestSection) {
        if (key.startsWith(extensionPattern)) {
            columnParams.exportResults.manifestChangeIndicator = ux_specification_types_1.ChangeIndicator.Updated;
            deleteObsoleteColumn(key, columnParams, manifestSection);
        }
    }
}
/**
 * Clusters the custom columns if a config by the extension's path in manifest
 * @param customColumnsInConfig - list of all custom columns in config
 * @param schemaDefinition - schema definition of the table custom column
 * @param v2Page - current page in manifest
 * @param entitySet - current entity set
 * @param sectionKey key of the section (in case of OP)
 * @returns the custom columns, clustered by the manifest path
 */
function clusterConfigColumnsByPath(customColumnsInConfig, schemaDefinition, v2Page, entitySet, sectionKey) {
    const cluster = {};
    for (const customColumn of customColumnsInConfig) {
        //verify that mandatory parameters are filled
        if (!customColumn['className'] ||
            !customColumn['fragmentName'] ||
            !customColumn['columnKey'] ||
            !customColumn['extensionType']) {
            continue;
        }
        //check fragment name
        if (schemaDefinition['properties']['fragmentName']['pattern']) {
            const namePattern = new RegExp(schemaDefinition['properties']['fragmentName']['pattern']);
            if (namePattern.test(customColumn['fragmentName']) === false) {
                continue;
            }
        }
        const { path, viewTemplateType } = (0, controls_1.getCustomColumnPath)(v2Page, entitySet, customColumn.tabKey || sectionKey, customColumn['extensionType']);
        if (!cluster[path]) {
            cluster[path] = {
                viewTemplateType: viewTemplateType,
                columns: []
            };
        }
        cluster[path].columns.push(customColumn);
    }
    return cluster;
}
/**
 * Transfers column extensions to manifest and fragment files
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param {TableCustomColumns} customColumnsInConfig - config part comprising the table custom columns
 * @param {object} schemaDefinition - Column schema definition
 * @param {ObjectPageSectionData} [objectPageSectionData] - Object Page section's data containing target and key options.
 */
function transferColumnExtensions(transferParameters, customColumnsInConfig, schemaDefinition, objectPageSectionData) {
    if (!transferParameters.v2Page) {
        return;
    }
    const sectionKey = objectPageSectionData ? objectPageSectionData.key : undefined;
    const sectionTarget = objectPageSectionData ? objectPageSectionData.target : undefined;
    const entitySet = sectionTarget || transferParameters.v2Page.entitySet;
    for (const extensionType in ux_specification_types_1.v2.TableColumnExtensionTypeV2) {
        const { path } = (0, controls_1.getCustomColumnPath)(transferParameters.v2Page, entitySet, sectionKey, extensionType);
        if (!path) {
            continue;
        }
        const columParams = {
            path,
            exportResults: transferParameters.exportResults,
            entitySet,
            config: customColumnsInConfig,
            sectionKey,
            extensionType,
            appId: transferParameters.appId
        };
        deleteObsoleteColumnsFromFragment(columParams);
    }
    if (customColumnsInConfig) {
        //cluster existing custom columns by manifest path (or tab key)
        const cluster = clusterConfigColumnsByPath(customColumnsInConfig, schemaDefinition, transferParameters.v2Page, entitySet, sectionKey);
        //Export to fragment
        for (const path in cluster) {
            (0, controls_1.exportCustomColumnsToFragment)(transferParameters.exportResults, path, cluster[path].columns, transferParameters.appId, cluster[path].viewTemplateType, transferParameters.logger);
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param parentIds - array of collected parent ids
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param targetDefinition - the current entry point or definition in the app schema
 */
function transferManifestExtensions(transferParameters, configSections, pageKey, parentIds, breadcrumbs, targetDefinition) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    if (!configSections) {
        return;
    }
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (let index = 0; index < sectionIds.length; index++) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref?.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split(common_1.DEFINITION_LINK_PREFIX);
        const nextTargetDefinition = transferParameters.appSchema['definitions'][definitionArray[definitionArray.length - 1]];
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, configSections[index], parentIds, [...breadcrumbs, sectionIds[index]], nextTargetDefinition);
    }
    // Delete removed manifest entries
    const manifestSections = (0, manifest_1.ensureManifestSectionByPathV2)(transferParameters.exportResults.manifest, (0, application_1.getViewExtensionsPath)());
    for (const key in manifestSections) {
        if ((0, utils_1.isAssociatedCustomSection)(key, entity) && !sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Method returns converted section id by resolving passed section id and title from schema.
 * @param {string[]} breadcrumbs Array of properties that we are currently processing. Required for instance for table column name.
 * @param {string} title Title from JSON schema, comprising the facet ID
 * @returns {string | undefined} Resolved section id.
 */
function getSectionId(breadcrumbs, title) {
    let sectionId = undefined;
    for (let i = breadcrumbs.length - 1; i >= 0; i--) {
        if (breadcrumbs[i] === ux_specification_types_1.PropertyName.table) {
            sectionId = breadcrumbs[i - 1];
            break;
        }
    }
    return (0, common_1.convertSectionId)(sectionId, title);
}
/**
 * Processes index tables in schema
 */
function transferIndexTable(currentConfigObject, transferParameters, title, key, ids, breadcrumbs) {
    const propertyDefinition = transferParameters.propertyDefinition;
    if (!currentConfigObject || !propertyDefinition?.additionalProperties) {
        return;
    }
    Object.keys(currentConfigObject).forEach((newKey) => {
        const nextDefinition = (0, common_1.getNextTargetDefinition)(transferParameters.appSchema, title, currentConfigObject[newKey], propertyDefinition.additionalProperties, key, transferParameters.factory, transferParameters.pageType);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, nextDefinition.configObject, ids, [...breadcrumbs, key], nextDefinition.targetDefinition, newKey);
    });
}
/**
 * Transfers custom columns of schema
 */
function transferCustomColumns(propertyDefinition, breadcrumbs, title, transferParameters, configObject, nextDefinition) {
    let objectPageSectionData;
    const target = (0, common_1.getTargetFromCustomColumnRef)(propertyDefinition.$ref);
    if (target) {
        objectPageSectionData = {
            target,
            key: getSectionId(breadcrumbs, title)
        };
    }
    transferColumnExtensions(transferParameters, configObject?.custom, nextDefinition.targetDefinition, objectPageSectionData);
}
/**
 * Processes anyOf definitions of schema
 */
function handleAnyOfDefinitions(propertyDefinition, transferParameters, title, currentConfigObject, key, ids, breadcrumbs) {
    propertyDefinition['anyOf'].forEach((element) => {
        const nextDefinition = (0, common_1.getNextTargetDefinition)(transferParameters.appSchema, title, currentConfigObject, element, key, transferParameters.factory, transferParameters.pageType);
        if (nextDefinition) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            transferManifestEntriesAndFlexChange(transferParameters, nextDefinition.configObject, ids, [...breadcrumbs, key], nextDefinition.targetDefinition, nextDefinition.title);
        }
    });
}
/**
 * Processes complex definitions of schema
 */
function transferComplexProperty(transferParameters, breadcrumbs, configObject, ids, propertyKey, nextDefinition, title) {
    const propertyDefinition = transferParameters.propertyDefinition;
    if (propertyDefinition?.type === 'array' &&
        (breadcrumbs[0] === 'sections' || breadcrumbs[0] === 'subsections') &&
        propertyKey === 'custom') {
        transferManifestExtensions(transferParameters, configObject[propertyKey], transferParameters.pageKeys[transferParameters.pageKeys.length - 1], ids, [...breadcrumbs, propertyKey], propertyDefinition?.items);
    }
    else if (nextDefinition && propertyKey === 'custom') {
        transferCustomColumns(propertyDefinition, breadcrumbs, title, transferParameters, configObject, nextDefinition);
        return;
    }
    else if (nextDefinition) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(transferParameters, nextDefinition.configObject, ids, [...breadcrumbs, propertyKey], nextDefinition.targetDefinition, nextDefinition.title);
    }
    else if (propertyDefinition['anyOf']) {
        handleAnyOfDefinitions(propertyDefinition, transferParameters, title, configObject?.[propertyKey], propertyKey, ids, breadcrumbs);
    }
}
/**
 * Function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param {TransferParameterTypeV2} transferParameters - list of input parameters for the recursive function call
 * @param configObject - current (sub)object of the configuration file
 * @param parentIds - array of collected parent ids
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - title from the app schema (comprising for instance the facet ID)
 */
function transferManifestEntriesAndFlexChange(transferParameters, configObject, parentIds, breadcrumbs, schemaDefinition, title) {
    let currentConfigObject;
    if (!schemaDefinition?.properties) {
        return;
    }
    for (const propertyKey in schemaDefinition.properties) {
        if (transferParameters.entityPathArray) {
            if (transferParameters.entityPathArray[breadcrumbs.length] !== propertyKey &&
                !(0, common_1.arrayIncludes)(breadcrumbs, transferParameters.entityPathArray)) {
                continue;
            }
        }
        currentConfigObject = configObject?.[propertyKey];
        const childId = configObject && (0, common_1.getChildId)(configObject, propertyKey);
        const ids = childId ? [...parentIds, childId] : parentIds;
        const syncRule = (0, common_1.getReflectMetadata)(configObject, propertyKey);
        const propertyDefinition = (transferParameters.propertyDefinition = schemaDefinition.properties[propertyKey]);
        const nextDefinition = (transferParameters.nextDefinition = (0, common_1.getNextTargetDefinition)(transferParameters.appSchema, title, currentConfigObject, propertyDefinition, propertyKey, transferParameters.factory, transferParameters.pageType));
        //Evaluate sync rule for the export
        evaluateExportRule(transferParameters, syncRule, configObject, [...breadcrumbs], ids, title, propertyKey);
        //index table
        transferIndexTable(currentConfigObject, transferParameters, title, propertyKey, ids, breadcrumbs);
        if (currentConfigObject === undefined || typeof currentConfigObject === 'object') {
            transferComplexProperty(transferParameters, breadcrumbs, configObject, ids, propertyKey, nextDefinition, title);
        }
        else if (propertyDefinition?.$ref === common_1.DEFINITION_LINK_PREFIX + 'TableCustomColumns') {
            //empty config ==> delete all given extensions
            transferColumnExtensions(transferParameters, [], transferParameters.appSchema['definitions']['TableCustomColumn']);
            continue;
        }
    }
}
exports.transferManifestEntriesAndFlexChange = transferManifestEntriesAndFlexChange;
//# sourceMappingURL=export.js.map