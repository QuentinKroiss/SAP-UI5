"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformPageToNewManifestV2 = exports.deleteManifestSectionByPathV2 = exports.getManifestSectionByPathV2 = exports.ensureManifestSectionByPathV2 = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
/**
 * Method searches in manifest object by passed path and returns found value.
 * If value was not found in manifest object,
 *   then method created empty object in manifest object within passed path.
 * @param manifest - target manifest object
 * @param path - path to lookup in manifest
 * @returns Found or created value
 */
const ensureManifestSectionByPathV2 = (manifest, path) => {
    let manifestSection = manifest;
    path.split('/').forEach(function (element) {
        if (!manifestSection[element]) {
            manifestSection[element] = {};
        }
        manifestSection = manifestSection && manifestSection[element];
    });
    return manifestSection ? manifestSection : {};
};
exports.ensureManifestSectionByPathV2 = ensureManifestSectionByPathV2;
/**
 * Method searches in manifest object by passed path and returns found value.
 * If value was not found in manifest object, then 'undefined' is returned.
 * @param manifest - target manifest file
 * @param path - path to lookup in manifest
 * @returns Found value
 */
const getManifestSectionByPathV2 = (manifest, path) => {
    let manifestSection = manifest;
    const elements = path.split('/');
    for (const element of elements) {
        if (!manifestSection[element]) {
            return undefined;
        }
        manifestSection = manifestSection && manifestSection[element];
    }
    return manifestSection ? manifestSection : {};
};
exports.getManifestSectionByPathV2 = getManifestSectionByPathV2;
const deleteManifestSectionByPathV2 = (manifest, path) => {
    let manifestSection = manifest;
    for (let index = 0; index < path.split('/').length; index++) {
        const element = path.split('/')[index];
        if (index === path.split('/').length - 1) {
            delete manifestSection[element];
        }
        else {
            manifestSection = manifestSection && manifestSection[element];
        }
    }
};
exports.deleteManifestSectionByPathV2 = deleteManifestSectionByPathV2;
function getNewPageTemplate(pageType) {
    return {
        component: {
            name: 'sap.suite.ui.generic.template.' + pageType
        }
    };
}
/**
 * Method finds matching pages by 'entitySet' and 'navigationProperty' in passed pages object.
 * @param {SapUiAppPagesV2} pages Object with pages.
 * @param {string} [entitySet] Entity set.
 * @param {string} [navigationProperty] Navigation property.
 * @returns {SapUiAppPageV2 | undefined} Matching page object.
 */
function findPageInManifest(pages, entitySet, navigationProperty) {
    if (!pages) {
        return;
    }
    for (const pageId in pages) {
        const page = pages[pageId];
        if (page.entitySet === entitySet && page.navigationProperty === navigationProperty) {
            return page;
        }
    }
}
function transformPageFromAssociation(configPages, association, manifestPage) {
    //Handling partial deletion of a page
    if (!configPages[association]) {
        return;
    }
    if (manifestPage['pages'] && !Object.values(manifestPage['pages'])[0]) {
        manifestPage['pages'][`${configPages[association].pageType}|${configPages[association].entitySet}`] =
            getNewPageTemplate(configPages[association].pageType);
    }
    if (!manifestPage['pages']) {
        manifestPage['pages'] = {
            [`${configPages[association].pageType}|${configPages[association].entitySet}`]: getNewPageTemplate(configPages[association].pageType)
        };
    }
    if (!Array.isArray(manifestPage['pages'])) {
        let associatedManifestPage = findPageInManifest(manifestPage['pages'], configPages[association].entitySet, configPages[association].navigationProperty);
        if (!associatedManifestPage) {
            manifestPage['pages'][`${configPages[association].pageType}|${configPages[association].entitySet}`] =
                associatedManifestPage = getNewPageTemplate(configPages[association].pageType);
        }
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transformPageToNewManifestV2(association, configPages, associatedManifestPage);
    }
}
function deletePage(manifestPage, configPages, configPage) {
    if (manifestPage['pages']) {
        Object.keys(manifestPage['pages']).forEach((key) => {
            const currentPage = manifestPage['pages'][key];
            if (currentPage.component?.name === ux_specification_types_1.v2.FE_TEMPLATE_V2_OBJECT_PAGE) {
                const configKey = `ObjectPage_${currentPage.entitySet}`;
                if (!configPages[configKey]) {
                    delete manifestPage['pages'][key];
                }
            }
        });
    }
    if ((configPage.pageType === ux_specification_types_1.PageTypeV2.ListReport || configPage.pageType === ux_specification_types_1.PageTypeV2.AnalyticalListPage) &&
        Object.keys(configPage.navigation).length === 0) {
        delete manifestPage['pages'];
    }
}
/**
 * Transfers pages and routings from manifest to the config pages
 * @param pageId - page ID
 * @param configPages - config definitions of each page
 * @param manifestPage - top page definition in manifest
 */
function transformPageToNewManifestV2(pageId, configPages, manifestPage) {
    const configPage = configPages[pageId];
    if (!configPage) {
        return;
    }
    if (configPage.entitySet) {
        manifestPage['entitySet'] = configPage.entitySet;
    }
    if (configPage.pageType === ux_specification_types_1.PageTypeV2.ListReport) {
        manifestPage['component']['list'] = true;
    }
    if (configPage.navigationProperty) {
        manifestPage['navigationProperty'] = configPage.navigationProperty;
    }
    if (configPage.defaultLayoutType) {
        manifestPage['defaultLayoutType'] = configPage.defaultLayoutType;
    }
    else if ('defaultLayoutType' in manifestPage) {
        delete manifestPage['defaultLayoutType'];
    }
    if (configPage.navigation) {
        for (const association in configPage.navigation) {
            transformPageFromAssociation(configPages, association, manifestPage);
        }
        // Delete page
        if (!Array.isArray(manifestPage['pages'])) {
            deletePage(manifestPage, configPages, configPage);
        }
    }
}
exports.transformPageToNewManifestV2 = transformPageToNewManifestV2;
//# sourceMappingURL=manifest.js.map