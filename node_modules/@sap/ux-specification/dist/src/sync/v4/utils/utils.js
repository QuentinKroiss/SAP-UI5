"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCustomFilterFieldDefinition = exports.addCustomSectionDefinition = exports.getPageCustomViewFile = exports.getPageCustomExtensionFile = exports.getManifestPage = exports.addHeaderFooterCustomActionDefinition = exports.addCustomActionDefinition = exports.alignSchemaWithTemplateType = exports.findPageV4 = exports.addEnumForActionAnchor = exports.addFragmentEnumForAnchor = exports.addLineItemsTypeToSchema = exports.appendLineItemsToSchema = exports.addCustomColumnDefinition = exports.addExtensionToArray = void 0;
const utils_1 = require("../../common/utils");
const StableIdHelper_1 = require("./StableIdHelper");
const common_1 = require("../../common");
const i18next_1 = __importDefault(require("i18next"));
const __1 = require("../../..");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const path_1 = require("path");
function sortByPropertyIndex() {
    return ([_key1, value1], [_key2, value2]) => value1[ux_specification_types_1.SchemaTag.propertyIndex] - value2[ux_specification_types_1.SchemaTag.propertyIndex];
}
/**
 * Sort function for properties in schema definitions.
 * @param definition - definition which contains list of properties, unsorted
 * @returns - list of properties, sorted by property index
 */
function sortPropertiesRecords(definition) {
    definition = typeof definition === 'object' ? definition : {};
    const unsortedObjArr = [...Object.entries(definition.properties)];
    if (!definition.properties || Object.keys(definition.properties).length === 0) {
        return unsortedObjArr;
    }
    return unsortedObjArr.sort(sortByPropertyIndex());
}
/**
 * Method receives extension object and returns title/text.
 * @param extension - custom extension object from manifest.
 * @returns Title/text of custom extension.
 */
function getExtensionText(extension) {
    let text;
    if ('header' in extension) {
        text = extension.header;
    }
    else if ('text' in extension) {
        text = extension.text;
    }
    else if ('title' in extension) {
        text = extension.title;
    }
    else if ('label' in extension) {
        text = extension.label;
    }
    return text;
}
/**
 * Adds a custom extension to the right position of a sorted array
 * @param extension - custom extension
 * @param sortedExtensionsArray - array of all entries(annotation entries and extensions), to be enhanced
 * @param targetIndex - index of the anchor entry
 * @param extId - ID of the new custom extension
 * @param newExtensionReference - schema reference of the new extension
 */
function addExtensionToSortedArray(extension, sortedExtensionsArray, targetIndex, extId, newExtensionReference) {
    const placement = extension.position?.placement || ux_specification_types_1.v4.Placement.After;
    if (placement === ux_specification_types_1.v4.Placement.Before) {
        sortedExtensionsArray.splice(targetIndex, 0, [extId, newExtensionReference]);
    }
    else {
        sortedExtensionsArray.splice(targetIndex + 1, 0, [extId, newExtensionReference]);
    }
}
/**
 * Adds remaining custom extensions that might self-reference and were not added in previous steps
 * @param {CustomExtensions} remainingExtensions - list of custom extensions that are left for post-processing
 * @param {string} extId - current id of remaining extensions
 * @param {CustomExtension} extension - current extension of remaining custom extensions
 * @param {[string, unknown]} sortedExtArray - sorted array of annotation-based extensions, to be updated
 * @param { $ref, description, key } newCustomExt - description based on extension in manifest
 */
function addRemainingTargetByBefore(remainingExtensions, extId, extension, sortedExtArray, newCustomExt) {
    const targetRemainingIndex = Object.entries(remainingExtensions)
        .filter(([key]) => key !== extId)
        .findIndex(([_key, entry]) => entry.position?.placement === 'Before' && entry.position?.anchor === extension.position?.anchor);
    if (targetRemainingIndex === -1) {
        sortedExtArray.splice(sortedExtArray.length, 0, [extId, newCustomExt]);
        delete remainingExtensions[extId];
    }
}
/**
 * Post-processing of custom extensions that are left after the first loop of adding extensions, i.e. custom extensions referring to other custom extensions
 * @param remainingExtensions - list of custom extensions that are left for post-processing
 * @param extensionDefinitionName - custom extension definition name, different in LR and OP
 * @param sortedExtArray - sorted array of annotation-based extensions, to be updated
 * @param logger - logger for error messages
 * @param {boolean} forceAdd - add self-referencing custom extensions after other additions
 */
function adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger, forceAdd = false) {
    const initialRemaining = Object.entries(remainingExtensions).length;
    const getExtensionDetails = (extension, extId) => {
        const description = getExtensionText(extension);
        return {
            $ref: `${utils_1.DEFINITION_LINK_PREFIX}${extensionDefinitionName}`,
            description,
            keys: [{ name: ux_specification_types_1.SchemaKeyName.key, value: `${extId}` }]
        };
    };
    for (const extId in remainingExtensions) {
        const extension = remainingExtensions[extId];
        // Detect description based on extension in manifest
        const newCustomExt = getExtensionDetails(extension, extId);
        if (extension.position?.anchor && extension.position?.placement) {
            const targetIndex = sortedExtArray.findIndex((element) => element[0] === extension.position.anchor);
            if (targetIndex > -1) {
                addExtensionToSortedArray(extension, sortedExtArray, targetIndex, extId, newCustomExt);
                delete remainingExtensions[extId];
            }
            else if (extId === extension.position.anchor ||
                Object.keys(remainingExtensions).indexOf(extension.position.anchor) === -1) {
                (0, __1.log)(logger, {
                    severity: "error" /* LogSeverity.Error */,
                    message: i18next_1.default.t('INVALIDANCHOR', { id: extId, anchor: extension.position.anchor }),
                    location: {
                        path: ux_specification_types_1.MANIFESTPATH,
                        range: [ux_specification_types_1.ManifestSection.generic]
                    }
                });
                sortedExtArray.splice(sortedExtArray.length, 0, [extId, newCustomExt]);
                delete remainingExtensions[extId];
            }
            else if (forceAdd) {
                addRemainingTargetByBefore(remainingExtensions, extId, extension, sortedExtArray, newCustomExt);
            }
        }
        else if (forceAdd) {
            addExtensionToSortedArray(extension, sortedExtArray, sortedExtArray.length, extId, newCustomExt);
            delete remainingExtensions[extId];
        }
    }
    const endRemaining = Object.entries(remainingExtensions).length;
    if (endRemaining > 0 && initialRemaining !== endRemaining) {
        adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger);
    }
    else if (endRemaining > 0) {
        adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger, true);
    }
}
/**
 * Returns anchor for extension. Priority:
 * 1. 'anchor' property in extension;
 * 2. When 'anchor' is not defined in extension and does calculation based placement and current list of extension and annotation entries.
 * @param extension - extension in manifest
 * @param sortedExtensionsArray - sorted array of annotation-based nodes, to be enhanced by extensions
 */
function getExtensionAnchor(extension, sortedExtensionsArray) {
    // Default placement is After
    const placement = extension.position?.placement || ux_specification_types_1.v4.Placement.After;
    let anchor = extension.position?.anchor;
    if (!anchor) {
        // Simulate runtime behavior - if there no anchor, then logic uses first or last annotation node
        // In some cases last extension can be previously inserted extension - in such case we still need use annotation node
        const index = placement === ux_specification_types_1.v4.Placement.Before ? 0 : sortedExtensionsArray.length - 1;
        anchor = sortedExtensionsArray[index] ? sortedExtensionsArray[index][0] : undefined;
    }
    return anchor;
}
/**
 * Preprocesses and returns list of local extension ids that needs to be skipped from addition
 * @param {CustomExtensions} localExtensions - list of extensions in manifest
 * @param {[string, unknown][]} annotationEntries - sorted array of annotation-based nodes, to be enhanced by extensions
 */
function getLocalExtensionsToSkip(localExtensions, annotationEntries) {
    // collect local extensions that has no annotation based anchor
    const ignoredIds = [];
    for (const extensionId in localExtensions) {
        const anchor = localExtensions[extensionId].position?.anchor;
        const hasAnnotationAnchor = annotationEntries.some((annotationEntry) => annotationEntry[0] === anchor);
        if (anchor && !hasAnnotationAnchor) {
            ignoredIds.push(extensionId);
        }
    }
    return ignoredIds;
}
/**
 * Method returns position of passed extension using calculation for merged annotation nodes approach.
 * Currently is used for custom subsections - annotation merges subsection if there is no any child collecation facet.
 * @param extension - custom extension
 * @param extensions - list of extensions in manifest
 * @param sortedExtensionsArray - array of all entries(annotation entries and extensions), to be enhanced
 *
 * @returns Index of extension using merged annotation nodes approach.
 */
function getExtensionIndexByMergedApproach(extension, extensions, sortedExtensionsArray) {
    const placement = extension.position?.placement || ux_specification_types_1.v4.Placement.After;
    const originalAnchor = extension.position?.anchor;
    if (originalAnchor) {
        // Custom extension is anchored to any extension
        return sortedExtensionsArray.length;
    }
    // Custom extension is not anchored to any extension
    // Inner method to find next available index before or after annotation node
    const findNextIndex = (index, condition) => {
        for (const sortExtension of sortedExtensionsArray) {
            const innerExtension = extensions[sortExtension[0]];
            if (condition(innerExtension)) {
                // Condition is fulfilled - no need to increase index
                break;
            }
            // Increase index and check next ordered extension
            index++;
        }
        return index;
    };
    let index = 0;
    if (placement === ux_specification_types_1.v4.Placement.Before) {
        // Special case when no anchor but placement is "Before" - then rendered as very first
        // Find index before first annotation node
        index = findNextIndex(0, (innerExtension) => !innerExtension);
    }
    else {
        // Special case when no anchor but placement is "After" - then rendered right after last annotation node
        index = findNextIndex(-1, (innerExtension) => !!(innerExtension &&
            // Ignore extension without anchor but with position "Before"
            (innerExtension?.position?.anchor || innerExtension?.position?.placement !== ux_specification_types_1.v4.Placement.Before)));
    }
    return index > -1 ? index : 0;
}
/**
 *
 * @param extension - custom extension
 * @param extensions - list of extensions in manifest
 * @param sortedExtensionsArray - array of all entries(annotation entries and extensions), to be enhanced
 * @param anchor - target anchor to check
 * @param ignoreAnnotationAnchors - calculation should ignore anchors referenced to annotation nodes. Used when annotations sections are merged
 *
 * @returns Index of extension using merged annotation nodes approach.
 */
function getExtensionIndex(extension, extensions, sortedExtensionsArray, anchor, ignoreAnnotationAnchors = false) {
    return !ignoreAnnotationAnchors
        ? sortedExtensionsArray.findIndex((element) => element[0] === anchor)
        : getExtensionIndexByMergedApproach(extension, extensions, sortedExtensionsArray);
}
/**
 * Adds extension at the right position of the sorted array of annotation-based nodes
 * @param extensions - list of extensions in manifest
 * @param sortedExtensionsArray - sorted array of annotation-based nodes, to be enhanced by extensions
 * @param extensionDefinitionName - extension definition name, different in LR and OP
 * @param logger - logger for error messages
 * @param ignoreAnnotationAnchors - calculation should ignore anchors referenced to annotation nodes. Used when annotations sections are merged.
 */
function addExtensionToArray(extensions, sortedExtensionsArray, extensionDefinitionName, templatePropertyName = 'template', logger, ignoreAnnotationAnchors = false) {
    const annotationEntries = [...sortedExtensionsArray];
    const localExtensions = { ...extensions };
    const localExtensionsToSkip = getLocalExtensionsToSkip(localExtensions, annotationEntries);
    for (const extensionId in localExtensions) {
        if (localExtensionsToSkip?.includes(extensionId)) {
            continue;
        }
        const extension = localExtensions[extensionId];
        if (!(templatePropertyName in extension)) {
            // Skip regular entries(columns, actions, etc.)
            delete localExtensions[extensionId];
            continue;
        }
        const newExtensionReference = {
            $ref: `${utils_1.DEFINITION_LINK_PREFIX}${extensionDefinitionName}`,
            description: getExtensionText(extension) || extensionId,
            keys: [{ name: ux_specification_types_1.SchemaKeyName.key, value: `${extensionId}` }],
            actionType: ux_specification_types_1.ActionType.Custom
        };
        const anchor = getExtensionAnchor(extension, annotationEntries);
        if (anchor) {
            const targetIndex = getExtensionIndex(extension, extensions, sortedExtensionsArray, anchor, ignoreAnnotationAnchors);
            if (targetIndex > -1) {
                addExtensionToSortedArray(extension, sortedExtensionsArray, targetIndex, extensionId, newExtensionReference);
                delete localExtensions[extensionId];
            }
        }
        else {
            // Empty array - no any anchor to reference to
            sortedExtensionsArray.push([extensionId, newExtensionReference]);
            delete localExtensions[extensionId];
        }
    }
    if (Object.keys(localExtensions).length > 0) {
        //Second loop is necessary for custom columns that refer to custom columns
        adjustCustomExtReferringToCustomExt(localExtensions, extensionDefinitionName, sortedExtensionsArray, logger);
    }
    return sortedExtensionsArray;
}
exports.addExtensionToArray = addExtensionToArray;
/**
 * Common function for enhancing the LineItems definition of app schema by custom columns
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customColumnDefinitionName - custom column definition name
 * @param sectionId - identifier of the current object page section in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addCustomColumnDefinition(appSchema, v4Page, logger, customColumnDefinitionName = ux_specification_types_1.DefinitionName.CustomColumn, sectionId, sectionIdInManifest) {
    const lineItemId = sectionId || ux_specification_types_1.DefinitionName.LineItems;
    const lineItems = appSchema.definitions[lineItemId];
    if (!lineItems) {
        return;
    }
    //sort line items
    let sortedColumnsArray = sortPropertiesRecords(lineItems);
    const id = sectionIdInManifest ? sectionIdInManifest.replace(/::/g, '/') : `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
    const columns = v4Page.options?.settings?.controlConfiguration?.[id]?.['columns'];
    if (columns) {
        sortedColumnsArray = addExtensionToArray(columns, sortedColumnsArray, customColumnDefinitionName, undefined, logger);
    }
    //Adjust propertyIndex
    for (let index = 0; index < sortedColumnsArray.length; index++) {
        sortedColumnsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    }
    const sortedColumnsAsObject = {};
    sortedColumnsArray.forEach(([key, value]) => (sortedColumnsAsObject[key] = value));
    appSchema.definitions[lineItemId].properties = sortedColumnsAsObject;
}
exports.addCustomColumnDefinition = addCustomColumnDefinition;
/**
 * Determines the name of the action in schema
 * @param {LineItemDataForSchema} data - data of the the LineItem
 *
 * @returns the name of the action
 */
function determineActionDefinitionName(data) {
    let actionDefinitionName;
    if (data.lineItemId.startsWith(ux_specification_types_1.DefinitionName.LineItemsOfView)) {
        actionDefinitionName = ux_specification_types_1.DefinitionName.ViewToolBarAction;
    }
    else if (data.lineItemId.startsWith(ux_specification_types_1.DefinitionName.LineItems)) {
        actionDefinitionName = ux_specification_types_1.DefinitionName.ToolBarAction;
    }
    else {
        actionDefinitionName = ux_specification_types_1.DefinitionName.ObjectPageToolBarAction;
    }
    return actionDefinitionName;
}
/**
 * Adds the schema tags 'keys' and 'target' to the schema definition of an action
 * @param {SchemaDefinition} actionDefinition - current action definition in the app schema
 * @param {DataFieldForActionAbstractTypes} lineItemRecord - actual record of the line item collection
 * @param {string} actionId - ID of the action, according to the lineItem definition
 */
function addTargetAndKeysOfAction(actionDefinition, lineItemRecord, actionId) {
    actionDefinition[ux_specification_types_1.SchemaTag.keys] = [];
    if (lineItemRecord[ux_specification_types_1.SchemaKeyName.semanticObject]) {
        actionDefinition[ux_specification_types_1.SchemaTag.keys].push({
            name: ux_specification_types_1.SchemaKeyName.semanticObject,
            value: lineItemRecord[ux_specification_types_1.SchemaKeyName.semanticObject]
        });
    }
    const { key, ns } = (0, common_1.getActionKey)(actionId, true);
    actionDefinition[ux_specification_types_1.SchemaTag.keys].push({ name: ux_specification_types_1.SchemaKeyName.action, value: key });
    if (ns) {
        actionDefinition[ux_specification_types_1.SchemaTag.target] = ns;
    }
}
/**
 * Processes a LineItem record of type DataFieldForAction during app schema generation
 * @param {LineItemDataForSchema} data: structure of input data
 * @param {Definition} actions - actions definition in schema, parent object
 * @param {string} lineItemPath - annotation path to the line item
 * @param {DataFieldForActionAbstractTypes} lineItemRecord - actual record of the line item collection
 * @param {number} recordIndex - record index in the collection
 * @param {boolean} createRef - defines whether the $ref attribute should be created for the action
 */
function addActionRecordToSchema(data, actionsDefinition, lineItemPath, lineItemRecord, recordIndex, createRef = true) {
    // Action but not inline action
    if (lineItemRecord.Determining === true) {
        return;
    }
    //no footer bar -> toolbar action
    const actionDefinitionName = determineActionDefinitionName(data);
    const description = (0, utils_1.getDataFieldDescription)(lineItemRecord, data.entityType);
    const prefix = lineItemRecord.$Type.split(`${ux_specification_types_1.UIVOCABULARY}.`)[1];
    const actionId = typeof lineItemRecord.Action === 'string' ? lineItemRecord.Action : lineItemRecord.Action['path'];
    const propertyKey = (0, StableIdHelper_1.replaceSpecialChars)(actionId);
    const actionDefinition = (actionsDefinition.properties[`${prefix}::${propertyKey}`] = {
        description
    });
    if (createRef) {
        actionDefinition.$ref = (0, common_1.getFacetDefinitionLink)(actionDefinitionName, (0, common_1.prepareRef)(propertyKey));
    }
    else {
        actionDefinition.properties = {};
        actionDefinition.type = 'object';
        actionDefinition.isViewNode = true;
    }
    actionDefinition[ux_specification_types_1.SchemaTag.propertyIndex] = recordIndex;
    actionDefinition[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataType)(lineItemRecord);
    //keys
    addTargetAndKeysOfAction(actionDefinition, lineItemRecord, actionId);
    actionDefinition[ux_specification_types_1.SchemaTag.annotationType] = lineItemRecord.$Type;
    if (createRef) {
        const action = (0, common_1.parseSchemaDefinition)(actionDefinitionName, (0, common_1.prepareRef)(propertyKey), data.appSchema);
        action[ux_specification_types_1.SchemaTag.annotationPath] = `${lineItemPath}/${recordIndex}`;
    }
    else {
        actionDefinition[ux_specification_types_1.SchemaTag.annotationPath] = `${lineItemPath}/${recordIndex}`;
    }
}
/**
 * Processes a LineItem record of type DataField during app schema generation
 * @param {LineItemDataForSchema} data: structure of input data
 * @param {object} lineItem - object comprising the line item information:
 * { lineItemRecord, lineItemId, lineItemPath }
 * @param {string} columnDefinitionName - Schema definition name for the column
 * @param {number} recordIndex - record index in the collection
 * @param {Definition | undefined} lineItemDefinition - line item definition
 */
function addLineItemRecordToSchema(data, lineItem, columnDefinitionName, recordIndex, lineItemDefinition) {
    const lineItemId = lineItem['lineItemId'];
    const lineItemRecord = lineItem['lineItemRecord'];
    if (lineItemRecord['Target']?.['value']) {
        const regex = `@${(0, utils_1.findAlias)(ux_specification_types_1.UIVOCABULARY, data.oDataServiceAVT)}.`;
        lineItemRecord['Target']['value'] = lineItemRecord['Target']['value'].replace(regex, '@');
    }
    const schemaKey = (0, StableIdHelper_1.getStableIdPartFromDataField)(lineItemRecord).replace(/\//g, '::');
    if (schemaKey) {
        let columnsDefinition = lineItemDefinition;
        if (!columnsDefinition) {
            columnsDefinition = data.appSchema.definitions[lineItemId];
        }
        const properties = columnsDefinition.properties;
        const property = {
            description: (0, utils_1.getDataFieldDescription)(lineItemRecord, data.entityType)
        };
        if (lineItemDefinition) {
            property.properties = {};
            property.type = 'object';
            property.isViewNode = true;
        }
        else {
            property.$ref = utils_1.DEFINITION_LINK_PREFIX + columnDefinitionName;
        }
        property[ux_specification_types_1.SchemaTag.annotationType] = lineItemRecord?.$Type;
        property[ux_specification_types_1.SchemaTag.annotationPath] = `${lineItem['lineItemPath']}/${recordIndex}`;
        property[ux_specification_types_1.SchemaTag.propertyIndex] = recordIndex;
        property[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataType)(lineItemRecord);
        properties[schemaKey] = property;
        (0, common_1.addKeyToDefinition)(lineItemRecord, properties, schemaKey);
    }
}
/**
 * Appends line item columns and actions to the app schema (for the list report, custom page or an object page section comprising a table)
 * @param {LineItemDataForSchema} data: structure comprising
 * - appSchema - the app specific schema that shall get enhanced
 * - lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * - entityType - the entity type as part of the AVT ConvertedMetadata
 * - oDataServiceAVT - complete service information, as returned by Annotation Vocabularies Tool
 * - lineItemId - in case of OP the parameter must be passed to distinguish the OP tables;
 *                in case of LR or ALP 'LineItems' is passed.
 * @param {Definition} actions - actions definition in schema, parent object
 * @param {string} lineItemPath - annotation path to the line item
 * @param {Definition | undefined} lineItemDefinition - line item definition
 * @param {string} columnDefinitionName - line item definition name
 */
function appendLineItemsToSchema(data, actions, lineItemPath, lineItemDefinition, columnDefinitionName = ux_specification_types_1.DefinitionName.TableColumn) {
    if (!data.lineItemAnnotation) {
        return;
    }
    let i = 0;
    data.lineItemAnnotation.forEach((lineItemRecord) => {
        if ((lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */ ||
            lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* UIAnnotationTypes.DataFieldForIntentBasedNavigation */) &&
            (lineItemRecord.Inline !== true || lineItemRecord.Determining === true)) {
            addActionRecordToSchema(data, actions, lineItemPath, lineItemRecord, i, !lineItemDefinition);
        }
        else {
            const lineItem = { lineItemRecord, lineItemId: data.lineItemId, lineItemPath };
            const columnDefinition = lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */
                ? `${columnDefinitionName}Action`
                : columnDefinitionName;
            addLineItemRecordToSchema(data, lineItem, columnDefinition, i, lineItemDefinition);
        }
        i++;
    });
}
exports.appendLineItemsToSchema = appendLineItemsToSchema;
/**
 * Adds the line item definition, columns and actions to the app schema (for the list report, custom page or an object page section comprising a table
 * @param {LineItemDataForSchema} data: structure comprising
 * - appSchema - the app specific schema that shall get enhanced
 * - lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * - entityType - the entity type as part of the AVT ConvertedMetadata
 * - oDataServiceAVT - complete service information, as returned by Annotation Vocabularies Tool
 * - lineItemId - in case of OP the parameter must be passed to distinguish the OP tables;
 *                in case of LR or ALP 'LineItems' is passed.
 * @param {string} columnDefinitionName - name of the column definition, i.e. TableColumn or ObjectPageTableColumn
 * @param {string} customColumnDefinitionName - name of the custom column definition
 * @param {string} customColumnDefinitionName - name of the custom action definition
 */
function addLineItemsTypeToSchema(data, columnDefinitionName = ux_specification_types_1.DefinitionName.TableColumn, customColumnDefinitionName = ux_specification_types_1.DefinitionName.CustomColumn, customActionDefinitionName = ux_specification_types_1.DefinitionName.CustomTableAction) {
    const { actions, lineItemPath } = (0, common_1.addCommonLineItemDefinitions)(data.appSchema, data.lineItemAnnotation, data.entityType, data.lineItemId, customColumnDefinitionName, customActionDefinitionName);
    appendLineItemsToSchema(data, actions, lineItemPath, undefined, columnDefinitionName);
}
exports.addLineItemsTypeToSchema = addLineItemsTypeToSchema;
/**
 * Adds an enum or value help to position > anchor of custom column
 * @param appSchema - app specific JSON schema
 * @param lineItemId - ID of the current line item in schema
 * @param v4Page - current page in manifest
 * @param positionName - ID of the definition of custom column position in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addFragmentEnumForAnchor(appSchema, lineItemId, v4Page, positionName = ux_specification_types_1.DefinitionName.Position, sectionIdInManifest) {
    const columns = appSchema.definitions[lineItemId]?.properties;
    const enumEntries = [];
    if (columns) {
        for (const key in columns) {
            if (key !== 'custom') {
                enumEntries.push(key);
            }
        }
    }
    const id = lineItemId !== ux_specification_types_1.DefinitionName.LineItems ? sectionIdInManifest : `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
    const columnsInManifest = v4Page.options?.settings?.controlConfiguration?.[id]?.['columns'];
    if (columnsInManifest) {
        for (const key in columnsInManifest) {
            if (enumEntries.indexOf(key) === -1) {
                enumEntries.push(key);
            }
        }
    }
    if (enumEntries.length > 0) {
        const anchor = appSchema.definitions[positionName].properties.anchor;
        (0, common_1.addEnumToSchema)(enumEntries, anchor);
    }
}
exports.addFragmentEnumForAnchor = addFragmentEnumForAnchor;
/**
 * Adds an enum or value help to position > anchor of custom column
 * @param appSchema - app specific JSON schema
 * @param definitionId - definition key of actions
 * @param positionName - target definition to update
 */
function addEnumForActionAnchor(appSchema, definitionId, positionName = ux_specification_types_1.DefinitionName.CustomActionPosition) {
    (0, common_1.addDescriptiveEnumDefinition)(appSchema, appSchema.definitions[definitionId], {
        definition: positionName,
        property: 'anchor'
    }, {
        resolveDefinition: true
    });
}
exports.addEnumForActionAnchor = addEnumForActionAnchor;
/**
 * Find the relevant V4 page under the routing targets of manifest,json
 * @param pages - list of all pages in manifest
 * @param pageName - search criterion: page name
 * @param entitySet - search criterion: entity set object from AVT
 * @param contextPath - search criterion: contextPath
 * @returns the page definition in manifest (if found)
 */
function findPageV4(pages, pageName, entitySet, contextPath) {
    let v4Page;
    for (const i in pages) {
        if (((contextPath && pages[i].options?.settings?.contextPath === contextPath) ||
            pages[i].options?.settings?.entitySet === entitySet?.name) &&
            (pages[i].name === pageName ||
                (pageName === ux_specification_types_1.v4.FE_TEMPLATE_V4_ALP && pages[i].name === ux_specification_types_1.v4.FE_TEMPLATE_V4_LIST_REPORT))) {
            v4Page = pages[i];
            break;
        }
    }
    return v4Page;
}
exports.findPageV4 = findPageV4;
/**
 * Depending on the template type, strip down the app schema so that only the relevant views are part of it
 * @param {Definition} appSchema - app specific JSON schema, to be adjusted
 * @param {GenerateAppSchemaParameters} generateParameters - object comprising all input parameters
 * @returns the right definition name for the table in the schema
 */
function alignSchemaWithTemplateType(appSchema, generateParameters) {
    let tableDefinitionName;
    const tableDefinition = appSchema.properties[ux_specification_types_1.PropertyName.table];
    if (generateParameters.templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV4) {
        tableDefinitionName = ux_specification_types_1.DefinitionName.ALPTableView;
        delete tableDefinition.anyOf;
        tableDefinition.$ref = `${utils_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ALPTableView}`;
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.Table];
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.LRChartView];
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.LRTableView];
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.MultiTableModeV4];
    }
    else if (generateParameters.templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4) {
        tableDefinitionName = ux_specification_types_1.DefinitionName.Table;
        delete tableDefinition.anyOf;
        tableDefinition.$ref = `${utils_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.Table}`;
        appSchema.definitions[tableDefinitionName].properties[ux_specification_types_1.PropertyName.annotationPath][ux_specification_types_1.SchemaTag.hidden] = true;
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTableView];
        appSchema.properties[ux_specification_types_1.PropertyName.defaultPath][ux_specification_types_1.SchemaTag.hidden] = true;
    }
    return tableDefinitionName;
}
exports.alignSchemaWithTemplateType = alignSchemaWithTemplateType;
/**
 * Common function for enhancing LineItems and FieldGroups definitions of app schema by custom action definitions
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customActionDefinitionName - definition name of custom action
 * @param sectionId - identifier of the current object page section in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addCustomActionDefinition(appSchema, v4Page, logger, customActionDefinitionName = ux_specification_types_1.DefinitionName.CustomTableAction, sectionId = '', sectionIdInManifest = '') {
    const definition = appSchema.definitions[sectionId];
    if (!definition) {
        return;
    }
    // Sort existing actions
    let sortedActionsArray = sortPropertiesRecords(definition);
    let configId;
    if (sectionIdInManifest) {
        if (customActionDefinitionName.indexOf(ux_specification_types_1.DefinitionName.CustomFormActionOP) !== -1) {
            configId = sectionIdInManifest.replace(/::/g, '#');
        }
        else {
            configId = sectionIdInManifest.replace(/::/g, '/');
        }
    }
    else {
        if (customActionDefinitionName === ux_specification_types_1.DefinitionName.CustomFormActionOP) {
            configId = `@${"com.sap.vocabularies.UI.v1.FieldGroup" /* UIAnnotationTerms.FieldGroup */}`;
        }
        else {
            configId = `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
        }
    }
    const actions = v4Page.options?.settings?.controlConfiguration?.[configId]?.['actions'];
    if (actions) {
        sortedActionsArray = addExtensionToArray(actions, sortedActionsArray, customActionDefinitionName, 'press', logger);
    }
    // Adjust propertyIndex
    if (sortedActionsArray) {
        for (let index = 0; index < sortedActionsArray.length; index++) {
            sortedActionsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
        }
        const sortedActionsAsObject = {};
        sortedActionsArray.forEach(([key, value]) => (sortedActionsAsObject[key] = value));
        appSchema.definitions[sectionId].properties = sortedActionsAsObject;
    }
}
exports.addCustomActionDefinition = addCustomActionDefinition;
/**
 * Common function for enhancing header and footer definitions of app schema by custom action definitions
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customActionDefinitionName - definition name of custom action
 * @param sectionId - identifier of the current object page section in schema
 */
function addHeaderFooterCustomActionDefinition(appSchema, v4Page, logger, customActionDefinitionName = ux_specification_types_1.DefinitionName.CustomHeaderActionOP, sectionId = '') {
    const definition = appSchema.definitions[sectionId];
    if (!definition) {
        return;
    }
    // Sort existing actions
    let sortedActionsArray = sortPropertiesRecords(definition);
    let actions;
    if ([ux_specification_types_1.DefinitionName.CustomHeaderAction, ux_specification_types_1.DefinitionName.CustomHeaderActionOP].includes(customActionDefinitionName)) {
        actions = v4Page.options?.settings?.content?.header?.['actions'];
    }
    else {
        actions = v4Page.options?.settings?.content?.footer?.['actions'];
    }
    if (actions) {
        sortedActionsArray = addExtensionToArray(actions, sortedActionsArray, customActionDefinitionName, 'press', logger);
    }
    // Adjust propertyIndex
    const sortedActionsAsObject = {};
    if (sortedActionsArray) {
        for (let index = 0; index < sortedActionsArray.length; index++) {
            sortedActionsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
        }
        sortedActionsArray.forEach(([key, value]) => (sortedActionsAsObject[key] = value));
    }
    appSchema.definitions[sectionId].properties = sortedActionsAsObject;
}
exports.addHeaderFooterCustomActionDefinition = addHeaderFooterCustomActionDefinition;
/**
 * Method returns page from manifest by passed page key.
 * @param manifest Object from manifest.json.
 * @param pageId Page id.
 * @param logger Logger to report error of unexisting page.
 * @returns Manifest's target page.
 */
function getManifestPage(manifest, pageId, logger) {
    const pages = (0, utils_1.getJSONPropertyByPath)(manifest, [
        ux_specification_types_1.ManifestSection.ui5,
        'routing',
        'targets'
    ]);
    if (!pages) {
        (0, __1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOTARGETS'),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    const page = (0, utils_1.getJSONPropertyByPath)(pages, [pageId]);
    if (!page) {
        (0, __1.log)(logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOROUTINGID', { routingId: pageId }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    return page;
}
exports.getManifestPage = getManifestPage;
/**
 * Method finds custom view/section XML file for passed page.
 * @param files All extension files.
 * @param pageId Page id.
 * @param manifest Object from manifest.json.
 * @param xmlType XML file type - view or fragment.
 * @param extensionName Extension namespace or path to extension name in page object.
 * @returns Custom page's data containing XML file.
 */
function getPageCustomExtensionFile(files, page, manifest, xmlType, extensionName) {
    if (extensionName) {
        const appId = manifest['sap.app']?.id || '';
        const fileExtension = 'xml';
        if (extensionName.startsWith(appId)) {
            // Remove app id from extension name
            extensionName = extensionName.replace(appId, '');
        }
        const fileParts = extensionName.split('.');
        let baseName = fileParts.pop();
        baseName = `${baseName}.${xmlType}.${fileExtension}`;
        const extPath = (0, path_1.join)(...fileParts, baseName);
        const file = files.find((file) => file.dataSourceUri.endsWith(extPath));
        if (file) {
            const settings = page.options?.settings;
            return {
                file,
                relativeFilePath: extPath,
                connection: {
                    contextPath: settings?.contextPath,
                    entitySet: settings?.entitySet
                }
            };
        }
    }
    return undefined;
}
exports.getPageCustomExtensionFile = getPageCustomExtensionFile;
/**
 * Method finds view XML file for passed page.
 * @param files All view files.
 * @param pageId Page id.
 * @param manifest Object from manifest.json.
 * @param logger Logger.
 * @returns Custom page's data containing view XML file.
 */
function getPageCustomViewFile(files, pageId, manifest, logger) {
    const page = getManifestPage(manifest, pageId, logger);
    const viewName = (0, utils_1.getJSONPropertyByPath)(page, ['options', 'settings', 'viewName']);
    return page && typeof viewName === 'string'
        ? getPageCustomExtensionFile(files, page, manifest, 'view', viewName)
        : undefined;
}
exports.getPageCustomViewFile = getPageCustomViewFile;
/**
 * Adds custom header or custom sub section definitions to app schema
 * @param appSchema - app-specific JSON schema
 * @param definition - sections definition
 * @param v4Page - actual page in the manifest
 * @param customSectionRef - value of custom section ref
 * @param isMergedSections - are merged section used
 * @param facetKey - facet key
 * @param logger - logger for error messages
 */
function addCustomSectionDefinition(appSchema, definition, v4Page, customSectionRef, isMergedSections, facetKey, logger) {
    let sortedSectionsArray = sortPropertiesRecords(definition);
    const annotationSectionsMap = new Map();
    sortedSectionsArray = sortedSectionsArray.map((annotationSection) => {
        const entry = (0, common_1.getEnumEntry)(appSchema, annotationSection[1], annotationSection[0], {
            keyProperties: [ux_specification_types_1.SchemaKeyName.id],
            descriptionAsFallback: true,
            resolveDefinition: true
        });
        annotationSectionsMap.set(entry.const, annotationSection[0]);
        return [entry.const, annotationSection[1]];
    });
    if (facetKey) {
        // check for already defined section
        const section = v4Page.options?.settings?.content?.body?.sections?.[facetKey];
        if (section && 'subSections' in section) {
            // add extension to subsection of section
            sortedSectionsArray = addExtensionToArray(section.subSections, sortedSectionsArray, customSectionRef, 'template', logger, isMergedSections);
        }
    }
    else {
        // it is header section
        const header = v4Page.options?.settings?.content?.header;
        if (header && 'facets' in header) {
            // add extension to header section
            sortedSectionsArray = addExtensionToArray(header.facets, sortedSectionsArray, customSectionRef, 'template', logger, isMergedSections);
        }
    }
    // Adjust propertyIndex
    for (let index = 0; index < sortedSectionsArray.length; index++) {
        sortedSectionsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    }
    const sortedActionsAsObject = {};
    sortedSectionsArray.forEach(([key, value]) => {
        key = annotationSectionsMap.get(key) || key;
        sortedActionsAsObject[key] = value;
    });
    definition.properties = sortedActionsAsObject;
}
exports.addCustomSectionDefinition = addCustomSectionDefinition;
/**
 * Method adds custom filter fields from manifest to schema properties.
 * @param appSchema - app-specific JSON schema
 * @param definition - filter fields definition
 * @param v4Page - actual page in the manifest
 */
function addCustomFilterFieldDefinition(appSchema, definition, v4Page) {
    let sortedFilterFieldsArray = sortPropertiesRecords(definition);
    const annotationSectionsMap = new Map();
    sortedFilterFieldsArray = sortedFilterFieldsArray.map((annotationSection) => {
        const entry = (0, common_1.getEnumEntry)(appSchema, annotationSection[1], annotationSection[0], {
            keyProperties: [ux_specification_types_1.SchemaKeyName.value],
            descriptionAsFallback: true,
            resolveDefinition: true
        });
        annotationSectionsMap.set(entry.const, annotationSection[0]);
        return [entry.const, annotationSection[1]];
    });
    // check for already defined section
    const selectionFieldsEntry = v4Page.options?.settings?.controlConfiguration?.[`@${"com.sap.vocabularies.UI.v1.SelectionFields" /* UIAnnotationTerms.SelectionFields */}`];
    if (typeof selectionFieldsEntry === 'object' && 'filterFields' in selectionFieldsEntry) {
        // add extension to subsection of section
        sortedFilterFieldsArray = addExtensionToArray(selectionFieldsEntry.filterFields, sortedFilterFieldsArray, ux_specification_types_1.DefinitionName.CustomFilterField, 'template');
    }
    // Adjust propertyIndex
    for (let index = 0; index < sortedFilterFieldsArray.length; index++) {
        sortedFilterFieldsArray[index][1][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    }
    const sortedFilterFieldsAsObject = {};
    sortedFilterFieldsArray.forEach(([key, value]) => {
        key = annotationSectionsMap.get(key) || key;
        sortedFilterFieldsAsObject[key] = value;
    });
    definition.properties = sortedFilterFieldsAsObject;
}
exports.addCustomFilterFieldDefinition = addCustomFilterFieldDefinition;
//# sourceMappingURL=utils.js.map