"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateObjectPageSchemaV4 = void 0;
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../extensionLogger");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const common_1 = require("../../common");
const utils_1 = require("../utils/utils");
const utils_2 = require("../utils/utils");
const StableIdHelper_1 = require("../../v4/utils/StableIdHelper");
const pageExtensions_1 = require("./fpm-custom-page/pageExtensions");
const utils_3 = require("../../v2/generate/utils");
const ROOT_PROPERTIES_ORDER = ['header', 'layout', 'sections', 'footer'];
const CRITICAL_ACTION_TYPES = [
    'UI.CriticalityType/Positive',
    'UI.CriticalityType/VeryPositive',
    'UI.CriticalityType/Negative',
    'UI.CriticalityType/VeryNegative'
];
const CUSTOM_ACTION_DEFINITION_DESCRIPTION = 'Custom Action';
/**
 * V4 callback - adds a single header action to schema
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ActionListType} action - item of the Ui.Identification collection and its original index
 * @param {ActionType} actionType - action classification for grouping
 * @param {Definition} appSchema Schema of the app
 * @param {EntityType} entityType - current entity type
 * @param {Definition} headerActions - list of header actions, to be enhanced
 */
function addSingleHeaderActionV4(oDataServiceAVT, action, actionType, appSchema, entityType, headerActions, index) {
    const { actionName, namespace } = (0, common_1.getActionNameAndId)(action.item, oDataServiceAVT);
    const stableId = (0, StableIdHelper_1.getStableIdPartFromDataField)(action.item);
    //stableId is used as key in V4, as the DataFieldForAction:: prefix shall be present in manifest settings
    const convertedIdentification = action.item['fullyQualifiedName'].replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`);
    const actionDefinitionKey = `ObjectPageHeaderAction<${(0, common_1.prepareRef)(stableId)}>`;
    const headerAction = (appSchema.definitions[actionDefinitionKey] = {
        type: 'object',
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ObjectPageHeaderAction}`,
        description: (0, common_1.getDataFieldDescription)(action.item, entityType)
    });
    headerAction[ux_specification_types_1.SchemaTag.isViewNode] = true;
    headerAction[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataType)(action.item);
    headerAction[ux_specification_types_1.SchemaTag.propertyIndex] = index;
    //keys
    headerAction[ux_specification_types_1.SchemaTag.keys] = [];
    if (action.item[ux_specification_types_1.SchemaKeyName.semanticObject]) {
        headerAction[ux_specification_types_1.SchemaTag.keys].push({
            name: ux_specification_types_1.SchemaKeyName.semanticObject,
            value: action.item[ux_specification_types_1.SchemaKeyName.semanticObject]
        });
    }
    headerAction[ux_specification_types_1.SchemaTag.keys].push({ name: ux_specification_types_1.SchemaKeyName.action, value: actionName });
    if (namespace) {
        appSchema.definitions[actionDefinitionKey][ux_specification_types_1.SchemaTag.target] = namespace;
    }
    headerAction[ux_specification_types_1.SchemaTag.actionType] = actionType;
    headerAction[ux_specification_types_1.SchemaTag.annotationPath] = `/${convertedIdentification}`;
    headerActions.properties[stableId] = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
    };
    // add propertyIndexes
    headerActions.properties[stableId][ux_specification_types_1.SchemaTag.propertyIndex] = index;
}
/**
 * Adds a given standard action to the app schema of the object page
 * @param {string} actionName  - name of the action
 * @param {Definition} appSchema - schema of the object page
 * @param {Definition} headerActions - list of header actions, to be enhanced
 * @param {number} index - index for propertyIndex
 *
 * @returns the new header action definition
 */
function addStandardHeaderAction(actionName, appSchema, headerActions, index) {
    const referenceKey = `${actionName}Action`;
    const actionDefinitionKey = `ObjectPageHeaderAction<${referenceKey}>`;
    const headerAction = (appSchema.definitions[actionDefinitionKey] = {
        type: 'object',
        description: `${actionName}`,
        additionalProperties: true
    });
    headerAction[ux_specification_types_1.SchemaTag.isViewNode] = true;
    headerAction[ux_specification_types_1.SchemaTag.propertyIndex] = index;
    //keys
    headerAction[ux_specification_types_1.SchemaTag.keys] = [];
    headerAction[ux_specification_types_1.SchemaTag.keys].push({ name: ux_specification_types_1.SchemaKeyName.action, value: actionName });
    headerAction[ux_specification_types_1.SchemaTag.actionType] = ux_specification_types_1.ActionType.Standard;
    headerActions.properties[referenceKey] = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
    };
    // add propertyIndexes
    headerActions.properties[referenceKey][ux_specification_types_1.SchemaTag.propertyIndex] = index;
    return headerAction;
}
/**
 * V4 callback - adds a single footer action to schema
 * @param {ActionListType} action - item of the Ui.Identification collection and its original index
 * @param {ActionType} actionType - action classification for grouping
 * @param {EntityType} entityType - current entity type
 * @param {Definition} appSchema - schema of the object page
 * @param {Definition} footerActions - list of footer actions, to be enhanced
 */
function addSingleFooterAction(action, actionType, entityType, appSchema, footerActions, index) {
    const actionId = (0, StableIdHelper_1.getStableIdPartFromDataField)(action.item);
    const description = (0, common_1.getDataFieldDescription)(action.item, entityType);
    const actionDefinitionKey = (0, common_1.prepareRef)(`${ux_specification_types_1.DefinitionName.ObjectPageFooterAction}<${actionId}>`);
    const convertedIdentification = action.item['fullyQualifiedName'].replace(`@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`, `/@${"com.sap.vocabularies.UI.v1.Identification" /* UIAnnotationTerms.Identification */}`);
    const footerAction = (appSchema.definitions[actionDefinitionKey] = {
        type: 'object',
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.FooterActionV4}`,
        description: description
    });
    footerAction[ux_specification_types_1.SchemaTag.isViewNode] = true;
    footerAction[ux_specification_types_1.SchemaTag.actionType] = actionType;
    footerAction[ux_specification_types_1.SchemaTag.propertyIndex] = index;
    footerAction[ux_specification_types_1.SchemaTag.annotationPath] = `/${convertedIdentification}`;
    footerActions.properties[actionId] = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${actionDefinitionKey}`
    };
}
/**
 * Distiguishes critical actions and others and returns two separate groups
 * @param {any} identification - UI.Identification annotation as present in AVT ConvertedMetadata
 * @returns two separate groups of items
 */
function groupByCriticality(identification) {
    const criticalActions = [];
    const unCriticalActions = [];
    identification.forEach((item, index) => {
        if ((!item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */) ||
            item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* UIAnnotationTypes.DataFieldForIntentBasedNavigation */) {
            if (CRITICAL_ACTION_TYPES.includes(item['Criticality'])) {
                criticalActions.push({ index, item });
            }
            else {
                unCriticalActions.push({ index, item });
            }
        }
    });
    return { criticalActions, unCriticalActions };
}
/**
 * Adds the critical header actions to schema
 * @param {ActionListType[]} criticalActions - list of critical actions
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {Definition} appSchema - schema of the object page
 * @param {EntityType} entityType - current entity type
 * @param {Definition} headerActions - list of all header actions
 */
function addCriticalActions(criticalActions, oDataServiceAVT, appSchema, entityType, headerActions) {
    for (let index = 0; index < criticalActions.length; index++) {
        addSingleHeaderActionV4(oDataServiceAVT, criticalActions[index], ux_specification_types_1.ActionType.Criticality, appSchema, entityType, headerActions, index);
    }
}
/**
 * Checks if one of the uncritical actions is marked by isCopyAction.
 * If so, adds this first to the schema and deletes it from the list.
 * @param {ActionListType[]} unCriticalActions - list of uncritical actions
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {Definition} appSchema - schema of the object page
 * @param {EntityType} entityType - current entity type
 * @param {Definition} headerActions - list of all header actions
 * @param {number} nextIndex - index for propertyIndex
 */
function addCopyAction(unCriticalActions, oDataServiceAVT, appSchema, entityType, headerActions, nextIndex) {
    const copyActionIndex = unCriticalActions.findIndex((action) => {
        return action.item['annotations']?.UI?.IsCopyAction !== undefined;
    });
    if (copyActionIndex > -1) {
        addSingleHeaderActionV4(oDataServiceAVT, unCriticalActions[copyActionIndex], ux_specification_types_1.ActionType.Copy, appSchema, entityType, headerActions, nextIndex);
        nextIndex++;
        unCriticalActions.splice(copyActionIndex, 1);
    }
}
/**
 * Adds the critical header actions to schema
 * @param {ActionListType[]} unCriticalActions - list of uncritical actions
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {Definition} appSchema - schema of the object page
 * @param {EntityType} entityType - current entity type
 * @param {Definition} headerActions - list of all header actions
 * @param {number} nextIndex - index for propertyIndex
 */
function addUncriticalActions(unCriticalActions, oDataServiceAVT, appSchema, entityType, headerActions, nextIndex) {
    for (const action of unCriticalActions) {
        addSingleHeaderActionV4(oDataServiceAVT, action, ux_specification_types_1.ActionType.Annotation, appSchema, entityType, headerActions, nextIndex);
        nextIndex++;
    }
}
/**
 * Fills the annotationPath of the given schema definition, by checking first the EntitySet annotation, then the EntityType annotation.
 * @param {Definition} schemaDefinition - current definition in the schema
 * @param {EntitySet} entitySet - current entity set
 * @param {EntityType} entityType - current entity type
 * @param {string} annotationName - name of the annotation term to be checked
 */
function setAnnotationPathFromEntitySetOrEntityType(schemaDefinition, entitySet, entityType, annotationName) {
    if (entitySet?.annotations?.UI?.[annotationName] || !entityType?.annotations?.UI?.[annotationName]) {
        schemaDefinition[ux_specification_types_1.SchemaTag.annotationPath] =
            `/${entitySet.fullyQualifiedName}/${ux_specification_types_1.UIVOCABULARYALPHADOT}${annotationName}`;
    }
    else {
        schemaDefinition[ux_specification_types_1.SchemaTag.annotationPath] =
            `/${entityType.fullyQualifiedName}/${ux_specification_types_1.UIVOCABULARYALPHADOT}${annotationName}`;
    }
}
/**
 * Callback for adding a single action to headerActions of V4
 * @param {EntityType} entityType - current entity type
 * @param {Definition} appSchema - schema of the object page
 * @param {any} identification - UI.Identification annotation as present in AVT ConvertedMetadata
 * @param {Definition} headerActions - list of header actions, to be enhanced
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {EntitySet} entitySet - current entity set
 */
function addHeaderActionCallBackV4(entityType, appSchema, identification, headerActions, oDataServiceAVT, entitySet) {
    //Build groups of action types
    const { criticalActions = [], unCriticalActions = [] } = identification ? groupByCriticality(identification) : {};
    addCriticalActions(criticalActions, oDataServiceAVT, appSchema, entityType, headerActions);
    if (entitySet) {
        const isDeletable = (0, utils_3.isEntityDeletable)(entitySet);
        const isUpdatable = (0, utils_3.isEntityUpdatable)(entitySet);
        // Add standard header actions
        // If ReadOnly, and all capabilities restrictions are set to true or When nothing exists i.e. no capabilities annotation and no draft root, show only Delete button
        // If DraftRoot + DraftNode and dynamic value for restriction - show Edit and Delete, if bool == false then hide the button
        if ((0, utils_3.isDraftEnabled)(entitySet) && isUpdatable) {
            const editAction = addStandardHeaderAction('Edit', appSchema, headerActions, criticalActions.length);
            setAnnotationPathFromEntitySetOrEntityType(editAction, entitySet, entityType, 'UpdateHidden');
        }
        if (isDeletable) {
            const deleteAction = addStandardHeaderAction('Delete', appSchema, headerActions, criticalActions.length + 1);
            setAnnotationPathFromEntitySetOrEntityType(deleteAction, entitySet, entityType, 'DeleteHidden');
        }
    }
    const nextIndex = criticalActions.length + 2;
    //Check if isCopyAction is defined, this gets rendered first after delete
    addCopyAction(unCriticalActions, oDataServiceAVT, appSchema, entityType, headerActions, nextIndex);
    addUncriticalActions(unCriticalActions, oDataServiceAVT, appSchema, entityType, headerActions, nextIndex);
}
/**
 * Callback for adding a single action to footerActions of V4
 * @param {EntityType} entityType - current entity type
 * @param {Definition} appSchema - schema of the object page
 * @param {Definition} footerActions - list of footer actions, to be enhanced
 * @param {any} identification - UI.Identification annotation as present in AVT ConvertedMetadata
 */
function addFooterActionCallBackV4(entityType, appSchema, footerActions, identification) {
    const criticalActions = [];
    const unCriticalActions = [];
    identification.forEach((item, index) => {
        if (item['Determining'] && item.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* UIAnnotationTypes.DataFieldForAction */) {
            if (item['Criticality']) {
                criticalActions.push({ index, item });
            }
            else {
                unCriticalActions.push({ index, item });
            }
        }
    });
    for (let index = 0; index < criticalActions.length; index++) {
        const action = criticalActions[index];
        addSingleFooterAction(action, ux_specification_types_1.ActionType.Criticality, entityType, appSchema, footerActions, index);
    }
    for (let index = 0; index < unCriticalActions.length; index++) {
        const action = unCriticalActions[index];
        addSingleFooterAction(action, ux_specification_types_1.ActionType.Annotation, entityType, appSchema, footerActions, criticalActions.length + index);
    }
}
/**
 * Object Page specific enhancements to addCustomColumnDefinition
 * @param {object} appSchema - app schema of the object page
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {string} lineItemId - identifier of the current table in schema
 * @param {string} facetIdInManifest - identifier of the current object page section in manifest
 * @param {ExtensionLogger} logger - logger for exceptions
 */
function addCustomColumnsOP(appSchema, v4Page, lineItemId, facetIdInManifest, logger) {
    // Create type specific copy of 'TableCustomColumnOP'
    const useDefinitionAsKey = lineItemId !== ux_specification_types_1.DefinitionName.LineItems &&
        lineItemId !== 'LineItemsOfSPV::LineItem' &&
        lineItemId !== `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
    const customColumDefinitionKey = useDefinitionAsKey
        ? `${ux_specification_types_1.DefinitionName.CustomColumnOP}<${lineItemId}>`
        : ux_specification_types_1.DefinitionName.CustomColumnOP;
    const customColumnDefinition = appSchema.definitions[customColumDefinitionKey];
    customColumnDefinition[ux_specification_types_1.SchemaTag.isViewNode] = true;
    customColumnDefinition.description = 'Custom Column';
    // Update definitions for type specific custom columns
    const schemaId = `${ux_specification_types_1.DefinitionName.CustomColumnOP}<${lineItemId}>`;
    (0, utils_2.addCustomColumnDefinition)(appSchema, v4Page, logger, schemaId, lineItemId, facetIdInManifest);
    const facetKey = useDefinitionAsKey ? lineItemId : ux_specification_types_1.DefinitionName.PositionOP;
    (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.PositionOP, facetKey, appSchema, useDefinitionAsKey);
    const positionId = useDefinitionAsKey ? `${ux_specification_types_1.DefinitionName.PositionOP}<${lineItemId}>` : ux_specification_types_1.DefinitionName.PositionOP;
    customColumnDefinition.properties.position.$ref = `${common_1.DEFINITION_LINK_PREFIX}${positionId}`;
    (0, utils_2.addFragmentEnumForAnchor)(appSchema, lineItemId, v4Page, positionId, facetIdInManifest.replace(/::/g, '/'));
}
/**
 * Object Page specific enhancements to addCustomColumnDefinition
 * @param {object} appSchema - app schema of the object page
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {string} lineItemId - identifier of the current table in schema
 * @param {string} facetIdInManifest - identifier of the current object page section in manifest
 * @param {ExtensionLogger} logger - logger for exceptions
 */
function addTableCustomActionsOP(appSchema, v4Page, lineItemId, facetIdInManifest, logger) {
    // Create type specific copy of 'TableCustomActionOP'
    const useDefinitionAsKey = lineItemId !== ux_specification_types_1.DefinitionName.LineItems &&
        lineItemId !== 'LineItemsOfSPV::LineItem' &&
        lineItemId !== `@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
    const customActionDefinitionKey = useDefinitionAsKey
        ? `${ux_specification_types_1.DefinitionName.CustomTableActionOP}<${lineItemId}>`
        : ux_specification_types_1.DefinitionName.CustomTableActionOP;
    const customActionDefinition = appSchema.definitions[customActionDefinitionKey];
    customActionDefinition[ux_specification_types_1.SchemaTag.isViewNode] = true;
    customActionDefinition.description = CUSTOM_ACTION_DEFINITION_DESCRIPTION;
    // Update definitions for type specific custom columns
    const schemaId = `${ux_specification_types_1.DefinitionName.CustomTableActionOP}<${lineItemId}>`;
    const schemaIdForActions = `${ux_specification_types_1.DefinitionName.Actions}<${(0, common_1.prepareRef)(lineItemId)}>`;
    (0, utils_2.addCustomActionDefinition)(appSchema, v4Page, logger, schemaId, schemaIdForActions, facetIdInManifest);
    const facetKey = useDefinitionAsKey ? lineItemId : ux_specification_types_1.DefinitionName.CustomActionPositionOP;
    (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.CustomActionPositionOP, facetKey, appSchema, useDefinitionAsKey);
    // Anchor selection
    const positionId = useDefinitionAsKey
        ? `${ux_specification_types_1.DefinitionName.CustomActionPositionOP}<${lineItemId}>`
        : ux_specification_types_1.DefinitionName.CustomActionPositionOP;
    customActionDefinition.properties.position.$ref = `${common_1.DEFINITION_LINK_PREFIX}${positionId}`;
    (0, utils_2.addEnumForActionAnchor)(appSchema, schemaIdForActions, positionId);
}
/**
 * Object Page specific custom action enhancements to header and footer
 * @param {object} appSchema - app schema of the object page
 * @param {SapUiAppPageV4} v4Page  - current page in manifest
 * @param {DefinitionName} customActionDefinitionKey - custom action key used in definitions
 * @param {ExtensionLogger} logger - logger for exceptions
 */
function addHeaderFooterCustomActionsOP(appSchema, v4Page, customActionDefinitionKey, logger) {
    const customActionDefinition = appSchema.definitions[customActionDefinitionKey];
    customActionDefinition[ux_specification_types_1.SchemaTag.isViewNode] = true;
    customActionDefinition.description = CUSTOM_ACTION_DEFINITION_DESCRIPTION;
    const schemaIdForActions = customActionDefinitionKey === ux_specification_types_1.DefinitionName.CustomHeaderActionOP
        ? ux_specification_types_1.DefinitionName.ObjectPageHeaderActions
        : ux_specification_types_1.DefinitionName.FooterActions;
    (0, utils_1.addHeaderFooterCustomActionDefinition)(appSchema, v4Page, logger, customActionDefinitionKey, schemaIdForActions);
    const facetKey = customActionDefinitionKey === ux_specification_types_1.DefinitionName.CustomHeaderActionOP
        ? ux_specification_types_1.DefinitionName.CustomHeaderActionPositionOP
        : ux_specification_types_1.DefinitionName.CustomFooterActionPositionOP;
    (0, common_1.parseSchemaDefinition)(facetKey, facetKey, appSchema, false);
    // Anchor selection
    customActionDefinition.properties.position.$ref = `${common_1.DEFINITION_LINK_PREFIX}${facetKey}`;
    (0, utils_2.addEnumForActionAnchor)(appSchema, schemaIdForActions, facetKey);
    if (appSchema.definitions[schemaIdForActions]) {
        appSchema.definitions[schemaIdForActions].additionalProperties = {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${customActionDefinitionKey}`
        };
    }
}
/**
 * Object Page specific enhancements to handleFormIdentification
 * @param {object} appSchema - app schema of the object page
 * @param {SapUiAppPageV4} v4Page - current page in manifest
 * @param {string} formItemId - identifier of the current form in schema
 * @param {string} facetIdInManifest - identifier of the current object page section in manifest
 * @param {ExtensionLogger} logger - logger for exceptions
 */
function addFormCustomActionsOP(appSchema, v4Page, formItemId, facetIdInManifest, logger) {
    const customActionDefinitionKey = `${ux_specification_types_1.DefinitionName.CustomFormActionOP}<${formItemId}>`;
    const customActionDefinition = appSchema.definitions[customActionDefinitionKey];
    customActionDefinition[ux_specification_types_1.SchemaTag.isViewNode] = true;
    customActionDefinition.description = CUSTOM_ACTION_DEFINITION_DESCRIPTION;
    const schemaId = `${ux_specification_types_1.DefinitionName.CustomFormActionOP}<${formItemId}>`;
    const schemaIdForActions = `${ux_specification_types_1.DefinitionName.SectionActions}<${(0, common_1.prepareRef)(formItemId)}>`;
    (0, utils_2.addCustomActionDefinition)(appSchema, v4Page, logger, schemaId, schemaIdForActions, facetIdInManifest);
    (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.CustomActionPositionOP, formItemId, appSchema, true);
    // Anchor selection
    const positionId = `${ux_specification_types_1.DefinitionName.CustomActionPositionOP}<${formItemId}>`;
    customActionDefinition.properties.position.$ref = `${common_1.DEFINITION_LINK_PREFIX}${positionId}`;
    (0, utils_2.addEnumForActionAnchor)(appSchema, schemaIdForActions, positionId);
    if (appSchema.definitions[schemaIdForActions]) {
        appSchema.definitions[schemaIdForActions].additionalProperties = {
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${customActionDefinitionKey}`
        };
    }
}
/**
 * Adds definitions for line items in object page sections to the app schema
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {string} facetKey - key of the facet, as used in annotation
 * @param {Definition} appSchema - app schema of the object page
 * @param {object} lineItemFacet - current lineItem facet
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {ExtensionLogger} logger - logger for exceptions
 */
function handleLineItem(facet, facetKey, appSchema, lineItemFacet, oDataServiceAVT, v4Page, logger) {
    const lineItemId = (0, common_1.getFacetKeyInSchema)(facetKey);
    const index = facetKey.lastIndexOf('::');
    const annotation = index > -1 ? facetKey.substring(index + 2) : facetKey;
    const tableDefinition = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageTable, facetKey, appSchema);
    if (facet.entityType && annotation) {
        tableDefinition[ux_specification_types_1.SchemaTag.annotationPath] = `/${facet.entityType.fullyQualifiedName}/${annotation}`;
    }
    tableDefinition.properties.columns = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${lineItemId}`
    };
    tableDefinition.properties.toolBar.$ref = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageToolBar, facetKey);
    //adjust quickVariantSelection
    tableDefinition.properties.quickVariantSelection.$ref = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.QuickVariantSelectionV4OP, facetKey);
    const tableQVS = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.QuickVariantSelectionV4OP, facetKey, appSchema);
    tableQVS.properties.paths['items'].$ref = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.AnnotationPathAsObject, facetKey);
    (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.AnnotationPathAsObject, facetKey, appSchema);
    (0, common_1.addEnumForSingleTabVariant)(facet.entityType, appSchema, `${ux_specification_types_1.DefinitionName.AnnotationPathAsObject}<${lineItemId}>`);
    const dataForLineItem = {
        appSchema,
        lineItemAnnotation: lineItemFacet['target'],
        entityType: lineItemFacet['entityType'],
        oDataServiceAVT,
        lineItemId
    };
    (0, utils_2.addLineItemsTypeToSchema)(dataForLineItem, ux_specification_types_1.DefinitionName.ObjectPageTableColumn, ux_specification_types_1.DefinitionName.CustomColumnOP, ux_specification_types_1.DefinitionName.CustomTableActionOP);
    addCustomColumnsOP(appSchema, v4Page, lineItemId, facetKey, logger);
    addTableCustomActionsOP(appSchema, v4Page, lineItemId, facetKey, logger);
    return tableDefinition;
}
/**
 * Adds definitions for table section in object page sections to the app schema
 * @param {FacetConfig} facet - current facet
 * @param {string} facetKey - facet key
 * @param {Definition} appSchema - app specific schema of the object page that gets enhanced
 * @param {object} lineItemFacet - current lineItem facet
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {Definition} sections - schema of current sections definition.
 * @returns {object} sectionTable - section of app schema containing added table section
 */
function handleSectionTable(facet, facetKey, appSchema, lineItemFacet, generateParameters, v4Page, sections) {
    if (sections) {
        sections.properties[facetKey] = {
            $ref: (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageSectionTableV4, facetKey)
        };
    }
    const sectionTable = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageSectionTableV4, facetKey, appSchema);
    (0, common_1.addSectionTitleAndDescription)(facet, sectionTable, (0, common_1.getFacetKeyInSchema)(facetKey));
    sectionTable[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    sectionTable[ux_specification_types_1.SchemaTag.target] = facet.namespace;
    sectionTable.properties.table['$ref'] = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageTable, facetKey);
    const table = handleLineItem(facet, facetKey, appSchema, lineItemFacet, generateParameters.serviceAVT, v4Page, generateParameters.logger);
    return { sectionTable, table };
}
/**
 * Adds definitions for Identification and Form facet items in object page sections to the app schema
 * @param {FacetConfig} facet - current facet
 * @param {v4.SapUiAppPageV4} v4Page Current page in manifest
 * @param {string} facetKey - facet key
 * @param {object} sections - schema of current sections definition
 * @param {object} appSchema - app specific schema of the object page that gets enhanced
 * @param {SectionType} sectionPrefix - prefix to distinguish Section and HeaderSection
 * @param {ExtensionLogger} logger - logger for exceptions
 */
function handleFormIdentification(facet, v4Page, facetKey, sections, appSchema, sectionPrefix, logger) {
    let definitionType;
    if (sectionPrefix === ux_specification_types_1.SectionType.Section) {
        definitionType = ux_specification_types_1.DefinitionName.ObjectPageSectionForm;
    }
    else if (sectionPrefix === ux_specification_types_1.SectionType.HeaderSection) {
        definitionType = ux_specification_types_1.DefinitionName.ObjectPageHeaderSectionForm;
    }
    sections['properties'][facetKey] = {
        $ref: (0, common_1.getFacetDefinitionLink)(definitionType, facetKey)
    };
    const formSection = (0, common_1.parseSchemaDefinition)(definitionType, facetKey, appSchema);
    if (!facet.ID) {
        formSection.properties = {};
    }
    (0, common_1.addSectionTitleAndDescription)(facet, formSection, facetKey);
    formSection[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    formSection[ux_specification_types_1.SchemaTag.target] = facet.namespace;
    formSection[ux_specification_types_1.SchemaTag.isViewNode] = true;
    const targetId = (0, common_1.handleForm)(sectionPrefix, facet, formSection, appSchema, ux_specification_types_1.FioriElementsVersion.v4, facetKey);
    if (facet.base === ux_specification_types_1.FacetBase.Form) {
        const formItemId = (0, common_1.getFacetKeyInSchema)(facetKey);
        (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.CustomFormActionOP, targetId, appSchema);
        addFormCustomActionsOP(appSchema, v4Page, targetId, formItemId, logger);
    }
}
/**
 * Adds definitions for header sections (DataPoint, Chart) in object page sections to the app schema
 * @param {FacetConfig} facet - current facet
 * @param {string} facetKey - facet key
 * @param {object} sections - schema of current sections definition
 * @param {object} appSchema - app specific schema of the object page that gets enhanced
 * @param {SectionType} facetDefinitionKey - key to identify new definition
 */
function handleHeaderFacet(facet, facetKey, sections, appSchema, facetDefinitionKey) {
    sections['properties'][facetKey] = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${facetDefinitionKey}`
    };
    const sectionFacet = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.CommonHeaderFacetSettings, facetDefinitionKey, appSchema, false);
    (0, common_1.addTargetTitleAndSectionDescription)(facet, sectionFacet, facetKey);
    sectionFacet[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    sectionFacet[ux_specification_types_1.SchemaTag.target] = facet.namespace;
    sectionFacet[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataTypeOfTarget)(facet?.target);
    sectionFacet[ux_specification_types_1.SchemaTag.isViewNode] = true;
}
/**
 * Adds definitions for Chart items in object page sections to the app schema
 * @param {FacetConfig | Chart | object} facet - current facet.
 * @param {string} facetKey - facet key.
 * @param {object} appSchema - app specific schema of the object page that gets enhanced.
 * @param {EntityType} entityType - current entity type
 */
function handleChartActions(facet, facetKey, appSchema, entityType) {
    const actions = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageToolBarActions, facetKey, appSchema);
    actions.additionalProperties = false;
    actions.properties = {};
    if (facet.Actions) {
        let i = 0;
        facet.Actions.forEach((actionRecord) => {
            const description = (0, common_1.getDataFieldDescription)(actionRecord, entityType);
            const prefix = actionRecord.$Type.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
            const actionId = actionRecord.Action.replace('/', '::');
            const toolBarActionsProperty = (actions.properties[`${prefix}::${actionRecord.Action}`] = {
                $ref: (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageToolBarAction, actionId),
                description
            });
            toolBarActionsProperty[ux_specification_types_1.SchemaTag.propertyIndex] = i;
            toolBarActionsProperty[ux_specification_types_1.SchemaTag.annotationType] = actionRecord.$Type;
            const toolBarAction = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageToolBarAction, (0, common_1.prepareRef)(actionId), appSchema);
            toolBarAction[ux_specification_types_1.SchemaTag.annotationPath] = (0, common_1.getFacetAnnotationPath)(actionRecord);
            toolBarAction[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataType)(actionRecord);
            toolBarAction.properties = {};
            i++;
        });
    }
    return actions;
}
/**
 * Adds definitions for Chart items in object page sections to the app schema
 * @param {FacetConfig | Chart | object} facet - current facet.
 * @param {string} facetKey - facet key.
 * @param {object} appSchema - app specific schema of the object page that gets enhanced.
 * @param {EntityType} entityType - current entity type
 */
function handleChart(facet, facetKey, appSchema, entityType) {
    const chart = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageChart, facetKey, appSchema);
    if (facet['Title']) {
        chart.description = facet['Title'];
    }
    chart[ux_specification_types_1.SchemaTag.annotationPath] = (0, common_1.getFacetAnnotationPath)(facet);
    chart[ux_specification_types_1.SchemaTag.dataType] = (0, common_1.determineDataTypeOfTarget)(facet.target || facet);
    chart[ux_specification_types_1.SchemaTag.isViewNode] = true;
    chart.properties.toolBar['$ref'] = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageToolBar, facetKey);
    const chartToolBar = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageToolBar, facetKey, appSchema);
    chartToolBar.properties.actions['$ref'] = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageToolBarActions, facetKey);
    const chartActions = handleChartActions(facet, facetKey, appSchema, entityType);
    return { chart, chartActions };
}
/**
 * Adds definitions for Chart section in object page sections to the app schema
 * @param {FacetConfig} facet - current facet.
 * @param {string} facetKey - facet key.
 * @param {object} appSchema - app specific schema of the object page that gets enhanced.
 * @param {object} sections - schema of current sections definition.
 * @param {EntityType} entityType - current entity type
 */
function handleSectionChart(facet, facetKey, appSchema, sections, entityType = facet.entityType) {
    if (sections) {
        sections.properties[facetKey] = {
            $ref: (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageSectionChart, facetKey)
        };
    }
    const sectionChart = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.ObjectPageSectionChart, facetKey, appSchema);
    (0, common_1.addTargetTitleAndSectionDescription)(facet, sectionChart, facetKey);
    sectionChart[ux_specification_types_1.SchemaTag.annotationPath] = (0, common_1.getFacetAnnotationPath)(facet);
    sectionChart.properties.chart['$ref'] = (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageChart, facetKey);
    const { chart, chartActions } = handleChart(facet.target || facet, facetKey, appSchema, entityType);
    return { sectionChart, chart, chartActions };
}
/**
 * Adds definitions for presentation variants in object page sections to the app schema
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {string} facetKey - key of the facet, as used in annotation
 * @param {Definition} appSchema - app schema of the object page
 * @param {object} sections - schema of current sections definition.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 */
function handleSectionPresentationVariant(facet, facetKey, appSchema, sections, generateParameters, v4Page) {
    let facetTarget, visualizationKey, target;
    if (!facet?.target) {
        (0, extensionLogger_1.log)(generateParameters.logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOPRESENTATIONVARIANT', { key: facetKey })
        });
        return;
    }
    const visualizations = facet?.target?.Visualizations;
    const navPath = facetKey.lastIndexOf('::') > 0 ? facetKey.slice(0, facetKey.lastIndexOf('::')) : undefined;
    if (visualizations?.[0]) {
        if (visualizations[0].$target) {
            facetTarget = visualizations[0].$target;
            visualizationKey = `@${facetTarget.fullyQualifiedName.split('@')[1].split('/')[0]}`;
            target = facetTarget;
        }
        else {
            facetTarget = visualizations[0];
            visualizationKey =
                '@' +
                    (0, common_1.replaceAlias)(`${facetTarget.targetString.split('@')[1].split('/')[0]}`, generateParameters.serviceAVT);
            const navigationProp = generateParameters.entityType.navigationProperties.find((prop) => {
                return prop.name === navPath;
            });
            const targetType = navigationProp.targetType;
            const visualization = visualizationKey?.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
            target = visualization && targetType?.annotations?.UI[visualization];
        }
    }
    if (facetTarget) {
        const visualizationType = visualizationKey.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
        const namespace = facet.target[ux_specification_types_1.SchemaTag.fullyQualifiedName].split('@')[0];
        const fullVisualizationKey = navPath ? `${navPath}::${visualizationKey}` : visualizationKey;
        if (visualizationType.startsWith(ux_specification_types_1.Visualization.Chart)) {
            sections.properties[`${facetKey}<${visualizationKey}>`] = {
                $ref: (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageSectionChart, fullVisualizationKey)
            };
            const { sectionChart, chart } = handleSectionChart(facetTarget, fullVisualizationKey, appSchema, undefined, facet.entityType);
            sectionChart[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
            (0, common_1.addTargetTitleAndSectionDescription)(facet, sectionChart, facetKey);
            chart[ux_specification_types_1.SchemaTag.annotationPath] = `/${namespace}/${visualizationKey}`;
            chart[ux_specification_types_1.SchemaTag.target] = namespace;
        }
        else if (visualizationType.startsWith(ux_specification_types_1.Visualization.LineItem)) {
            sections.properties[`${facetKey}<${visualizationKey}>`] = {
                $ref: (0, common_1.getFacetDefinitionLink)(ux_specification_types_1.DefinitionName.ObjectPageSectionTableV4, fullVisualizationKey)
            };
            const { sectionTable, table } = handleSectionTable(facet, fullVisualizationKey, appSchema, { target, entityType: facet.entityType }, generateParameters, v4Page);
            sectionTable[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
            (0, common_1.addTargetTitleAndSectionDescription)(facet, sectionTable, facetKey);
            delete sectionTable[ux_specification_types_1.SchemaTag.isViewNode];
            table[ux_specification_types_1.SchemaTag.annotationPath] = `/${namespace}/${visualizationKey}`;
            table[ux_specification_types_1.SchemaTag.target] = namespace;
        }
    }
}
/**
 * Method checks if passed facet contains any collection facet.
 * @param {FacetConfig} facet - facet to check
 * @returns {boolean} Passed facet contains at least one collection facet
 */
function containsCollectionFacet(facet) {
    const childFacets = facet.facets || {};
    for (const id in childFacets) {
        const childFacet = childFacets[id];
        if (childFacet.base === ux_specification_types_1.FacetBase.CollectionFacet) {
            return true;
        }
    }
    return false;
}
/**
 * Object Page specific enhancements to addCustomColumnDefinition
 * @param {object} appSchema - app schema of the object page
 * @param {string} id - identifier of the current section facet
 * @param {string[]} featureToggles - supported features
 * @returns {string} Custom sub section reference id
 */
function createCustomSubSectionReference(appSchema, id, featureToggles) {
    const referenceId = `${ux_specification_types_1.DefinitionName.ObjectPageCustomSubSectionFragment}<${id}>`;
    const sourceDefinition = appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageCustomSubSectionFragment];
    if (typeof sourceDefinition === 'object') {
        const relatedFacetSchema = typeof sourceDefinition.properties?.relatedFacet === 'object'
            ? sourceDefinition.properties.relatedFacet
            : {};
        const newRef = {
            ...sourceDefinition,
            properties: {
                ...sourceDefinition.properties,
                relatedFacet: {
                    ...relatedFacetSchema,
                    type: 'string'
                }
            }
        };
        // Building blocks
        if ((0, common_1.isFeatureSupported)(featureToggles, ux_specification_types_1.Features.BuildingBlocks)) {
            newRef['properties']['controls'] = {
                type: 'object'
            };
        }
        appSchema.definitions[referenceId] = newRef;
    }
    return referenceId;
}
/**
 * Common method updates schema for custom header sections or custom subsections.
 * @param {Definition} sections - sections definition
 * @param {Definition} appSchema - app schema of the object page
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {string} facetKey - key of the facet, as used in annotation
 */
function applyCustomSections(sections, appSchema, generateParameters, v4Page, facet, facetKey) {
    let isMergedSections = false;
    let customSectionRef;
    // facet and facetkey are used for custom subsection definition
    if (facet && facetKey) {
        isMergedSections = !containsCollectionFacet(facet);
        customSectionRef = createCustomSubSectionReference(appSchema, facetKey, generateParameters.featureToggles);
    }
    else {
        // else use custom header section definition
        customSectionRef = ux_specification_types_1.DefinitionName.ObjectPageCustomHeaderSectionFragment;
    }
    sections.additionalProperties = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${customSectionRef}`
    };
    (0, utils_1.addCustomSectionDefinition)(appSchema, sections, v4Page, customSectionRef, isMergedSections, facetKey, generateParameters.logger);
    const sectionDefinition = appSchema.definitions[customSectionRef];
    if (typeof sectionDefinition === 'object') {
        (0, common_1.addDescriptiveEnumDefinition)(appSchema, sections, {
            schema: sectionDefinition,
            property: 'relatedFacet'
        }, {
            resolveDefinition: true,
            keyProperties: [ux_specification_types_1.SchemaKeyName.id, ux_specification_types_1.SchemaKeyName.key],
            descriptionAsFallback: true
        });
    }
    const relatedFacet = sectionDefinition.properties.relatedFacet;
    if (customSectionRef?.includes(ux_specification_types_1.DefinitionName.ObjectPageCustomSubSectionFragment) &&
        isMergedSections &&
        typeof relatedFacet === 'object') {
        // Exclude annotation nodes
        const section = v4Page.options?.settings?.content?.body?.sections?.[facetKey];
        const subSections = section && 'subSections' in section ? section.subSections : {};
        for (let i = relatedFacet.oneOf.length - 1; i >= 0; i--) {
            const entry = relatedFacet.oneOf[i];
            if (!subSections[entry.const]) {
                entry.hidden = true;
            }
        }
    }
}
/**
 * Adds definitions for collections in object page sections to the app schema
 * @param {FacetConfig} facet - the given facet from the UI annotations
 * @param {string} facetKey - key of the facet, as used in annotation
 * @param {Definition} appSchema - app schema of the object page
 * @param {Definition} sections - schema of current sections definition.
 * @param {SectionType} sectionPrefix - prefix to distinguish Section and HeaderSection
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {number} level Collection level in tree
 */
function handleCollection(facet, facetKey, appSchema, sections, sectionPrefix, generateParameters, v4Page, level) {
    const isCustomSubSectionsSupported = level === 0;
    const collectionFacet = (sections.properties[facetKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey));
    const subsections = {
        // Custom subsections are allowed on first level of subsections
        additionalProperties: false,
        type: 'object',
        properties: {},
        description: 'Subsections'
    };
    collectionFacet.properties = {
        subsections
    };
    subsections[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    subsections[ux_specification_types_1.SchemaTag.target] = facet.namespace;
    subsections[ux_specification_types_1.SchemaTag.keys] = [
        {
            name: ux_specification_types_1.SchemaKeyName.id,
            value: facet.ID
        }
    ];
    subsections[ux_specification_types_1.SchemaTag.isViewNode] = true;
    const nextLevel = level + 1;
    for (const key in facet.facets) {
        addSection(generateParameters, facet.facets, key, subsections, appSchema, sectionPrefix, v4Page, nextLevel);
    }
    if (isCustomSubSectionsSupported) {
        applyCustomSections(subsections, appSchema, generateParameters, v4Page, facet, facetKey);
    }
}
/**
 * Creates a section definition in app schema.
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {FacetConfigs} facets - list of all facets
 * @param {string} facetKey - facet key
 * @param {object} sections - schema of current sections definition
 * @param {object} appSchema - app specific schema of the object page that gets enhanced.
 * @param {SectionType} sectionPrefix - prefix to distinguish Section and HeaderSection
 * @param {SapUiAppPageV4} v4Page Current page in manifest
 * @param {number} [level=0] Section level in tree
 */
function addSection(generateParameters, facets, facetKey, sections, appSchema, sectionPrefix, v4Page, level = 0) {
    const facet = facets[facetKey];
    const facetDefinitionKey = `ObjectPage${sectionPrefix}${facet.base}<${(0, common_1.getFacetKeyInSchema)(facetKey)}>`;
    switch (facet.base) {
        case ux_specification_types_1.FacetBase.PresentationVariant: {
            handleSectionPresentationVariant(facet, facetKey, appSchema, sections, generateParameters, v4Page);
            break;
        }
        case ux_specification_types_1.FacetBase.CollectionFacet: {
            handleCollection(facet, facetKey, appSchema, sections, sectionPrefix, generateParameters, v4Page, level);
            break;
        }
        case ux_specification_types_1.FacetBase.LineItem: {
            if (sectionPrefix === ux_specification_types_1.SectionType.Section) {
                const lineItemFacet = facets[facetKey];
                handleSectionTable(facet, facetKey, appSchema, lineItemFacet, generateParameters, v4Page, sections);
            }
            break;
        }
        case ux_specification_types_1.FacetBase.Form:
        case ux_specification_types_1.FacetBase.Identification: {
            handleFormIdentification(facet, v4Page, facetKey, sections, appSchema, sectionPrefix, generateParameters.logger);
            break;
        }
        case ux_specification_types_1.FacetBase.DataPoint: {
            handleHeaderFacet(facet, facetKey, sections, appSchema, facetDefinitionKey);
            break;
        }
        case ux_specification_types_1.FacetBase.Chart: {
            if (sectionPrefix === ux_specification_types_1.SectionType.HeaderSection) {
                handleHeaderFacet(facet, facetKey, sections, appSchema, facetDefinitionKey);
            }
            else if (sectionPrefix === ux_specification_types_1.SectionType.Section) {
                handleSectionChart(facet, facetKey, appSchema, sections);
            }
            break;
        }
        case ux_specification_types_1.FacetBase.Address:
        case ux_specification_types_1.FacetBase.Contact: {
            (0, common_1.handleAddressContact)(facet, facetKey, sections, appSchema, sectionPrefix);
            break;
        }
        default: {
            sections['properties'][facetKey] = (0, common_1.createDefaultSection)(appSchema, facet, facetKey);
        }
    }
}
/**
 * Derives the sections from the UI.Facets annotation and adds them to the schema
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {object} appSchema - application specific JSON schema of the object page
 * @param {SapUiAppPageV4} v4Page - current page
 */
function addSections(generateParameters, appSchema, v4Page) {
    // Get facet annotations
    const facets = (0, common_1.getObjectPageFacets)(generateParameters.entityType, generateParameters.serviceAVT, ux_specification_types_1.FioriElementsVersion.v4, generateParameters.logger);
    if (!facets) {
        delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSubSections];
        return;
    }
    const sections = appSchema.definitions[ux_specification_types_1.DefinitionName.Sections];
    for (const facetKey in facets) {
        addSection(generateParameters, facets, facetKey, sections, appSchema, ux_specification_types_1.SectionType.Section, v4Page);
    }
    // Custom sections as part of sections
    if (appSchema.definitions[ux_specification_types_1.DefinitionName.CustomSections]) {
        sections.properties = {
            ...sections.properties,
            ...appSchema.definitions[ux_specification_types_1.DefinitionName.CustomSections].properties
        };
    }
}
/**
 * Derives the header sections from the UI.HeaderFacets annotation and adds them to the schema
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {object} appSchema - application specific JSON schema of the object page
 * @param {EntityType} entityType - current entity type
 * @param {SapUiAppPageV4} v4Page - current page in manifest
 */
function addHeaderSections(generateParameters, appSchema, entityType, v4Page) {
    // Get facet annotations
    const facets = (0, common_1.getObjectPageHeaderFacets)(entityType, generateParameters.serviceAVT, ux_specification_types_1.FioriElementsVersion.v4, generateParameters.logger);
    const sections = appSchema.definitions[ux_specification_types_1.DefinitionName.HeaderSections];
    sections.properties = {};
    sections.additionalProperties = false;
    if (!facets) {
        return;
    }
    // add annotation header sections
    for (const facetKey in facets) {
        addSection(generateParameters, facets, facetKey, sections, appSchema, ux_specification_types_1.SectionType.HeaderSection, v4Page);
    }
    // add custom header sections
    applyCustomSections(sections, appSchema, generateParameters, v4Page);
    //delete generic definitions
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageHeaderSectionForm];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageHeaderSectionChart];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageHeaderSectionDataPoint];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageHeaderSectionContact];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageHeaderSectionAddress];
}
/**
 * Adds the related facets keys 'enum' to the app schema
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {object} schema - app specific schema of the object page that gets enhanced
 * @param {SapUiAppPageV4[]} pages - list of all pages
 * @param {string} contextPath - contextPath of the actual (object) page
 */
function addRelatedFacetKeysType(generateParameters, schema, pages, contextPath) {
    Object.keys(pages).forEach((element) => {
        if (pages[element].options &&
            pages[element].options.settings &&
            (pages[element].options.settings.entitySet === generateParameters?.entitySet?.name ||
                (contextPath && pages[element].options.settings.contextPath === contextPath)) &&
            pages[element].name === ux_specification_types_1.v4.FE_TEMPLATE_V4_OBJECT_PAGE) {
            // Find sections from annotation
            const facetSections = (0, common_1.getObjectPageFacetSection)(generateParameters.entityType, generateParameters.serviceAVT, generateParameters.logger);
            // Find custom sections ids from manifest
            const page = pages[element];
            const customSections = page.options?.settings?.content?.body?.sections;
            if (customSections) {
                for (const key in customSections) {
                    const customSection = customSections[key];
                    // Avoid duplications
                    if (!facetSections.some((section) => section.key === key)) {
                        facetSections.push({
                            key,
                            title: customSection['title'],
                            custom: true
                        });
                    }
                }
            }
            // Update schema definition
            (0, common_1.addDefinitionForRelatedFacetKeys)(schema, [ux_specification_types_1.DefinitionName.ObjectPageCustomSectionFragment], facetSections, [
                'ID',
                'label',
                'key'
            ]);
        }
    });
}
/**
 * Add Object Page Header to app-specific schema
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Definition} appSchema Schema of the object page
 * @param {SapUiAppPageV4} v4Page - current page in manifest
 */
function addHeader(generateParameters, appSchema, v4Page) {
    const entityType = generateParameters.entityType;
    (0, common_1.addCommonHeaderSchema)(appSchema, entityType);
    // Add header actions
    (0, common_1.addHeaderActions)(appSchema, entityType, generateParameters.entitySet, generateParameters.serviceAVT, addHeaderActionCallBackV4);
    // Add custom header actions
    addHeaderFooterCustomActionsOP(appSchema, v4Page, ux_specification_types_1.DefinitionName.CustomHeaderActionOP, generateParameters.logger);
    // Add header sections
    if (entityType) {
        appSchema.definitions[ux_specification_types_1.DefinitionName.HeaderSections][ux_specification_types_1.SchemaTag.annotationPath] =
            `/${entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.HeaderFacets" /* UIAnnotationTerms.HeaderFacets */}`;
    }
    addHeaderSections(generateParameters, appSchema, entityType, v4Page);
}
/**
 * Generates an app specific schema out of the generic schema.
 * Generic types are replaced by information from the app specific annotations.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {object} genericSchema  - generic JSON schema of an object page
 * @param {string} contextPath - contextPath of the given page
 * @param {object} genericMacrosSchema - generic JSON schema of custom page
 *
 * @returns the app specific JSON schema
 */
function generateObjectPageSchemaV4(generateParameters, genericSchema, contextPath, genericMacrosSchema) {
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    // Change reference to generated sections
    appSchema.properties.sections = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.Sections}`
    };
    if (!generateParameters.manifest[ux_specification_types_1.ManifestSection.ui5].routing ||
        !generateParameters.manifest[ux_specification_types_1.ManifestSection.ui5].routing.targets) {
        (0, extensionLogger_1.log)(generateParameters.logger, {
            severity: "error" /* LogSeverity.Error */,
            message: i18next_1.default.t('NOROUTING'),
            location: {
                path: ux_specification_types_1.MANIFESTPATH
            }
        });
        return appSchema;
    }
    //initialize sections
    const sections = (appSchema.definitions[ux_specification_types_1.DefinitionName.Sections] = {
        type: 'object',
        properties: {},
        additionalProperties: false,
        description: ux_specification_types_1.DefinitionName.Sections
    });
    sections[ux_specification_types_1.SchemaTag.isViewNode] = true;
    if (generateParameters.entityType) {
        const pages = generateParameters.manifest[ux_specification_types_1.ManifestSection.ui5].routing
            .targets;
        if (!pages) {
            (0, extensionLogger_1.log)(generateParameters.logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOPAGES', { appId: generateParameters.manifest['sap.app']['id'] }),
                location: {
                    path: ux_specification_types_1.MANIFESTPATH,
                    range: [ux_specification_types_1.ManifestSection.generic]
                }
            });
            return appSchema;
        }
        const v4Page = (0, utils_2.findPageV4)(pages, ux_specification_types_1.v4.FE_TEMPLATE_V4_OBJECT_PAGE, generateParameters.entitySet, contextPath);
        if (!v4Page) {
            return appSchema;
        }
        // Add Header
        addHeader(generateParameters, appSchema, v4Page);
        // Add sections
        sections[ux_specification_types_1.SchemaTag.isViewNode] = true;
        if (generateParameters.entityType) {
            sections[ux_specification_types_1.SchemaTag.annotationPath] =
                `/${generateParameters.entityType.fullyQualifiedName}/@${"com.sap.vocabularies.UI.v1.Facets" /* UIAnnotationTerms.Facets */}`;
        }
        addSections(generateParameters, appSchema, v4Page);
        // Custom Section facets
        addRelatedFacetKeysType(generateParameters, appSchema, pages, contextPath);
        // Custom extension fragments
        if ((0, common_1.isFeatureSupported)(generateParameters.featureToggles, ux_specification_types_1.Features.BuildingBlocks) && genericMacrosSchema) {
            appSchema['definitions'][ux_specification_types_1.DefinitionName.ObjectPageCustomSectionFragment]['properties']['controls'] = {
                type: 'object'
            };
            try {
                (0, pageExtensions_1.resolveFragments)(appSchema, genericMacrosSchema, generateParameters, v4Page.id);
            }
            catch (error) {
                (0, extensionLogger_1.log)(generateParameters.logger, {
                    severity: "error" /* LogSeverity.Error */,
                    message: error
                });
            }
        }
        // Add Footer (actions only)
        (0, common_1.addFooterActions)(appSchema, generateParameters, ux_specification_types_1.FioriElementsVersion.v4, addFooterActionCallBackV4);
        addHeaderFooterCustomActionsOP(appSchema, v4Page, ux_specification_types_1.DefinitionName.CustomFooterActionOP, generateParameters.logger);
    }
    // Delete generic definitions from schema
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.CommonHeaderFacetSettings];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.GenericColumnsOP];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.GenericSections];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.GenericSubSections];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageChart];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionAddress];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionChart];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionContact];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionDataPoint];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionForm];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionTableV4];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSectionPresentationVariant];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageSubSections];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageTable];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageToolBar];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageToolBarAction];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ObjectPageToolBarActions];
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.QuickVariantSelectionV4OP];
    (0, common_1.updatePropertyIndices)(appSchema, ROOT_PROPERTIES_ORDER);
    return appSchema;
}
exports.generateObjectPageSchemaV4 = generateObjectPageSchemaV4;
//# sourceMappingURL=objectPage.js.map