"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.annotationMacrosHandlers = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const listReport_1 = require("../listReport");
const common_1 = require("../../../common");
const utils_1 = require("./utils");
const utils_2 = require("../../utils/utils");
/**
 * Method resolves passed "metaPath" property from XML node.
 * @param {string} metaPath "metaPath" property from XML node.
 * @returns {MetaPathResolution} Meta path resolution.
 */
function resolveMetaPath(metaPath) {
    const mataPathParts = metaPath.split('/');
    let navigationIndex = -1;
    for (let i = 0; i < mataPathParts.length; i++) {
        if (mataPathParts[i]) {
            if (!mataPathParts[i].startsWith('@')) {
                navigationIndex = i;
            }
            break;
        }
    }
    if (navigationIndex !== -1) {
        return {
            navigation: mataPathParts[navigationIndex],
            term: mataPathParts.slice(navigationIndex + 1, mataPathParts.length).join('/')
        };
    }
    return { term: metaPath };
}
/**
 * Method returns entity type for passed macros annotation handler params.
 * @param {HandlerParams} params Macros annotation handler params containing serviceAvt and connection context information.
 * @returns {EntityType | undefined} EntityType for passed connection.
 */
function getEntityTypeResolution(params) {
    const { node, serviceAVT, connectionContext } = params;
    const contextPath = (0, utils_1.getAttribute)(node, 'contextPath') || connectionContext.contextPath;
    let metaPath = (0, utils_1.getAttribute)(node, 'metaPath');
    const entitySet = connectionContext.entitySet;
    if (!contextPath && !entitySet) {
        return undefined;
    }
    let path = contextPath || `/${entitySet}`;
    if (metaPath) {
        const metaPathResolution = resolveMetaPath(metaPath);
        if (metaPathResolution.navigation) {
            path += '/' + metaPathResolution.navigation;
            metaPath = metaPathResolution.term;
        }
    }
    const resolvedContextPath = serviceAVT?.resolvePath(path);
    let entityType;
    switch (resolvedContextPath?.target?.['_type']) {
        case 'EntitySet': {
            entityType = resolvedContextPath.target.entityType;
            break;
        }
        case 'NavigationProperty': {
            entityType = resolvedContextPath.target.targetType;
            break;
        }
        case 'EntityType': {
            entityType = resolvedContextPath.target;
            break;
        }
    }
    return entityType
        ? {
            entityType,
            metaPath
        }
        : undefined;
}
/**
 * Method applies annotation path for passed XML node's schema.
 * @param {HandlerParams} schema Schema to update with "annotationPath".
 * @param {EntityTypeResolution} [entityTypeResolution] Entity type resolution object.
 */
function applyAnnotationPath(schema, entityTypeResolution) {
    if (entityTypeResolution?.metaPath) {
        const { entityType, metaPath } = entityTypeResolution;
        schema.annotationPath = `/${entityType.fullyQualifiedName}/${metaPath}`;
    }
}
/**
 * Method returns data for table annotation line items for passed entity type resolution.
 * @param {EntityTypeResolution} entityTypeResolution Entity type resolution object.
 * @param {ConvertedMetadata} serviceAVT Combined service metadata, as returned by annotation vocabularies tools.
 * @param {ConvertedMetadata} alias Annotation alias.
 * @returns {TableLineItemAnnotationData | undefined} Table annotation line items.
 */
function getTableLineItemAnnotationData(entityTypeResolution, serviceAVT, alias) {
    const { metaPath, entityType } = entityTypeResolution;
    let lineItem;
    let annotationPath;
    if (entityType && metaPath) {
        const annotation = (0, listReport_1.analyzeViewAnnotation)(metaPath, entityType?.annotations?.[alias], serviceAVT);
        if (annotation.visualization) {
            const annotationTerm = annotation.visualization.split('.')[1];
            lineItem = entityType?.annotations?.[alias]?.[annotationTerm];
            if (lineItem?.fullyQualifiedName) {
                annotationPath = (0, common_1.getAnnotationPathUsingFullyQualifiedName)(entityType, lineItem.fullyQualifiedName);
            }
        }
    }
    if (lineItem) {
        return {
            lineItem,
            annotationPath
        };
    }
    return undefined;
}
// Handlers map for macros controls
exports.annotationMacrosHandlers = {
    'sap.fe.macros.Chart': (params) => {
        const entityTypeResolution = getEntityTypeResolution(params);
        applyAnnotationPath(params.schema, entityTypeResolution);
    },
    'sap.fe.macros.FilterBar': (params) => {
        const { schema, serviceAVT, rootSchema } = params;
        const entityTypeResolution = getEntityTypeResolution(params);
        // Handler selection fields
        const filterFieldsDefinition = schema.properties?.filterFields;
        if (typeof filterFieldsDefinition === 'object' && entityTypeResolution) {
            if (!filterFieldsDefinition.properties) {
                filterFieldsDefinition.properties = {};
            }
            const alias = (0, common_1.findAlias)(ux_specification_types_1.UIVOCABULARY, serviceAVT);
            const selectionFieldAnnotation = alias && entityTypeResolution.entityType?.annotations?.[alias]?.SelectionFields;
            (0, listReport_1.addSelectionFields)(entityTypeResolution.entityType, rootSchema, selectionFieldAnnotation, filterFieldsDefinition);
        }
    },
    'sap.fe.macros.Table': (params) => {
        const { schema, serviceAVT, rootSchema } = params;
        const entityTypeResolution = getEntityTypeResolution(params);
        const colDefinition = schema.properties.columns;
        const actionDefinition = schema.properties.actions;
        if (typeof colDefinition === 'object' && typeof actionDefinition === 'object' && entityTypeResolution) {
            if (!colDefinition.properties) {
                colDefinition.properties = {};
            }
            if (!actionDefinition.properties) {
                actionDefinition.properties = {};
            }
            const alias = (0, common_1.findAlias)(ux_specification_types_1.UIVOCABULARY, serviceAVT);
            applyAnnotationPath(schema, entityTypeResolution);
            if (schema.annotationPath) {
                const annotationData = getTableLineItemAnnotationData(entityTypeResolution, serviceAVT, alias);
                if (annotationData?.annotationPath) {
                    schema.annotationPath = annotationData.annotationPath;
                }
                const dataForLineItem = {
                    appSchema: rootSchema,
                    lineItemAnnotation: annotationData.lineItem,
                    entityType: entityTypeResolution.entityType,
                    oDataServiceAVT: serviceAVT,
                    lineItemId: ux_specification_types_1.DefinitionName.LineItems
                };
                (0, utils_2.appendLineItemsToSchema)(dataForLineItem, actionDefinition, schema.annotationPath, colDefinition);
            }
        }
    }
};
//# sourceMappingURL=annotations.js.map