"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportXMLFragmentConfig = exports.exportFPMCustomPageConfig = void 0;
const xml_js_1 = require("xml-js");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const utils_1 = require("../utils/utils");
const macros_1 = require("../utils/macros");
/**
 * Method compares values if values are different after converted to string.
 * It is used to determine if we need make change in XML file.
 * @param {unknown} value1 First value to compare.
 * @param {unknown} value2 Second value to compare.
 * @returns {boolean} Returns true if values are same after values converted to string.
 */
function isExportValueEquals(value1, value2) {
    return value1 !== undefined && value2 !== undefined ? `${value1}` === `${value2}` : value1 === value2;
}
/**
 * Method deletes property by emoving attribute from element.
 * Method also considers if it is last attribute and element is complex property, then element would removed as well.
 * @param {TraverseData} traverseData Schema and XML traverse data.
 * @param {string} name Name of property.
 */
function deleteProperty(traverseData, name) {
    const { element, schema, parent, contextPath } = traverseData;
    delete element.attributes[name];
    if (schema.metadata?.type === ux_specification_types_1.MacrosPropertyType.Property &&
        Object.keys(element.attributes).length === 0 &&
        parent?.element.elements) {
        // Last attribute is deleted for property - if element is property then remove property itself
        const context = contextPath[contextPath.length - 1];
        if (context) {
            parent.element.elements.splice(context.index, 1);
        }
    }
}
/**
 * Callback method of traversing schema and XML.
 * Method exports value from page config object to XML element.
 * @param {TraverseData} traverseData Schema and XML traverse data.
 * @param {SchemaDefinition} property Schema property to use for export.
 * @param {object} config Fragment of page config object.
 * @param {string} name Name of property to export.
 * @returns {boolean} Is new value differs.
 */
function exportProperty(traverseData, property, config, name) {
    const { contextPath, fullSchema, element } = traverseData;
    let differs = false;
    if (property.hidden) {
        // Currently we ignore hidden properties
        return false;
    }
    if (name in config && config[name] !== undefined) {
        if (property.isViewNode) {
            if (!element.elements) {
                element.elements = [];
            }
            const targetElement = {
                name,
                type: 'element'
            };
            element.elements.push(targetElement);
            return (0, macros_1.traverseSchema)({
                fullSchema: fullSchema,
                schema: property,
                element: targetElement,
                contextPath: [
                    ...contextPath,
                    {
                        name,
                        index: 0
                    }
                ],
                config: config[name],
                parent: traverseData
            }, exportProperty);
        }
        else if (!isExportValueEquals(element.attributes?.[name], config[name])) {
            if (!element.attributes) {
                element.attributes = {};
            }
            element.attributes[name] = config[name];
            differs = true;
        }
    }
    else if (element.attributes?.[name]) {
        deleteProperty(traverseData, name);
        differs = true;
    }
    return differs;
}
/**
 * Populates export results with data from extension.
 * @param {ExtensionFileData} extensionData Extension data from parsed XML file.
 * @param {ExportResults} exportResults Export results API parameters needed for the export.
 * @param {object} config Extension of page config object.
 * @param {SchemaDefinition} jsonSchema Extesion definition schema.
 * @param {string} extensionType Extension type - view or fragment.
 * @param {ExtensionLogger | undefined} logger Logger class for logging messages.
 */
function getExtensionExportResult(extensionData, exportResults, config, jsonSchema, extensionType, logger) {
    const element = (0, macros_1.parseXML)(extensionData.file, false, logger);
    if (element) {
        const coreElement = (0, macros_1.getRootElement)(element);
        const differs = (0, macros_1.traverseSchema)({
            fullSchema: jsonSchema,
            schema: jsonSchema,
            element: coreElement,
            contextPath: [],
            config
        }, exportProperty);
        if (differs) {
            const fileContent = (0, xml_js_1.js2xml)(element, { spaces: 4 });
            const extensionExportResult = {
                dataSourceUri: extensionData.file.dataSourceUri,
                fileContent,
                changeIndicator: ux_specification_types_1.ChangeIndicator.Updated
            };
            if (extensionType === 'view') {
                exportResults.views = [extensionExportResult];
            }
            else if (extensionType === 'fragment') {
                exportResults.fragments.push(extensionExportResult);
            }
        }
    }
}
/**
 * Run through the given FPM Custom Page config and return respective XML View result.
 * If no changes in config, then view is not returned.
 * @param {ExportListReportV4Parameters} exportParameters All API parameters needed for the export.
 * @param {ExportResults} defaultExportResult Default export result.
 * @param {FeatureToggle[]} [featureToggles] - array of supported features.
 * @returns {ExportResults} Object comprising the updated xml view
 */
const exportFPMCustomPageConfig = (exportParameters, defaultExportResult) => {
    const exportResults = { ...defaultExportResult };
    const { views, manifest, jsonSchema, page, logger } = exportParameters;
    let viewData = undefined;
    if (jsonSchema && Object.keys(jsonSchema).length > 0) {
        viewData = (0, utils_1.getPageCustomViewFile)(views || [], page.name, manifest, logger);
    }
    if (viewData) {
        getExtensionExportResult(viewData, exportResults, page.config, jsonSchema, 'view', logger);
    }
    return exportResults;
};
exports.exportFPMCustomPageConfig = exportFPMCustomPageConfig;
/**
 * Runs through the given config and pushes changed fragments into export results.
 * @param {TransferParameterTypeV4} transferParameters List of transfer parameters passed from API.
 * @param {string} fragmentName Full name of the fragment.
 * @param {object} config Current (sub)object of the configuration file.
 */
const exportXMLFragmentConfig = (transferParameters, fragmentName, config) => {
    const { appSchema, exportResults, fragments, pageNameArray, logger } = transferParameters;
    const { manifest } = exportResults;
    let fragmentData = undefined;
    const extensionType = 'fragment';
    if (appSchema && Object.keys(appSchema).length > 0) {
        const targetManifestPage = (0, utils_1.getManifestPage)(manifest, pageNameArray[0]);
        fragmentData = (0, utils_1.getPageCustomExtensionFile)(fragments, targetManifestPage, manifest, extensionType, fragmentName);
    }
    if (fragmentData) {
        const definitionKey = (0, macros_1.getCustomExtensionFragmentDefinitionKey)(fragmentName);
        const targetConfigSchema = appSchema['definitions'][definitionKey];
        const tempSchema = {
            ...targetConfigSchema,
            definitions: appSchema['definitions']
        };
        getExtensionExportResult(fragmentData, exportResults, config, tempSchema, extensionType, logger);
    }
};
exports.exportXMLFragmentConfig = exportXMLFragmentConfig;
//# sourceMappingURL=fpmCustomPage.js.map